<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>eloquent</title>
<!-- 2016-10-11 Tue 03:47 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="your name" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>

         <link href="http://fonts.googleapis.com/css?family=Droid+Sans+Mono|Galdeano|Open+Sans:600italic,400,600|Roboto+Condensed:400,700" rel="stylesheet" type="text/css">
         <link rel="stylesheet" type="text/css" href="/static/css/main.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
<script type="text/javascript" src="http://orgmode.org/mathjax/MathJax.js"></script>
<script type="text/javascript">
<!--/*--><![CDATA[/*><!--*/
    MathJax.Hub.Config({
        // Only one of the two following lines, depending on user settings
        // First allows browser-native MathML display, second forces HTML/CSS
        //  config: ["MMLorHTML.js"], jax: ["input/TeX"],
            jax: ["input/TeX", "output/HTML-CSS"],
        extensions: ["tex2jax.js","TeX/AMSmath.js","TeX/AMSsymbols.js",
                     "TeX/noUndefined.js"],
        tex2jax: {
            inlineMath: [ ["\\(","\\)"] ],
            displayMath: [ ['$$','$$'], ["\\[","\\]"], ["\\begin{displaymath}","\\end{displaymath}"] ],
            skipTags: ["script","noscript","style","textarea","pre","code"],
            ignoreClass: "tex2jax_ignore",
            processEscapes: false,
            processEnvironments: true,
            preview: "TeX"
        },
        showProcessingMessages: true,
        displayAlign: "center",
        displayIndent: "2em",

        "HTML-CSS": {
             scale: 100,
             availableFonts: ["STIX","TeX"],
             preferredFont: "TeX",
             webFont: "TeX",
             imageFont: "TeX",
             showMathMenu: true,
        },
        MMLorHTML: {
             prefer: {
                 MSIE:    "MML",
                 Firefox: "MML",
                 Opera:   "HTML",
                 other:   "HTML"
             }
        }
    });
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="http://harrifeng.github.io/sitemap.html"> UP </a>
 |
 <a accesskey="H" href="http://harrifeng.github.io/index.html"> HOME </a>
</div><div id="preamble" class="status">

         <div id="header">
            <div id="header-top">
                <div id="blog-title">Harrifeng's Path</div>
                <div id="blog-sub-title">纸上得来终觉浅,绝知此事要Coding</div>
            </div>
            <div id="nav">
                <ul>
                    <li><a href="/">首页</a></li>
                    <li><a href="/about.html">About Me</a></li>
                    <li>
                    </li>
                </ul>
            </div>
         </div>
</div>
<div id="content">
<h1 class="title">eloquent</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Chapter 01: Write Code That Looks Like Ruby</a>
<ul>
<li><a href="#sec-1-1">The Very Basic Basics</a></li>
<li><a href="#sec-1-2">Go Easy on the Comments</a></li>
<li><a href="#sec-1-3">Camels for Classes, Snakes Everywhere Else</a></li>
<li><a href="#sec-1-4">Parentheses Are Optional but Are Occasionally Forbidden</a></li>
<li><a href="#sec-1-5">Folding Up Those Lines</a></li>
<li><a href="#sec-1-6">Folding Up THose Code Blocks</a></li>
<li><a href="#sec-1-7">Staying Out of Trouble</a></li>
<li><a href="#sec-1-8">In the Wild</a></li>
</ul>
</li>
<li><a href="#sec-2">Chapter 02: Choose the Right Control Structure</a>
<ul>
<li><a href="#sec-2-1">If, Unless, While, and Until</a></li>
<li><a href="#sec-2-2">Use the Modifier Forms Where Appropriate</a></li>
<li><a href="#sec-2-3">Use each, Not for</a></li>
<li><a href="#sec-2-4">A Case of Programming Logic</a></li>
<li><a href="#sec-2-5">Staying Out of Trouble</a></li>
<li><a href="#sec-2-6">In the Wild</a></li>
</ul>
</li>
<li><a href="#sec-3">Chapter 03: Take Advantage of Ruby's Smart Collections</a>
<ul>
<li><a href="#sec-3-1">Literal Shortcuts</a></li>
<li><a href="#sec-3-2">Instant Arrays and Hashes from Method Calls</a></li>
<li><a href="#sec-3-3">Running Through Your Collection</a></li>
<li><a href="#sec-3-4">Beware the Bang!</a></li>
<li><a href="#sec-3-5">Rely on the Order of Your Hashes</a></li>
<li><a href="#sec-3-6">In the Wild</a></li>
<li><a href="#sec-3-7">Staying Out</a></li>
</ul>
</li>
<li><a href="#sec-4">Chapter 04: Take Advantage of Ruby's Smart Strings</a>
<ul>
<li><a href="#sec-4-1">Coming Up with a String</a></li>
<li><a href="#sec-4-2">Another API to Master</a></li>
<li><a href="#sec-4-3">The String: A Place for Your Lines, Characters, and Bytes</a></li>
<li><a href="#sec-4-4">In the Wild</a></li>
<li><a href="#sec-4-5">Staying Out of Trouble</a></li>
</ul>
</li>
<li><a href="#sec-5">Chapter 05: Find the Right String with Regular Expressions</a>
<ul>
<li><a href="#sec-5-1">Matching One Character at a Time</a></li>
<li><a href="#sec-5-2">Sets, Ranges, and Alternatives</a></li>
<li><a href="#sec-5-3">The Regular Expression Star</a></li>
<li><a href="#sec-5-4">Regular Expressions in Ruby</a></li>
<li><a href="#sec-5-5">Beginnings and Endings</a></li>
<li><a href="#sec-5-6">In the Wild</a></li>
<li><a href="#sec-5-7">Staying Out of Trouble</a></li>
</ul>
</li>
<li><a href="#sec-6">Chapter 06: Use Symbols to Stand for Something</a>
<ul>
<li><a href="#sec-6-1">The Two Faces of Strings</a></li>
<li><a href="#sec-6-2">Not Quite a String</a></li>
<li><a href="#sec-6-3">Optimized to Stand for Something</a></li>
<li><a href="#sec-6-4">In the Wild</a></li>
<li><a href="#sec-6-5">Staying Out of Trouble</a></li>
</ul>
</li>
<li><a href="#sec-7">Chapter 07: Treat Everything Like an Object &#x2013; Because Everything Is</a>
<ul>
<li><a href="#sec-7-1">A Quick Review of Clases, Instances, and Methods</a></li>
<li><a href="#sec-7-2">Objects All the Way Down</a></li>
<li><a href="#sec-7-3">The Importance of Being an Object</a></li>
<li><a href="#sec-7-4">Public, Private, and Protected</a></li>
<li><a href="#sec-7-5">In the Wild</a></li>
<li><a href="#sec-7-6">Staying Out of Trouble</a></li>
</ul>
</li>
<li><a href="#sec-8">Chapter 08: Embrace Dynamic Typing</a>
<ul>
<li><a href="#sec-8-1">Shorter Programs, But Not the Way You Think</a></li>
<li><a href="#sec-8-2">Extreme Decoupling</a></li>
<li><a href="#sec-8-3">Required Ceremony Versus Programmer-Driven Clarity</a></li>
<li><a href="#sec-8-4">Staying Out of Trouble</a></li>
<li><a href="#sec-8-5">In the Wild</a></li>
</ul>
</li>
<li><a href="#sec-9">Chapter 09: Write Specs!</a>
<ul>
<li><a href="#sec-9-1">Test::Unit: When Your Documents Just Have to Work</a></li>
<li><a href="#sec-9-2">A Plethora of Assertions</a></li>
<li><a href="#sec-9-3">Don't Test Il, Spec It!</a></li>
<li><a href="#sec-9-4">A Tidy Spec Is a Readable Spec</a></li>
</ul>
</li>
<li><a href="#sec-10">Chapter 10: Construct Your Classes from Short, Focused Methods</a>
<ul>
<li><a href="#sec-10-1">Compressing Specifications</a></li>
<li><a href="#sec-10-2">Composing Methods for Humans</a></li>
<li><a href="#sec-10-3">Composing Ruby Methods</a></li>
<li><a href="#sec-10-4">One Way Out?</a></li>
<li><a href="#sec-10-5">Staying Out of Trouble</a></li>
<li><a href="#sec-10-6">In the Wild</a></li>
</ul>
</li>
<li><a href="#sec-11">Chapter 11: Define Operators Respectfully</a>
<ul>
<li><a href="#sec-11-1">Defining Operators in Ruby</a></li>
<li><a href="#sec-11-2">A Sampling of Operators</a></li>
<li><a href="#sec-11-3">Operating Across Classes</a></li>
<li><a href="#sec-11-4">Staying Out of Trouble</a></li>
<li><a href="#sec-11-5">In the Wild</a></li>
</ul>
</li>
<li><a href="#sec-12">Chapter 12: Create Classes That Understand Equality</a>
<ul>
<li><a href="#sec-12-1">An Identifier for Your Documents</a></li>
<li><a href="#sec-12-2">An Embarrassment of Equality</a></li>
<li><a href="#sec-12-3">Double Equals for Everyday Use</a></li>
<li><a href="#sec-12-4">Broadening the Appeal of the == Method</a></li>
<li><a href="#sec-12-5">Well-Behaved Equality</a></li>
<li><a href="#sec-12-6">Triple Equals for Case Statements</a></li>
<li><a href="#sec-12-7">Hash Tables and the eql? Method</a></li>
<li><a href="#sec-12-8">Building a Well-Behaved Hash Key</a></li>
<li><a href="#sec-12-9">Staying Out of Trouble</a>
<ul>
<li><a href="#sec-12-9-1">In the Wild</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-13">Chapter 13: Get the Behavior You Nedd with Singleton and Class Methods</a>
<ul>
<li><a href="#sec-13-1">A Stubby Puzzle</a></li>
<li><a href="#sec-13-2">A Hidden, but Real Class</a></li>
<li><a href="#sec-13-3">Class Methods: Singletons in Plain Sight</a></li>
<li><a href="#sec-13-4">In the Wild</a></li>
<li><a href="#sec-13-5">Staying Out of Trouble</a></li>
</ul>
</li>
<li><a href="#sec-14">Chapter 14: Use Class Instance Variables</a>
<ul>
<li><a href="#sec-14-1">A Quick Review of Class Variables</a></li>
<li><a href="#sec-14-2">Wandering Variables</a></li>
<li><a href="#sec-14-3">Getting Control of the Data in Your Class</a></li>
<li><a href="#sec-14-4">Class Instance Variable and Subclasses</a></li>
<li><a href="#sec-14-5">Adding Some Convenience to Your Class Instance</a></li>
<li><a href="#sec-14-6">In the Wild</a></li>
<li><a href="#sec-14-7">Staying Out of Trouble</a></li>
</ul>
</li>
<li><a href="#sec-15">Chapter 15: Use Modules as Name Spaces</a>
<ul>
<li><a href="#sec-15-1">A Place for Your Stuff, with a Name</a></li>
<li><a href="#sec-15-2">A Home for Those Utility Methods</a></li>
<li><a href="#sec-15-3">Building Modules a Little at a Time</a></li>
<li><a href="#sec-15-4">Treat Modules Like the Objects That They Are</a></li>
<li><a href="#sec-15-5">Staying Out of Trouble</a></li>
<li><a href="#sec-15-6">In the Wild</a></li>
</ul>
</li>
<li><a href="#sec-16">Chapter 16: Use Modules as Mixins</a>
<ul>
<li><a href="#sec-16-1">Better Books with Modules</a></li>
<li><a href="#sec-16-2">Mixin Modules to the Rescue</a></li>
<li><a href="#sec-16-3">Extending a Module</a></li>
<li><a href="#sec-16-4">Staying Out of Trouble</a></li>
<li><a href="#sec-16-5">In the Wild</a></li>
</ul>
</li>
<li><a href="#sec-17">Chapter 17: Use Blocks to Iterate</a>
<ul>
<li><a href="#sec-17-1">A Quick Review of Code Blocks</a></li>
<li><a href="#sec-17-2">One Word after Another</a></li>
<li><a href="#sec-17-3">As Many Iterators as You Like</a></li>
<li><a href="#sec-17-4">Iterating over the Ethereal</a></li>
<li><a href="#sec-17-5">Enumerable: Your Iterator on Steroids</a></li>
<li><a href="#sec-17-6">Staying Out of Trouble</a></li>
<li><a href="#sec-17-7">In the Wild</a></li>
</ul>
</li>
<li><a href="#sec-18">Chapter 18: Execute Around with a Block</a>
<ul>
<li><a href="#sec-18-1">Add a Little Logging</a></li>
<li><a href="#sec-18-2">Carring the Answers Back</a></li>
<li><a href="#sec-18-3">When It Absolutely Must Happen</a></li>
<li><a href="#sec-18-4">Setting Up Objects with an Initialization Block</a></li>
<li><a href="#sec-18-5">Dragging Your Scope along with the Block</a></li>
<li><a href="#sec-18-6">Carrying the Answers Back</a></li>
<li><a href="#sec-18-7">Staying Out of Trouble</a></li>
<li><a href="#sec-18-8">In the Wild</a></li>
</ul>
</li>
<li><a href="#sec-19">Chapter 19: Save Blocks to Execute Later</a>
<ul>
<li><a href="#sec-19-1">Explicit Blocks</a></li>
<li><a href="#sec-19-2">The Call Back Problem</a></li>
<li><a href="#sec-19-3">Banking Blocks</a></li>
<li><a href="#sec-19-4">Saving Code Blocks for Lazy Initialization</a></li>
<li><a href="#sec-19-5">Instant Block objects</a></li>
<li><a href="#sec-19-6">Staying Out of Trouble</a></li>
<li><a href="#sec-19-7">In the Wild</a></li>
</ul>
</li>
<li><a href="#sec-20">Chapter 20: Use Hooks to Keep Your Program Informed</a>
<ul>
<li><a href="#sec-20-1">Waking Up to a New Subclass</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Chapter 01: Write Code That Looks Like Ruby</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">The Very Basic Basics</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>Ruby style的核心:
<ul class="org-ul">
<li>首先,代码要清晰
<pre class="example">
Good code tells the reader exactly what it is trying to do.
Great code shouts its intent
</pre>
</li>
<li>其次,代码要简单, 简单才更容易清晰
</li>
</ul>
</li>
<li>看个例子
<div class="org-src-container">

<pre class="src src-ruby">class Document
  attr_accessor :title, :author, :content

  def initialize(title, author, content)
    @title         title
    @author        author
    @content       content
  end

  def words
    @content.split
  end

  def word_count
    words.size
  end
end
</pre>
</div>
</li>
<li>上面的代码,可以看到ruby缩进的规则
<ul class="org-ul">
<li>ruby使用了2空格的缩进,基本上是能察觉到的最短的缩进,为了写更多的代码
</li>
<li>ruby绝不使用tab,而是使用2空格代替
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Go Easy on the Comments</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>ruby有两种的不同的注释手段:
<ul class="org-ul">
<li>使用'#'在行首
</li>
<li>使用=begin 和=end
</li>
</ul>
</li>
<li>ruby是一种self-explain的语言,所以如果代码能够解释自己的话,就不需要注释
</li>
<li>最需要写的注释是"如何使用你的代码", 而不是"我为什么要这样写代码, 你使用了什
么算法, 你以后要做什么改进", 比如,下面就是一个很好的comment
<div class="org-src-container">

<pre class="src src-ruby"># Class that models a plain text document, complete with title and author
#
# doc Document.new('Hamlet', 'Shakespeare', 'To be or ...')
# puts doc.title
# puts doc.author
# puts doc.content
#
# Document instances know how to parse their content into words:
#
# puts doc.words
# puts doc.word_count
#

class Document
  # class omitted..
end
</pre>
</div>
</li>
<li>还有一种好的comment是"代码如何工作"
</li>
<li>此外还有作者信息,版权信息
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Camels for Classes, Snakes Everywhere Else</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>函数变量命名的方式,总结起来就是:
<ul class="org-ul">
<li>类名使用首字母大写的"骑驼峰"
<div class="org-src-container">

<pre class="src src-ruby">class Document
  # ...
end
</pre>
</div>
</li>
<li>常亮使用全部大写,以下划线分割
<div class="org-src-container">

<pre class="src src-ruby">ANTLERS_PER_MALE_MOOSE 2
</pre>
</div>
</li>
<li>其他全部的情况都是小写字母,以下划线分割
<div class="org-src-container">

<pre class="src src-ruby">def count_words_in(the_string)
  the_words the_string.split
  the_words.size
end
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">Parentheses Are Optional but Are Occasionally Forbidden</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>ruby让你可以省略括号!无论是定义还是使用的时候:
<ul class="org-ul">
<li>比如下面的代码
<div class="org-src-container">

<pre class="src src-ruby">def find_document(title, author)
  # Body omitted...
end

# ...
find_document('Frankenstein', 'Shelley')
</pre>
</div>
</li>
<li>可以完全去掉括号,写成如下
<div class="org-src-container">

<pre class="src src-ruby">def find_document title, author
  # Body ommited...
end

find_document 'Frankenstein', 'Shelley'
</pre>
</div>
</li>
</ul>
</li>
<li>在括号这件事情上,即便是懒惰的ruby工程师也觉得做的过火了.所以并没有多少情况
下, 括号是可以被省略的,总结起来,也就如下几种:
<ul class="org-ul">
<li>函数参数只有一个, 而且大家非常熟悉的函数,比如puts
</li>
<li>函数参数没有, 即便大家不熟悉,也可以不使用括号,比如
<div class="org-src-container">

<pre class="src src-ruby">def words
  @content.split
end

# is more often used than

def words()
  @content.split
end
</pre>
</div>
</li>
<li>在条件判断的时候,我们也倾向去不使用括号
<div class="org-src-container">

<pre class="src src-ruby">if words.size &gt; 100
  puts "The document is not very long"
end

# is more often used than

if (words.size &gt; 100)
  puts "The document is not very long"
end
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">Folding Up Those Lines</h3>
<div class="outline-text-3" id="text-1-5">
<ul class="org-ul">
<li>几行代码写成一行的时候,要使用分号.不过这个规则不常用
<div class="org-src-container">

<pre class="src src-ruby">puts doc.title; puts doc.author
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6">Folding Up THose Code Blocks</h3>
<div class="outline-text-3" id="text-1-6">
<ul class="org-ul">
<li>{} 和 do/end都能处理block, 前者处理单行的, 后者处理多行的
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7">Staying Out of Trouble</h3>
<div class="outline-text-3" id="text-1-7">
<ul class="org-ul">
<li>尽管ruby可以让你少些代码,写短代码,但是"可读性"仍然是最最重要的
<ul class="org-ul">
<li>{}尽快是控制一行的,但是如果这个行太长,还是可以使用do/end替代
<div class="org-src-container">

<pre class="src src-ruby">doc.word.each {|word| some_really_really_long(with .....)}
</pre>
</div>
</li>
<li>有些时候某个函数还是加上括号比较好,比如instance_of?的参数很长的时候
<div class="org-src-container">

<pre class="src src-ruby">doc.instance_of? (self.class.superclass.class)
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8">In the Wild</h3>
<div class="outline-text-3" id="text-1-8">
<ul class="org-ul">
<li>学习ruby的一个好的办法是阅读源代码,比如set.rb
</li>
<li>从set.rb的源代码中,我们可以看到,所有的查询是否存在的函数都是以"?"结尾的,这
不是ruby的语法糖, "?"是函数的一个部分
</li>
<li>所有以"!"结尾的函数,也是一样,代表比较危险的函数
</li>
<li>当然,源代码里面也是有很多的漏洞的,比如最常见的就是Float不小心被写成了一个method
而不是一个class.
</li>
<li>当然了很多人认为Float函数情有可原,因为它的返回值是一个Float类型(传入参数是
string)
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Chapter 02: Choose the Right Control Structure</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">If, Unless, While, and Until</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>ruby 为了简洁,引入了unless,其作用和if not相同.
<div class="org-src-container">

<pre class="src src-ruby">unless @read_only
  @title = new_title
end
</pre>
</div>
</li>
<li>上面的例子可以理解为, "除非你是read_only的,我们惹不起,否则我们一定要改变当
前的标题内容"
</li>
<li>unless看似是一小步,但是简化了很多的逻辑思考.
</li>
<li>while也像if一样,有个"false的版本",叫做until. 不过我不怎么喜欢用
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Use the Modifier Forms Where Appropriate</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>即便使用了unless, 还是不够简约,我们甚至可以把unless放到后面,形成一个modifier
<div class="org-src-container">

<pre class="src src-ruby">@title = new_title unless @read_only
@title = new_title if @writable
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Use each, Not for</h3>
<div class="outline-text-3" id="text-2-3">
<ul class="org-ul">
<li>相比看起来很奇怪的unless, ruby提供的for却很友好, 和python的很像
<div class="org-src-container">

<pre class="src src-ruby">fonts = ['courier', 'times roman', 'helvetica']

for font in fonts
  puts font
end

##################################################
# &lt;===================OUTPUT===================&gt; #
# "courier"                                      #
# "times roman"                                  #
# "helvetica"                                    #
##################################################
</pre>
</div>
</li>
<li>但是, 如果你要写的更"ruby"的话,就不要使用for! 主要基于下面两点的原因:
<ul class="org-ul">
<li>for其实在内部就是调用了each, 干嘛不直接使用each
</li>
<li>for其实创建了以新的local的code block(namespace), 不会造成命名冲突
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">A Case of Programming Logic</h3>
<div class="outline-text-3" id="text-2-4">
<ul class="org-ul">
<li>case也有两种表现形式:
<ul class="org-ul">
<li>和传统的语言相似的方法
<div class="org-src-container">

<pre class="src src-ruby">title = 'hello world'

case title
when 'War And Peace'
  puts 'Tolstoy'
when 'Romeo And Juliet'
  puts 'Shakespeare'
else
  puts "Don't know"
end

##################################################
# &lt;===================OUTPUT===================&gt; #
# Don't know                                     #
##################################################
</pre>
</div>
</li>
<li>还可以把case做成一个部分,然后再赋值给一个变量
<div class="org-src-container">

<pre class="src src-ruby">author = case title
         when 'War And Peace'
           'Tolstoy'
         when 'Romeo And Juliet'
           'Shakespeare'
         else
           "Don't know"
         end
puts author

##################################################
# &lt;===================OUTPUT===================&gt; #
# Don't know                                     #
##################################################
</pre>
</div>
</li>
</ul>
</li>
<li>上面的第二个例子才是我们"更ruby"的写法.这种把一个"逻辑判断"赋值给一个变量的
做法还可以更进一步的"简化":
<ul class="org-ul">
<li>使用then, 使其变成一行
<div class="org-src-container">

<pre class="src src-ruby">author = case title
         when 'War and Peace' then 'Tolstoy'
         when 'Romeo And Juliet' then 'Shake'
         else "Don't know"
         end

puts author

##################################################
# &lt;===================OUTPUT===================&gt; #
# Don't know                                     #
##################################################
</pre>
</div>
</li>
<li>其实我们author如果在title没有已知value的情况下,希望得到第一个nil,而不是一
个"Don't know", 这种情况下,就可以省略else
<div class="org-src-container">

<pre class="src src-ruby">author = case title
         when 'War and Pease' then 'Tolstoy'
         when 'Romeo And Juliet' then 'Shakespeare'
         end

p author
##################################################
# &lt;===================OUTPUT===================&gt; #
# nil                                            #
##################################################
</pre>
</div>
</li>
</ul>
</li>
<li>case最为让人值得记住的是
<pre class="example">
case 是使用'==='(三个等号)来进行比对的
</pre>
</li>
<li>=== 有很多用处:
<ul class="org-ul">
<li>class使用===来判断某个object是不是自己的instance
<div class="org-src-container">

<pre class="src src-ruby">class Document
end

doc = Document.new

case doc
when Document
  puts " It's a document !"
when String
  puts " It's a string"
else
  puts "Don't know what it is!"
end


##################################################
# &lt;===================OUTPUT===================&gt; #
# It's a document !                              #
##################################################
</pre>
</div>
</li>
<li>正则表达式使用===来判断字符串是否匹配
<div class="org-src-container">

<pre class="src src-ruby">title = "Remeo and Apple"
case title
when /War And .*/
  puts 'Maybe Tolstoy?'
when /Remeo and .*/
  puts 'Maybe Shakespeare?'
else
  puts 'Absolutely no idea...'
end

##################################################
# &lt;===================OUTPUT===================&gt; #
# Maybe Shakespeare?                             #
##################################################
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">Staying Out of Trouble</h3>
<div class="outline-text-3" id="text-2-5">
<ul class="org-ul">
<li>Ruby 和其他语言(主要是C)不一样的地方是, 它只把false和nil认为是FALSE, 0都是
是TRUE.所以下面两种情况都是TRUE,要小心
<div class="org-src-container">

<pre class="src src-ruby">puts "Sorry Dennis Richie, but 0 is true!" if 0
puts "Sorry Dennis Richie, but 'false' is not false" if 'false'

##################################################
# &lt;===================OUTPUT===================&gt; #
# Sorry Dennis Richie, but 0 is true!            #
# Sorry Dennis Richie, but 'false' is not false  #
##################################################
</pre>
</div>
</li>
<li>在ruby里面,只有两个事物是false,绝大部分都是true,所以"绝对不要测试事物是否为
TRUE", 这很危险,比如如下的例子中defined?并不是返回true, 而是返回定义的类型
比如("local-variable")
<div class="org-src-container">

<pre class="src src-ruby">class Document
end

doc = Document.new
puts flag = defined?(doc)

if flag == true
  puts "TRUE"
end

##################################################
# &lt;===================OUTPUT===================&gt; #
# local-variable                                 #
##################################################
</pre>
</div>
</li>
<li>相反的也不要认为只有nil是FALSE, false也会FALSE的,比如IO的输入是遇到nil就退
出,但是你设计一个函数,取得下一个object的函数,就不能处理nil就完了,因为false
也要考虑.所以要"明确"的写出nil
<div class="org-src-container">

<pre class="src src-ruby"># Broken in a subtle way ...
while next_object = get_next_object
  # Do something with the object
end

# Should use following version
until (next_object = get_next_object) == nil
  # Do something with the object
end

# OR following
until (next_object = get_next_object).nil?
  # Do something with the object
end
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">In the Wild</h3>
<div class="outline-text-3" id="text-2-6">
<ul class="org-ul">
<li>?: 操作符来自c语言,然后非常符合ruby的哲学,所以被吸纳进来了
<div class="org-src-container">

<pre class="src src-ruby">all = nil
file = all ? 'specs' : 'latest_specs'

puts file

##################################################
# &lt;===================OUTPUT===================&gt; #
# latest_specs                                   #
##################################################
</pre>
</div>
</li>
<li>ruby更近一步,为"如果这个变量没有被申请过,就申请,否则还是用它原来的值"这种情
况来设计了一个操作符||=
<div class="org-src-container">

<pre class="src src-ruby">@first_name ||= ''

# Actually Equals to

@first_name = @first_name || ''
</pre>
</div>
</li>
<li>上面这种用法在first_name是false的情况下就是一个悲剧.所以不要使用||=来初始化
boolean
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Chapter 03: Take Advantage of Ruby's Smart Collections</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Literal Shortcuts</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>最常见的literal形式是这样的
<div class="org-src-container">

<pre class="src src-ruby">poem_words = ['twinkle', 'little', 'star', 'how', 'I', 'wonder']
p poem_words

#######################################################
# &lt;===================OUTPUT===================&gt;      #
# ["twinkle", "little", "star", "how", "I", "wonder"] #
#######################################################
</pre>
</div>
</li>
<li>ruby不喜欢写那么多的'', 所以可以简化成
<div class="org-src-container">

<pre class="src src-ruby">poem_words = %w{twinkle little star ho I wonder}
p poem_words

######################################################
# &lt;===================OUTPUT===================&gt;     #
# ["twinkle", "little", "star", "ho", "I", "wonder"] #
######################################################
</pre>
</div>
</li>
<li>hash 最开始的格式是这样的. 基本上就是把格式严格的书写一遍
<div class="org-src-container">

<pre class="src src-ruby">freq = {"I" =&gt; 1, "don't" =&gt; 1, "like" =&gt; 1, "spam" =&gt; 963}
p freq

##################################################
# &lt;===================OUTPUT===================&gt; #
# {"I"=&gt;1, "don't"=&gt;1, "like"=&gt;1, "spam"=&gt;963}   #
##################################################
</pre>
</div>
</li>
<li>hash在symbol出现以后,就不再推荐使用字符串了,而是使用:sym的symbol作为key,既
能保证唯一,又好书写
<div class="org-src-container">

<pre class="src src-ruby">book_info = {:first_name=&gt; 'Russ', :last_name =&gt; 'Olsen'}
p book_info

# Can be even written like this

book_info = {first_name: 'Russ', last_name: 'Olsen'}
p book_info

##################################################
# &lt;===================OUTPUT===================&gt; #
# {:first_name=&gt;"Russ", :last_name=&gt;"Olsen"}     #
# {:first_name=&gt;"Russ", :last_name=&gt;"Olsen"}     #
##################################################
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Instant Arrays and Hashes from Method Calls</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>给参数一个默认值,然后使用的时候可以少输入几个参数,没什么奇怪的,这是所有高级语言的特性
<div class="org-src-container">

<pre class="src src-ruby">def load_font(name, size = 12)
  # Go font hunting...
end
</pre>
</div>
</li>
<li>ruby还支持可变参数,就是参数到底是几个不一定. 使用*args作为参数,等到使用的时
候, 真正传入的这些参数就"装进"一个名叫args的数组
<div class="org-src-container">

<pre class="src src-ruby">def echo_all(*args)
  args.each {|arg| p arg}
end

echo_all("hello", "world", false)

##################################################
# &lt;===================OUTPUT===================&gt; #
# "hello"                                        #
# "world"                                        #
# false                                          #
##################################################
</pre>
</div>
</li>
<li>利用ruby可以帮你转换数组这个事实,你可以在设计函数的时候,就加上*, 然后这个参
数在使用的时候,就可以被当做一个数组啦, 传参数的时候又非常的惬意
<div class="org-src-container">

<pre class="src src-ruby">def add_authors(*names)
  puts "Author is " + "#{names.join(' ')}"
end

add_authors('Strunk', 'White')

# Inside of following

def add_authors_another(names)
  puts "Author is " + "#{names.join(' ')}"
end

add_authors_another(['Strunk', 'White'])

##################################################
# &lt;===================OUTPUT===================&gt; #
# Author is Strunk White                         #
# Author is Strunk White                         #
##################################################
</pre>
</div>
</li>
<li>*args作为参数,可以放在函数参数的任意位置(从1.9开始才可以,原来是必须放到末尾)
</li>
<li>hash可以作为函数的参数,而且,更重要的是如果hash是函数最后一个参数的话,可以不
写大括号!!非常重要,因为不懂这个规则在很多代码面前都很疑惑
<div class="org-src-container">

<pre class="src src-ruby">def load_font(specification_hash)
  # Load a font according to specification_hash[:name] etc.
end

load_font({:name =&gt; 'Times roman', :size=&gt;12})

# Can be repalced with following
load_font(:name =&gt; 'Times roman', :size=&gt;12)
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">Running Through Your Collection</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>遍历collection可以使用类python的方法,但是还是那句话,只是可以这么写,但是不要
这么写
<div class="org-src-container">

<pre class="src src-ruby">words = %w{ Mary had a little lamb }

for i in 0..words.size
  puts  words[i]
end

##################################################
# &lt;===================OUTPUT===================&gt; #
# Mary                                           #
# had                                            #
# a                                              #
# little                                         #
# lamb                                           #
##################################################
</pre>
</div>
</li>
<li>要这样写, ruby总是偏爱code block
<div class="org-src-container">

<pre class="src src-ruby">words = %w{ Mary had a little lamb }

words.each {|word| puts word}

##################################################
# &lt;===================OUTPUT===================&gt; #
# Mary                                           #
# had                                            #
# a                                              #
# little                                         #
# lamb                                           #
##################################################
</pre>
</div>
</li>
<li>hash也要使用code block的循环方式,因为hash是"key/value的紧密组合", 所以只使
用一个code block变量的话,会打印出数组来.使用两个code block变量就没事了
<div class="org-src-container">

<pre class="src src-ruby">movie = {title: '2001', genre: 'sci fi', rating: 10}

movie.each {|entry| p entry}

movie.each {|name, value| puts "#{name} =&gt; #{value}"}

##################################################
# &lt;===================OUTPUT===================&gt; #
# [:title, "2001"]                               #
# [:genre, "sci fi"]                             #
# [:rating, 10]                                  #
# title =&gt; 2001                                  #
# genre =&gt; sci fi                                #
# rating =&gt; 10                                   #
##################################################
</pre>
</div>
</li>
<li>hash和数组背后都有非常强大的API支持,因为ruby只支持这两种collection(这两个
collection稍加更改就能做其他语言里面的stack,heap等).如果你要在collection增
加一些功能的话,查询一些API,可能大部分功能都有了,只需要稍许改变.比如查找某个
word在数组中的位置,如果自己不了解Array API直接写的话
<div class="org-src-container">

<pre class="src src-ruby">def index_for(word)
  i = 0
  words.each do |this_word|
    return i if word == this_word
    i += 1
  end
  nil
end
</pre>
</div>
</li>
<li>查询过API后,可以发现可以利用find_index的帮助
<div class="org-src-container">

<pre class="src src-ruby">def index_for(word)
  words.find_index {|this_word| word == this_word}
end
</pre>
</div>
</li>
<li>前面介绍了each和index_for, 另外两个对于collection至关重要的函数是:
<ul class="org-ul">
<li>map: 也是遍历的方法,但是并不是像index_for一样遍历途中遇到什么情况就返回,
而是保证每个element都遍历,最后把结果都保存下来(这点又和each很像), 比如下
面的例子是求每个单词的长度
<div class="org-src-container">

<pre class="src src-ruby">words = %w{ I love you China}

p words.map {|word| word.size}

# You can see the all-lowercase version of the words in following way
p words.map {|word| word.downcase}

##################################################
# &lt;===================OUTPUT===================&gt; #
# [1, 4, 3, 5]                                   #
# ["i", "love", "you", "china"]                  #
##################################################
</pre>
</div>
</li>
<li>inject: 也是会像each一样遍历整个数组,但是它总是会在每一步的遍历途中记录两
个值1.累计值2.当前值. inject在运行的时候还要初始化累计值(当然也可以不指定,
那么数组第一个值就是默认值了, 但是第一个例子必须初始化否则初始值是一个字符
串无法加上其他数字).
<div class="org-src-container">

<pre class="src src-ruby">words = %w{ I love you China}

total = words.inject(0.0) {|result, word| word.size + result}
puts total / words.size

connect = words.inject {|result, word| result + word}
puts connect

##################################################
# &lt;===================OUTPUT===================&gt; #
# 3.25                                           #
# IloveyouChina                                  #
##################################################
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">Beware the Bang!</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>ruby的collection中元素的顺序是可以改变的.而且可以改变的元素顺序的函数大部分
都再最后加上了!.比如:
<ul class="org-ul">
<li>sort是返回一个sorted的数组, sort!是直接把原数组排序
</li>
<li>reverse是返回一个reversed的数组,reverse!是直接把原数组reverse
</li>
</ul>
</li>
<li>!的意思并不是改变,而是危险.所以有些会改变元素但是"不危险"的函数就没有加!了,
比如push, pop, delete等等
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5">Rely on the Order of Your Hashes</h3>
<div class="outline-text-3" id="text-3-5">
<ul class="org-ul">
<li>array的顺序是固定的这个是所有编程语言的常识
</li>
<li>从ruby1.9开始,ruby的hash也是顺序固定的了,这个很重要.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6">In the Wild</h3>
<div class="outline-text-3" id="text-3-6">
<ul class="org-ul">
<li>java中,可能会为每一个它认为特别的数据集合创建一个比如叫做ForSepcialCollection
的类,然后这个类是某个类的子类. 而ruby不这么想,ruby重复的,到处使用其仅有的两
个collection: map和array. 因为ruby认为: 东西越多,越容易混乱.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-7" class="outline-3">
<h3 id="sec-3-7">Staying Out</h3>
<div class="outline-text-3" id="text-3-7">
<ul class="org-ul">
<li>collection也有很多的陷阱,比如下面删除负数的例子,由于删除了第一个-10的时候,
吧index搞乱了,最后可能出现的结果就是有的负数没有被删掉
<div class="org-src-container">

<pre class="src src-ruby">array = [0, -10, -9, 5, 9]
# Wrong! mess up the internal index
array.each_index {|i| array.delete_at(i) if array[i] &lt; 0}

p array

##################################################
# &lt;===================OUTPUT===================&gt; #
# [0, -9, 5, 9]                                  #
##################################################
</pre>
</div>
</li>
<li>其实除了array和hash, ruby还是有set这个数据结构的,只不过不是内置的需要require
一把
<div class="org-src-container">

<pre class="src src-ruby">require 'set'

word_set = Set.new(words)
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Chapter 04: Take Advantage of Ruby's Smart Strings</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">Coming Up with a String</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>和python一样,ruby支持单引号和双引号两种方法创建字符串. 这种做法的好处是因为
单引号双引号相互之间不是特殊字符,我们可以在需要其中一种时候,在外面包裹另外
一种,比如
<div class="org-src-container">

<pre class="src src-ruby">str = "\"Stop\", she said, \"I cannot deal with the backslashes.\""
puts str

str2 = '"Stop", she said, "I cannot deal with the backslashes."'
puts str2

###########################################################
# &lt;===================OUTPUT===================&gt;          #
# "Stop", she said, "I cannot deal with the backslashes." #
# "Stop", she said, "I cannot deal with the backslashes." #
###########################################################
</pre>
</div>
</li>
<li>如果双引号,单引号,双引号交替三次以上出现,那么就得使用%q了
<div class="org-src-container">

<pre class="src src-ruby">str = %q{"Stop", she said, "I can't live without 's and "s."}

puts str

#######################################################
# &lt;===================OUTPUT===================&gt;      #
# "Stop", she said, "I can't live without 's and "s." #
#######################################################
</pre>
</div>
</li>

<li>#{}加变量的方法是ruby独有的
<div class="org-src-container">

<pre class="src src-ruby">author = "Ben Bova"
title = "Mars"
puts "#{title} is written by #{author}"

##################################################
# &lt;===================OUTPUT===================&gt; #
# Mars is written by Ben Bova                    #
##################################################
</pre>
</div>
</li>
<li>还有和python""""""对应的多行输入.注意大写字母是任意的,只要对称就可以
<div class="org-src-container">

<pre class="src src-ruby">heres_one = &lt;&lt;EOF
This is the beginning of my here document.
And this is the end.
EOF
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">Another API to Master</h3>
<div class="outline-text-3" id="text-4-2">
<ul class="org-ul">
<li>String系列API是我们必须要掌握的:
<ul class="org-ul">
<li>lstrip, rstrip是去除左右空格的
</li>
<li>chomp去掉尾部的一个换行(如果有三个剩下两个,如果一个没有,就不去)
</li>
<li>chop去掉尾部一个char,不管是什么
</li>
<li>把字符串和数组完美结合的是split, 参数会显示依靠"什么"来分割这些字符串
<div class="org-src-container">

<pre class="src src-ruby">p 'It was a dark and stormy night'.split
p 'Bill:Shakespeare:Playwright:Globe'.split( ':' )

########################################################
# &lt;===================OUTPUT===================&gt;       #
# ["It", "was", "a", "dark", "and", "stormy", "night"] #
# ["Bill", "Shakespeare", "Playwright", "Globe"]       #
########################################################
</pre>
</div>
</li>
<li>index函数是寻找某个字符串在原字符串的位置
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">The String: A Place for Your Lines, Characters, and Bytes</h3>
<div class="outline-text-3" id="text-4-3">
<ul class="org-ul">
<li>array的话,因为在定义的时候就有分割,所以很容易使用each来"个个"输出, 而string
在ruby里面是没有明显的输出的.换句话说,你可以使用多种方法来"分割"他们:
<ul class="org-ul">
<li>by char: 这个是和c语言一样了
<div class="org-src-container">

<pre class="src src-ruby">"Clarke".each_char {|c| puts c}

##################################################
# &lt;===================OUTPUT===================&gt; #
# C                                              #
# l                                              #
# a                                              #
# r                                              #
# k                                              #
# e                                              #
##################################################
</pre>
</div>
</li>
<li>by byte: 每个char其实也是一个byte
<div class="org-src-container">

<pre class="src src-ruby">"Clarke".each_byte {|b| puts b}

##################################################
# &lt;===================OUTPUT===================&gt; #
# 67                                             #
# 108                                            #
# 97                                             #
# 114                                            #
# 107                                            #
# 101                                            #
##################################################
</pre>
</div>
</li>
<li>by line: 这个很好理解,就是通过newline来区分
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4">In the Wild</h3>
<div class="outline-text-3" id="text-4-4">
<ul class="org-ul">
<li>ruby的很多操作都是针对字符串的,所以字符串的理解无比重要
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5">Staying Out of Trouble</h3>
<div class="outline-text-3" id="text-4-5">
<ul class="org-ul">
<li>Ruby字符串是mutable的,这个是跟Java完全相反的!
</li>
<li>Ruby的字符串也是class,也分ref和object,所以下面的两个字符串其实是一个
<div class="org-src-container">

<pre class="src src-ruby">first_name = 'Karen'
given_name = first_name

p first_name
p given_name

first_name[0] = 'D'

p first_name
p given_name

##################################################
# &lt;===================OUTPUT===================&gt; #
# "Karen"                                        #
# "Karen"                                        #
# "Daren"                                        #
# "Daren"                                        #
##################################################
</pre>
</div>
</li>
<li>所以把ruby看成是和collection一样的,可更改的数据集合.因为是可更改的,所以是可
以被赋值的. 赋值的用法也更为便于阅读和理解
<div class="org-src-container">

<pre class="src src-ruby">first_name = first_name.upcase

# Instead of
first_name.upcase!
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Chapter 05: Find the Right String with Regular Expressions</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">Matching One Character at a Time</h3>
<div class="outline-text-3" id="text-5-1">
<ul class="org-ul">
<li>正则表达式里面对应一个字符的情况有两种:
<ul class="org-ul">
<li>字符和数字是简单的"和自己"一对一的关系(大小写区分)
</li>
<li>regular expression中的标点符号就不是和自己的字符对应了,但是有些还是对应一
个比如"."就是对应一个任意的字符:
<ol class="org-ol">
<li>. 对应r,或%,或~
</li>
<li>..对应xx,或者4F,或者[!
</li>
<li>\.对应.
</li>
<li>3\.14对应3.14
</li>
</ol>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">Sets, Ranges, and Alternatives</h3>
<div class="outline-text-3" id="text-5-2">
<ul class="org-ul">
<li>除了这种"一一对应"的单挑用法,还有一种"多对一"的用法,就是一堆的字符最终只为
匹配一个字符.好比"三英战吕布", 这"三英"分别是:
<ul class="org-ul">
<li>Sets: 就是括号里面写上所有的可能项目,都是一一列举:
<ol class="org-ol">
<li>[ 0123456789 ]对应一个单个字母
</li>
<li>[Rr]会对应r或者R
</li>
<li>[aApP][mM]会对应am, aM, pM, PM等8种写法
</li>
</ol>
</li>
<li>Range: Sets因为要一一列举有些繁琐,适合Rr这种情况较少的, Range就是可以把情
况一股脑的全部列出:
<ol class="org-ol">
<li>[0-9abcdef]会对应单个的十六进制数字
</li>
<li>[a-z]会对应全部的小写字母
</li>
<li>转移字符是一种"\"加一个字母来替代一个复杂的range的做法.所以不再需要[]
了.比如\d 对应所有的digit, \d\d对应00到99. \w对应所有的字符. \s对应所
有的空格,包括tab, newline
</li>
</ol>
</li>
<li>Alternatives: range的特点是太宽泛,有时候没有这么宽泛的对应,比如我只支持AM和PM,
但是因为是两个字母,sets又没办法实现.所以就设计了"Set的多字母版本,窄对应"
版本Alternatives:
<ol class="org-ol">
<li>AM|PM就对应AM或者PM
</li>
<li>The (cat|boat) is red 就对应 The cat is red 或者 The boat is red
</li>
</ol>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3">The Regular Expression Star</h3>
<div class="outline-text-3" id="text-5-3">
<ul class="org-ul">
<li>star的定义值得深思,其需要*前面的字母配合
<pre class="example">
In regular expressions, an asterisk (*) matcches zero or more of the
thing that came just before it
</pre>
</li>
<li>所以*可以说是"双对多":
<ul class="org-ul">
<li>AB* 可以对应哪个AB
</li>
<li>AB* 可以对应哪个ABBBBBBBBBBBBB
</li>
<li>AB* 还可以对应A
</li>
</ul>
</li>
<li>star强大的"两对多"功能还可以跟其他的"多或者一对一"的正则表达式进行合作:
<ul class="org-ul">
<li>和Set合作,那么[aeiou]*就对应任意多个元音的组合, [0-9]*就对应多个数字的组合
</li>
<li>和.合作.也就是.*: 这个正则表达式世界里面最最常用的式子.因为它可以对应
anything!, 当然了对应anything是没有意义的,把".*"和其他字符串对应会起到非
常好的作用:
<ul class="org-ul">
<li>George.* 会对应所有以George开头的字符串
</li>
<li>.*George 会对应所有以George结尾的字符串
</li>
<li>.*George.*会对应所有含有George的字符串
</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4">Regular Expressions in Ruby</h3>
<div class="outline-text-3" id="text-5-4">
<ul class="org-ul">
<li>在ruby中,regular express收到非常高的礼遇,其就是一种内置的数据类型.其特点是
被"/"包裹, 下面就是一个Regexp的例子
<div class="org-src-container">

<pre class="src src-ruby">/\d\d:\d\d (AM|PM)/
</pre>
</div>
</li>
<li>Regexp的匹配也有自己的操作符就是=~, 其返回值为匹配位置,如果完全无法匹配返回
nil, 而且=~ 和 == 一样是不分左右的, Regexp放在左边或者右边都没有关系
<div class="org-src-container">

<pre class="src src-ruby">p '10:24 PM' =~ /\d\d:\d\d (AM|PM)/

p /\d\d:\d\d (AM|PM)/ =~ '10:24 PM'

p /PM/ =~ '10:24 PM'

p /May/ =~ 'Something in June'


##################################################
# &lt;===================OUTPUT===================&gt; #
# 0                                              #
# 0                                              #
# 6                                              #
# nil                                            #
##################################################
</pre>
</div>
</li>
<li>Regexp是case sensitive的,但是你可以在Regexp的最后加上i来表示其忽略大小写
<div class="org-src-container">

<pre class="src src-ruby">puts "It matches!" if /AM/i =~ 'am'

##################################################
# &lt;===================OUTPUT===================&gt; #
# It matches!                                    #
##################################################
</pre>
</div>
</li>
<li>Regexp还能发挥查找的作用,在String的gsub函数里面可以发挥它的作用
<div class="org-src-container">

<pre class="src src-ruby">def obscure_times!
  @content.gsub!(/\d\d:\d\d (AM|PM)/, '**:** **')
end
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-5" class="outline-3">
<h3 id="sec-5-5">Beginnings and Endings</h3>
<div class="outline-text-3" id="text-5-5">
<ul class="org-ul">
<li>前面的Regexp没有对开始匹配的位置进行要求,一个字符串如果能从中间匹配也是可以
的, 如果要求必须要从开头匹配,那么就要使用\A
<div class="org-src-container">

<pre class="src src-ruby">/\AOnce upon a time/
</pre>
</div>
</li>
<li>反之如果想字符串必须匹配最后的字符,那么必须使用\z
<div class="org-src-container">

<pre class="src src-ruby">/and they all lived happily ever after\z/
</pre>
</div>
</li>
<li>更高深的是,如果我不是从文章开头,而是一段文章的某一行的开头,或结尾,那么我们
就要使用^和$. 这个是和Vim的操作对待行时候的字符操作是一样的
<div class="org-src-container">

<pre class="src src-ruby">content = 'The Princess And the Monkey

Once upon a time there was a princess...
... and they all lived happily ever after.
The End'

puts "Found the beginning" if content =~ /^Once upon a time/
puts "Found the ending" if content =~ /happily ever after\.$/

##################################################
# &lt;===================OUTPUT===================&gt; #
# Found the beginning                            #
# Found the ending                               #
##################################################
</pre>
</div>
</li>
<li>做过我们像来个全文匹配,中间不知道的地方使用万能的.*来替代的话,会发现有问题,
因为.*默认屏蔽了多行匹配,加上参数m, 代表multiple(就像i是ignore一样), 就可以
跨行匹配了
<div class="org-src-container">

<pre class="src src-ruby">content = 'The Princess And the Monkey

Once upon a time there was a princess...
... and they all lived happily ever after.
The End'

puts "Found the whole" if content =~ /^Once upon a time.*happily ever after\.$/m

##################################################
# &lt;===================OUTPUT===================&gt; #
# Found the whole                                #
##################################################
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-6" class="outline-3">
<h3 id="sec-5-6">In the Wild</h3>
<div class="outline-text-3" id="text-5-6">
<ul class="org-ul">
<li>ruby 源代码里面有很多处使用Regexp的例子,比如测试zone是否符合某个字符串格式
<div class="org-src-container">

<pre class="src src-ruby">if /\A([+-])(\d\d):?(\d\d)\z/ =~ zone
</pre>
</div>
</li>
<li>这里的:?的意思是"零个或者1个:", ?和*有相似的功能,不过其能力只能到1,无法到无穷
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-7" class="outline-3">
<h3 id="sec-5-7">Staying Out of Trouble</h3>
<div class="outline-text-3" id="text-5-7">
<ul class="org-ul">
<li>ruby在Regexp上面最容易犯的错误有两种:
<ul class="org-ul">
<li>使用==, 而不是=~来判断是否匹配
</li>
<li>匹配成功返回的结果是开始匹配的位置,所以0也是成功,而且是非常成功. nil才表
示匹配不成功.
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">Chapter 06: Use Symbols to Stand for Something</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1">The Two Faces of Strings</h3>
<div class="outline-text-3" id="text-6-1">
<ul class="org-ul">
<li>symbol是ruby的一种创造. 一个symbol很容易被看成是一个stirng. 比如在rails的代
码中, 想要取得所有的记录的方法如下
<div class="org-src-container">

<pre class="src src-ruby">book = Book.find(:all)
</pre>
</div>
</li>
<li>其实我们也可以使用字符串.没有太大的区别
<div class="org-src-container">

<pre class="src src-ruby">book = Book.find('all')
</pre>
</div>
</li>
<li>ruby提供symbol必有其其他目的
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2">Not Quite a String</h3>
<div class="outline-text-3" id="text-6-2">
<ul class="org-ul">
<li>其实symobl的使用更类似于其他语言的枚举类型(enum), 是一个符号,计算机无所谓什
么类型,但是人类希望他更容易"标示", 但不要是String. 因为String还有传达数据的
作用.不要和"标示"相互混淆
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3">Optimized to Stand for Something</h3>
<div class="outline-text-3" id="text-6-3">
<ul class="org-ul">
<li>既然是"标示"作用,那么symbol的一大特点就是唯一性.无论在哪里,你写下了:all那么
就是相等的.被:all赋值的数据无论用什么方法比较都是相等的
<div class="org-src-container">

<pre class="src src-ruby">a = :all
c = :all

puts a == c
puts a === c
puts a.eql?(c)
puts a.equal?(c)

##################################################
# &lt;===================OUTPUT===================&gt; #
# true                                           #
# true                                           #
# true                                           #
# true                                           #
##################################################
</pre>
</div>
</li>
<li>如果是字符串的话,就不一定了
<div class="org-src-container">

<pre class="src src-ruby">a = "all"
c = "all"

puts a == c
puts a === c
puts a.eql?(c)
puts a.equal?(c)

##################################################
# &lt;===================OUTPUT===================&gt; #
# true                                           #
# true                                           #
# true                                           #
# false                                          #
##################################################
</pre>
</div>
</li>
<li>symbol的另外一大好处是其为immutable的,一旦创建,不会改变!所以非常适合做hash
的key. 实际的情况是hash即便是接受了"字符串"作为hash的key,其内部也会拷贝一份
的. 字符串的传入在创建hash的时刻就确定了.不会因为原来字符串改变而改变.
<div class="org-src-container">

<pre class="src src-ruby">author = "abc"
title = "xyz"
hash = {author=&gt;title}
author.upcase!
puts "hash[author] is #{hash[author]}"
puts "hash[author.downcase] is #{hash[author.downcase]}"

##################################################
# &lt;===================OUTPUT===================&gt; #
# hash[author] is                                #
# hash[author.downcase] is xyz                   #
##################################################
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-4" class="outline-3">
<h3 id="sec-6-4">In the Wild</h3>
<div class="outline-text-3" id="text-6-4">
<ul class="org-ul">
<li>在ruby中,symbol和stirng可以相互之间轻易转换.
<div class="org-src-container">

<pre class="src src-ruby">the_string = :all.to_s
the_symbol = "all".to_sym

p the_string
p the_symbol

##################################################
# &lt;===================OUTPUT===================&gt; #
# "all"                                          #
# :all                                           #
##################################################
</pre>
</div>
</li>
<li>1.9以前的ruby在public_methods的返回值上面犯了个错误,其会返回字符串数组, 但
是函数名是一个class的某些"标示", 其实应该是symbol的,所以在1.9中,这个错误被
更改过来了
<div class="org-src-container">

<pre class="src src-ruby">x = Object.new
p x.public_methods

##################################################
# &lt;===================OUTPUT===================&gt; #
# [:nil?, :===, :=~, :!~, :eql?, :hash, :&lt;=&gt;,    #
#  ...]                                          #
##################################################
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-5" class="outline-3">
<h3 id="sec-6-5">Staying Out of Trouble</h3>
<div class="outline-text-3" id="text-6-5">
<ul class="org-ul">
<li>对于symbol来说,最容易出错的地方,是一定要记住hash一定要使用symbol来作为key,
在使用的时候也要回去看看到底自己是不是用了symbol. 如果设置的时候使用了symbol
的话,使用的时候使用字符串肯定是不行的
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-7" class="outline-2">
<h2 id="sec-7">Chapter 07: Treat Everything Like an Object &#x2013; Because Everything Is</h2>
<div class="outline-text-2" id="text-7">
</div><div id="outline-container-sec-7-1" class="outline-3">
<h3 id="sec-7-1">A Quick Review of Clases, Instances, and Methods</h3>
<div class="outline-text-3" id="text-7-1">
<ul class="org-ul">
<li>对于ruby来说, class就意味着两件事情:
<ul class="org-ul">
<li>class首先是method的容器
<div class="org-src-container">

<pre class="src src-ruby">class Document
  def words
    # ...
  end
end
</pre>
</div>
</li>
<li>class其次是创建instance的工厂
<div class="org-src-container">

<pre class="src src-ruby">doc = Document.new("Ethics")
</pre>
</div>
</li>
</ul>
</li>
<li>ruby和python一样都有self这个概念,但是ruby里面你不需要再"明确的"写出一个self
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-7-2" class="outline-3">
<h3 id="sec-7-2">Objects All the Way Down</h3>
<div class="outline-text-3" id="text-7-2">
<ul class="org-ul">
<li>在ruby中,绝大多数你看到的东西都是object,连数字和true false都是, 甚至nil都是
<div class="org-src-container">

<pre class="src src-ruby">puts -3.class
puts true.class
puts false.class
puts nil.class

##################################################
# &lt;===================OUTPUT===================&gt; #
# Fixnum                                         #
# TrueClass                                      #
# FalseClass                                     #
# NilClass                                       #
##################################################
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-7-3" class="outline-3">
<h3 id="sec-7-3">The Importance of Being an Object</h3>
<div class="outline-text-3" id="text-7-3">
<ul class="org-ul">
<li>基本上所有的object都是Object的子类,所以可以使用Object提供的一大票的函数:
<ul class="org-ul">
<li>class: 查询父类名称
</li>
<li>instance_of?: 查询是否是某个class的instance
</li>
<li>to_s: 转化为字符串
</li>
</ul>
</li>
<li>Object的很多函数,其实是存在于Kernel module,然后mixed into到Object里面的
</li>
<li>Object还有很多奇异的函数:
<ul class="org-ul">
<li>eval: 接受一个字符串,这个字符串会被看成是ruby代码. (这个eval的名字估计来
自elisp), 在eval的帮助下,你可以快速实现一个irb
<div class="org-src-container">

<pre class="src src-ruby">while true
  print "Cmd&gt;"
  cmd = gets
  puts (eval(cmd))
end

##################################################
# &lt;===================OUTPUT===================&gt; #
# bash-3.2$ ruby eval_irb.rb                     #
# Cmd&gt;2 + 2                                      #
# 4                                              #
# Cmd&gt;puts "hello world"                         #
# hello world                                    #
#                                                #
# Cmd&gt;                                           #
##################################################
</pre>
</div>
</li>
<li>public_methods: 列出所有类的成员函数
</li>
<li>instance_variables: 列出所有的成员变量
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-7-4" class="outline-3">
<h3 id="sec-7-4">Public, Private, and Protected</h3>
<div class="outline-text-3" id="text-7-4">
<ul class="org-ul">
<li>和其他语言一样,ruby也有三种访问模式:
<ul class="org-ul">
<li>public: 所有人都能看到
</li>
<li>protected: 只有自己的继承序列能看到
</li>
<li>private: 和其他语言理解的有所不同, ruby的private函数是无法使用instance调
用而已,在class内部当然不需要instance调用就使用.同样的在subclass内部,也可
以不使用instance就使用函数,所以,也是可以调用的.
</li>
</ul>
</li>
<li>在ruby里面,所有的private,其实只是"君子协定",你完全可以使用其他方法来规避,比
如Object里面提供的send函数
<div class="org-src-container">

<pre class="src src-ruby">class Document
  private :word_count

  def word_count
    puts "word count"
  end
end

doc = Document.new

# doc.send(:word_count)
doc.word_count
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-7-5" class="outline-3">
<h3 id="sec-7-5">In the Wild</h3>
<div class="outline-text-3" id="text-7-5">
<ul class="org-ul">
<li>在ruby中,如下情况在内部确实不是通过函数实现的:
<ul class="org-ul">
<li>给一个变量赋值
</li>
<li>if 判断
</li>
<li>while 判断
</li>
</ul>
</li>
<li>但是确实是有些情况是函数实现的,虽然表面上看不出来
<ul class="org-ul">
<li>private, public, protected的实现也是通过函数
</li>
<li>require其实也是一种函数: 读取某个文件的内容,然后把它的内容当做ruby代码来
进行执行
</li>
<li>attr_accessor也是函数
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-7-6" class="outline-3">
<h3 id="sec-7-6">Staying Out of Trouble</h3>
<div class="outline-text-3" id="text-7-6">
<ul class="org-ul">
<li>Object带来了50个"一出生就能使用的函数", 代价是有50次name collision的机会,所
以对Object的所有成员都了解是非常必要的
</li>
<li>出错机会小的一种办法是少些代码:你从来没写过的代码会一直正常运行!
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-8" class="outline-2">
<h2 id="sec-8">Chapter 08: Embrace Dynamic Typing</h2>
<div class="outline-text-2" id="text-8">
</div><div id="outline-container-sec-8-1" class="outline-3">
<h3 id="sec-8-1">Shorter Programs, But Not the Way You Think</h3>
<div class="outline-text-3" id="text-8-1">
<ul class="org-ul">
<li>动态语言的短小精悍绝不是来自于少些了几个int或者string,而是:
来自于不再需要书写类似java中的bstract class, 或者interface(在java中
abstract class是一种不纯粹的interface). 在ruby中,我们并不严格的要求某个object
必须是什么类型的,是其他类型就不对,我们只要求它有"足够用的method"就可以了
<pre class="example">
Duck typing: If an object has the right methods, then it is the right kind of object
</pre>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-2" class="outline-3">
<h3 id="sec-8-2">Extreme Decoupling</h3>
<div class="outline-text-3" id="text-8-2">
<ul class="org-ul">
<li>短小精悍不是动态语言的唯一优点
</li>
<li>前面我们设计过Document类,它有string类型的title和author
<div class="org-src-container">

<pre class="src src-ruby">class Document
  attr_accessor :title, :author, :content

  def initialize(title, author, content)
    @title = title
    @author = author
    @content = content
  end
end
</pre>
</div>
</li>
<li>现在我们有了下面两个新的类来代表"题目"和"作者", 然后你会要求Document也要支持
<div class="org-src-container">

<pre class="src src-ruby">class Title
  attr_reader :long_nam, :short_name
  attr_reader :isbn

  def initialize(long_name, short_name, isbn)
    @long_name = long_name
    @short_name = short_name
  end
end

class Author
  attr_reader :first_name, :last_name

  def initialize(first_name, last_name)
    @first_name = first_name
    @last_name = last_name
  end
end
</pre>
</div>
</li>
<li>然后你发现,你"不需要写任何代码!", Document已经支持两个新的类型了!这就是动态
语言厉害的另外的地方:非常松的耦合!
<div class="org-src-container">

<pre class="src src-ruby">two_cities = Title.new('A Tale of Two Cities',
                       '2 Cities', '0-999-9999-9')
dickens = Author.new('Charles', 'Dickens')

##############################################
# now Document works!                        #
# previously Document may be written like    #
# doc = Document.new("A Tale of Two Cities", #
#                    "Charles Dickens"       #
#                    'It was the best...')   #
##############################################

doc = Document.new(two_cities, dickens, 'It was the best...')
</pre>
</div>
</li>
<li>这种松耦合是动态语言的特质,千万不要像下面的例子一样,再去判断输入是否是stirng,
因为这样写有一天不是string了,我们就不能能用了
<div class="org-src-container">

<pre class="src src-ruby">def initialize(title, author, content)
  raise "Title isn't a String" unless title.kind_of? String
  raise "Author isn't a String" unless title.kind_of? String
  raise "Content isn't a String" unless content.kind_of? String
  @title = title
  @author = author
  @content = content
end
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-3" class="outline-3">
<h3 id="sec-8-3">Required Ceremony Versus Programmer-Driven Clarity</h3>
<div class="outline-text-3" id="text-8-3">
<ul class="org-ul">
<li>动态语言和传统高级语言的不同在于:
<ul class="org-ul">
<li>传统高级语言是依靠编译器来强制指定类型:这是有好处的,因为声明为int类型的参
数如果在使用的时候给了一个string类型的输入,编译器就会警告你
</li>
<li>在动态语言里面, 对类型的判断的任务交给了程序员,你要书写更清晰的变量名,更
清晰的注释来让麻烦变得尽可能的少
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-4" class="outline-3">
<h3 id="sec-8-4">Staying Out of Trouble</h3>
<div class="outline-text-3" id="text-8-4">
<ul class="org-ul">
<li>ruby中,我们最常见到的错误就是和类型相关的,比如你"认为"一个object是Title类型
的,所以你调用了Title的函数long_name, 结果却得到了如下的错误提示(因为其实你
提供的不是Title类型,而是String类型)
<div class="org-src-container">

<pre class="src src-sh">NoMethodError: undefined method `long_name` for "TwoCities":String
</pre>
</div>
</li>
<li>ruby不回避这种问题的存在,应对的方法是两个:
<ul class="org-ul">
<li>书写更加简洁清新的代码
</li>
<li>高质量全覆盖的测试用例
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-8-5" class="outline-3">
<h3 id="sec-8-5">In the Wild</h3>
<div class="outline-text-3" id="text-8-5">
<ul class="org-ul">
<li>ruby的设计不是像java那样,有森严的类之间的继承体系,可以多多的重用代码.在ruby
里面,更多的是从实用的角度上来设计,并且尽可能的"疏远类之间的关系",比如下面代码
中的open_file和open_string, 他们有着几乎一致的api,比如seek, readline等等,但
是他俩第一个共同的祖先竟然是Object(也就是说他们没有什么重用代码,都是自己各
搞了一份). 从这里看,ruby的实用哲学一览无余
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-9" class="outline-2">
<h2 id="sec-9">Chapter 09: Write Specs!</h2>
<div class="outline-text-2" id="text-9">
</div><div id="outline-container-sec-9-1" class="outline-3">
<h3 id="sec-9-1">Test::Unit: When Your Documents Just Have to Work</h3>
<div class="outline-text-3" id="text-9-1">
<ul class="org-ul">
<li>Test::Unit是Xunit系列在ruby的代言, 其他语言的代言有Junit, cppUnit等等
</li>
<li>Test::Unit的使用也和其他XUnit差不多.下面是一个例子
<div class="org-src-container">

<pre class="src src-ruby">class DocumentTest &lt; Test::Unit::TestCase
  def setup
    @text = 'A Bunch of words'
    @doc = Document.new('test', 'nobody', @test)
  end

  def test_that_docment_holds_onto_contents
    assert_equal @text, @doc.content, 'Contents are still there'
  end

  def test_that_word_count_is_correct
    assert_equal 4, @doc.word_count, 'Word count is correct'
  end
end
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-9-2" class="outline-3">
<h3 id="sec-9-2">A Plethora of Assertions</h3>
<div class="outline-text-3" id="text-9-2">
<ul class="org-ul">
<li>assert当然有很多其他情况,比如:
<ul class="org-ul">
<li>assert_not_equal
</li>
<li>assert_nil
</li>
<li>assert_not_nil
</li>
<li>assert_match: 能够判断字符串是否符合正则表达式
<div class="org-src-container">

<pre class="src src-ruby">assert_match /times.*/, 'times new roman'
</pre>
</div>
</li>
<li>assert_instance_of
<div class="org-src-container">

<pre class="src src-ruby">assert_instance_of String, 'hello'
</pre>
</div>
</li>
<li>assert_raise: 抛出异常
<div class="org-src-container">

<pre class="src src-ruby">assert_raise ZeroDivisionError do
  x = 1 / 0
end
</pre>
</div>
</li>
<li>assert_nothing_thrown: 不抛出异常
<div class="org-src-container">

<pre class="src src-ruby">assert_nothing_thrown do
  x = 1 / 2
end
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-9-3" class="outline-3">
<h3 id="sec-9-3">Don't Test Il, Spec It!</h3>
<div class="outline-text-3" id="text-9-3">
<ul class="org-ul">
<li>随着时代的发展, Test::Unit不再那么适应时代(或者更确切的说是适应ruby,因为其
他Xunit还是活的风生水起). Ruby社区诞生了Rspec
</li>
<li>Rspec更像是一个specification,而不是unit test,我们来看一段Rspec代码
<div class="org-src-container">

<pre class="src src-ruby">describe Document do
  it 'should hold on to the contents' do
    text = 'A bunch of words'
    doc = Document.new('test', 'nobody', text)
    doc.content.should == text
  end

  it 'should return all of the words in the document' do
    text = 'A bunch of words'
    doc = Document.new('test', 'nobody', text)
    doc.words.include?('A').should == true
    # ...
  end
end
</pre>
</div>
</li>
<li>Rspec的特点就是包含大量的should,它不再使用生硬的assert,使用更柔和的should
</li>
<li>Rspec和每个rb文件对应Document.rb的spec文件就是Document_spec.rb
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-9-4" class="outline-3">
<h3 id="sec-9-4">A Tidy Spec Is a Readable Spec</h3>
<div class="outline-text-3" id="text-9-4">
<ul class="org-ul">
<li>Rspec也要解决DIY的问题,Rspec的setup叫做before, Rspec的teardown叫做after
<div class="org-src-container">

<pre class="src src-ruby">describe Document do
  before :each do
    @text = 'A bunch of words'
    @doc = Document.new('test', 'nobody', @text)
  end
  # ...
end
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-10" class="outline-2">
<h2 id="sec-10">Chapter 10: Construct Your Classes from Short, Focused Methods</h2>
<div class="outline-text-2" id="text-10">
<ul class="org-ul">
<li>Ruby设计函数的原则和Unix一样:
<pre class="example">
short methods that stick to doing one thing and doing it well
</pre>
</li>
</ul>
</div>
<div id="outline-container-sec-10-1" class="outline-3">
<h3 id="sec-10-1">Compressing Specifications</h3>
<div class="outline-text-3" id="text-10-1">
<ul class="org-ul">
<li>讲解函数设计的技巧就必须得通过例子,下面是一个压缩字符串的例子.一个字符串被
输入后会被分解成两个array, 一个array放所有出现过的单词(多次出现只写一次,更
像是一个set).另外一个array保存单词出现的位置,一个新学ruby的人会马上堆出如下
代码
<div class="org-src-container">

<pre class="src src-ruby">class TextCompressor
  attr_reader :unique, :index

  def initialize(text)
    @unique = []
    @index = []

    words = text.split
    words.each do |word|
      i = @unique.index( word )
      if i
        @index &lt;&lt; i
      else
        @unique &lt;&lt; word
        @index &lt;, unique.size - 1
      end
    end
  end
end

text = "This specification is the spec for a specification"
compressor = TextCompressor.new(text)
</pre>
</div>
</li>
<li>这个版本只能说差强人意,我们试着改编一下,让它看起来更加的清晰
<div class="org-src-container">

<pre class="src src-ruby">class TextCompressor
  attr_reader :unique, :index

  def initialize(text)
    @unique = []
    @index = []

    words = text.split
    words.each do |word|
      i = unique_index_of(word)
      if i
        @index &lt;&lt; i
      else
        @index &lt;, add_unique_word(word)
      end
    end
  end

  def unique_index_of(word)
    @unique.index(word)
  end

  def add_unique_word(word)
    @unique &lt;&lt; word
    unique.size - 1
  end
end
</pre>
</div>
</li>
<li>这个版本已经进步很大了,我们把繁琐的"加入array"的代码写成了method放在别的地
方,减轻了我们阅读initialize函数的负担,但是initialize依然看起来十分的臃肿
<div class="org-src-container">

<pre class="src src-ruby">class TextCompressor
  attr_reader :unique, :index

  def initiaize(text)
    @unique = []
    @index = []
    add_text(text)
  end

  def add_text(text)
    words = text.split
    words.each {|word| add_word(word)}
  end

  def add_word(word)
    i = unique_index_of(word) || add_unique_word(word)
    @index &lt;&lt; i
  end

  def unique_index_of(word)
    @unique.index(word)
  end

  def add_unique_word(word)
    @unique &lt;&lt; word
    unique.size  - 1
  end
end
</pre>
</div>
</li>
<li>这个版本才是真正的ruby的写法, initialize清晰,每个函数都很简短.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-10-2" class="outline-3">
<h3 id="sec-10-2">Composing Methods for Humans</h3>
<div class="outline-text-3" id="text-10-2">
<ul class="org-ul">
<li>我们上面对TextCompressor类的改编在学术上叫做"Composed method"技法,其核心是
将函数分解成满足如下三个条件的函数:
<ul class="org-ul">
<li>每个函数只做一件事情,这样既易于书写,又易于理解
</li>
<li>每个函数只处理一个level的概念
</li>
<li>每个函数短到它的名字就可以概括它的作用
</li>
</ul>
</li>
<li>书写简短,名字非常容易理解的函数的意义,不是为了computer着想,而是为了你.为了
你能更好的处理细节
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-10-3" class="outline-3">
<h3 id="sec-10-3">Composing Ruby Methods</h3>
<div class="outline-text-3" id="text-10-3">
<ul class="org-ul">
<li>ruby创建method的代价很小,而且小的函数为你提供了更多的"插口",也更容易的书写
测试用例
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-10-4" class="outline-3">
<h3 id="sec-10-4">One Way Out?</h3>
<div class="outline-text-3" id="text-10-4">
<ul class="org-ul">
<li>Ruby设计了一种最后一行不用说就是返回值的做法,这不是偶然的. 先看一个新手的ruby
代码例子
<div class="org-src-container">

<pre class="src src-ruby">class Document
  def prose_rating
    if pretentious_density &gt; 0.3
      if informal_density &lt; 0.2
        return :really_pretentious
      else
        return :somewhat_pretentious
      end
    elsif pretentious_density &lt; 0.1
      if informal_density &gt; 0.3
        return :really_informal
      end
      return :somewhat_informal
    else
      return :about_right
    end
  end

  def pretentious_density
    # ...
  end

  def informal_density
    # ...
  end
end
</pre>
</div>
</li>
<li>这是在其他语言里面最常见不过的代码,但是ruby不喜欢这样.ruby非常喜欢的就是"一
行代码"的函数! 这一行也就是返回值.这就是为什么ruby要设计成最后一行默认是返
回值. 我们来看看"一行代码"的函数的魅力
<div class="org-src-container">

<pre class="src src-ruby">def prose_rating
  return :really_pretentious if really_pretentious?
  return :somewhat_pretentious if somewhat_pretentious?
  return :really_informal if really_informal?
  return :somewhat_informal if somewhat_informal?
  return :about_right
end

def really_pretentious?
  pretentious_density &gt; 0.3 &amp;&amp; informal_density &lt; 0.2
end

def somewhat_pretentious?
  pretentious_density &gt; 0.3 &amp;&amp; informal_density &gt;= 0.2
end

def really_informal?
  pretentious_density &lt; 0.1 &amp;&amp; informal_density &gt; 0.3
end

def somewhat_informal?
  pretentious_density &lt; 0.1 &amp;&amp; informal_density &lt;= 0.3
end

def pretentious_density
  # ...
end

def informal_density
  # ...
end
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-10-5" class="outline-3">
<h3 id="sec-10-5">Staying Out of Trouble</h3>
<div class="outline-text-3" id="text-10-5">
<ul class="org-ul">
<li>我们前面将了太多将函数设计的极简成一行的办法,但是你要了解虽然我们要求简单,
但是也得要有意义.函数虽然设计成一行了,但是啥都没干,也没意义.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-10-6" class="outline-3">
<h3 id="sec-10-6">In the Wild</h3>
<div class="outline-text-3" id="text-10-6">
<ul class="org-ul">
<li>在"简短而有意义"的ruby函数设计的实践中,rails一定是做的最好的.比如rails会把
下面的代码变得非常有意义
<div class="org-src-container">

<pre class="src src-ruby">class Employee &lt; ActiveRecord::Base
end
</pre>
</div>
</li>
<li>我们来看看base.rb里面是如何实现ActiveRecord::Base的
<div class="org-src-container">

<pre class="src src-ruby">def find(*args)
  options = args.extract_options!
  validate_find_options(options)
  set_readonly_option!(options)

  case args.first
  when :first then find_initial(options)
  when :last then find_last(options)
  when :all then find_every(options)
  else find_from_ids(args, options)
  end
end
</pre>
</div>
</li>
<li>虽然你不一定了解这些代码里面是干什么的,但是从rails生动的函数命名来说,你已经
了解了他们的功能.
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-11" class="outline-2">
<h2 id="sec-11">Chapter 11: Define Operators Respectfully</h2>
<div class="outline-text-2" id="text-11">
<ul class="org-ul">
<li>重定义操作符在c++来到的时候,火了一把,但是后来又沉寂,这是因为其存在着优点以及
缺点, ruby选择了支持操作符重载,所以我们也必须知道如何避免它的缺点
</li>
</ul>
</div>
<div id="outline-container-sec-11-1" class="outline-3">
<h3 id="sec-11-1">Defining Operators in Ruby</h3>
<div class="outline-text-3" id="text-11-1">
<ul class="org-ul">
<li>ruby能够重定义操作符的原理是:ruby所有操作符的内部实现都是函数
<div class="org-src-container">

<pre class="src src-ruby">sum = first + second
# is Actually
sum = first.+(second)
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-11-2" class="outline-3">
<h3 id="sec-11-2">A Sampling of Operators</h3>
<div class="outline-text-3" id="text-11-2">
<ul class="org-ul">
<li>除了+, ruby还允许你定义各种操作符-,/,*等等,但是最经常定义的一个操作符是&lt;&lt;,
其意义是"add another one". 数组就重定义了这个操作符
<div class="org-src-container">

<pre class="src src-ruby">names = []
names &lt;&lt; 'Rob'
names &lt;&lt; 'Denise'

p names

##################################################
# &lt;===================OUTPUT===================&gt; #
# ["Rob", "Denise"]                              #
##################################################
</pre>
</div>
</li>
<li>Ruby1.9开始,你甚至可以定义unary operator,比如!
<div class="org-src-container">

<pre class="src src-ruby">class Document
  attr_reader :content
  def initialize(content)
    @content = content
  end

  def !
    Document.new("It is not true: #{content}")
  end
end

favorite = Document.new('Chocolate is best')

puts favorite.content
puts (!favorite).content

##################################################
# &lt;===================OUTPUT===================&gt; #
# Chocolate is best                              #
# It is not true: Chocolate is best              #
##################################################
</pre>
</div>
</li>
<li>你也不是所有的操作符都能重定义,比如下面的就不行:
<ol class="org-ol">
<li>not
</li>
<li>and
</li>
<li>||
</li>
<li>&amp;&amp;
</li>
</ol>
</li>
<li>如果想把+当做unary来重定义,函数名是+@
</li>
<li>在Ruby里面[]也是一个操作符,其内部实现也是函数[],可以重定义.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-11-3" class="outline-3">
<h3 id="sec-11-3">Operating Across Classes</h3>
<div class="outline-text-3" id="text-11-3">
<ul class="org-ul">
<li>操作符重定义的一个问题就在于夸class,比如我们想让Document来和string进行相加
<div class="org-src-container">

<pre class="src src-ruby">def +(other)
  if otehr.kind_of?(String)
    return Document.new(title, author, "#{content} #{other}")
  end
  Document.new(title, author, "#{content} #{other.content}")
end
</pre>
</div>
</li>
<li>这样做的问题在于,如果我是String在前,Document在后,比如
<div class="org-src-container">

<pre class="src src-ruby">'I say to you, ' + doc
</pre>
</div>
</li>
<li>就会出现错误
<div class="org-src-container">

<pre class="src src-sh">#&lt;TypeError: can't convert Document into String&gt;
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-11-4" class="outline-3">
<h3 id="sec-11-4">Staying Out of Trouble</h3>
<div class="outline-text-3" id="text-11-4">
<ul class="org-ul">
<li>从略
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-11-5" class="outline-3">
<h3 id="sec-11-5">In the Wild</h3>
<div class="outline-text-3" id="text-11-5">
<ul class="org-ul">
<li>在ruby代码中,还是有一些地方重定义了操作符的,比如,在时间里面
<div class="org-src-container">

<pre class="src src-ruby">now = Time.now
# one_minute_from_now = now + 60

# Bang! Will break
# one_minute_from_now = 60 + now

puts now
puts one_minute_from_now

##################################################
# &lt;===================OUTPUT===================&gt; #
# 2014-06-05 20:47:26 +0800                      #
# 2014-06-05 20:48:26 +0800                      #
##################################################
</pre>
</div>
</li>

<li>ruby典型的#{variable}也是重定义了操作符
</li>
<li>还有格式化输出
<div class="org-src-container">

<pre class="src src-ruby">day = 4
month = 7
year = 1776

file_name = 'file_%02d%02d%d' % [ day, month, year]

puts file_name

##################################################
# &lt;===================OUTPUT===================&gt; #
# file_04071776                                  #
##################################################
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-12" class="outline-2">
<h2 id="sec-12">Chapter 12: Create Classes That Understand Equality</h2>
<div class="outline-text-2" id="text-12">
</div><div id="outline-container-sec-12-1" class="outline-3">
<h3 id="sec-12-1">An Identifier for Your Documents</h3>
<div class="outline-text-3" id="text-12-1">
<ul class="org-ul">
<li>Document类设计的非常出色,你为了能够快速的定位一个Document,设计了一个Document
的Id类
<div class="org-src-container">

<pre class="src src-ruby">class DocumentIdentifier
  attr_reader :folder, :name

  def initialize(folder, name)
    @folder = folder
    @name = name
  end
end
</pre>
</div>
</li>
<li>然后你发现你的设计并不足够好,同事们认为这个class无法快速比较两个Document的
内容是否完全一致.你需要增加这个设计
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-12-2" class="outline-3">
<h3 id="sec-12-2">An Embarrassment of Equality</h3>
<div class="outline-text-3" id="text-12-2">
<ul class="org-ul">
<li>说到"相等性"(equality),在标榜简洁的Ruby里面,有多达四种的表示"相等"这个概念
的操作符:
<ul class="org-ul">
<li>eql? : 比较Hash的key
</li>
<li>equal?: 比较object(的哈希值)
</li>
<li>==: 比较内容
</li>
<li>===: 比较正则表达式
</li>
</ul>
</li>
<li>好消息是equal?首先可以不用考虑,因为它是指的两个object是否指的是同一个(hash
值相同,类似于Java中的==)
<div class="org-src-container">

<pre class="src src-ruby"># Return true if x and y are both references to identically same objects
x.equal?(y)
</pre>
</div>
</li>
<li>equal?的设计其实就是比对内部的hash,这个在Object类里面已经实现好了,无需多次实现.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-12-3" class="outline-3">
<h3 id="sec-12-3">Double Equals for Everyday Use</h3>
<div class="outline-text-3" id="text-12-3">
<ul class="org-ul">
<li>在Object里面, ==operator的实现和equal?是一样的.而实际上, ==operator才是真正
的比较"内容",而非heap里面的object
</li>
<li>所以,我们要在class里面如下实现==operator
<div class="org-src-container">

<pre class="src src-ruby">class DocumentIdentifier
  attr_reader :folder, :name

  def initialize(folder, name)
    @folder = folder
    @name = name
  end

  def ==(other)
    return false unless other.instance_of?(self.class)
    folder == other.folder &amp;&amp; name == other.name
  end
end
</pre>
</div>
</li>
<li>实现的原理也非常简单:
<ul class="org-ul">
<li>首先测试other是不是一个self.class也就是DocumentIdentifier类型的instance,
需要注意的是nil不需要进行专门测试(像在java中那样), 因为nil本身也是一个类,
会再instance_of?的时候返回false
</li>
<li>其次我们再判断name和folder是否都一致
</li>
</ul>
</li>
<li>一个合理的优化,就是测试other是否就是自己本身(这在其他语言中也很常见,比如c++)
<div class="org-src-container">

<pre class="src src-ruby">def ==(other)
  return true if other.equal?(self)
  return false unless other.instance_of?(self.class)
  folder == other.folder &amp;&amp; name == other.name
end
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-12-4" class="outline-3">
<h3 id="sec-12-4">Broadening the Appeal of the == Method</h3>
<div class="outline-text-3" id="text-12-4">
<ul class="org-ul">
<li>前面一个例子的坏处是它只能让==成功匹配完全相同类型的(也就是DocumentIdentifier)
的instance,其实在OO设计中. subclass"也是"一种baseclass.所以,我们使用kind_of?
来替代instance_of?
<div class="org-src-container">

<pre class="src src-ruby">class DocumentIdentifier
  # ...

  def ==(other)
    return true if other.equal?(self)
    return false unless other.kind_of?(self.class)
    folder == other.folder &amp;&amp; name == other.name
  end
end

class ContractIdentifer &lt; DocumentIdentifier
end
</pre>
</div>
</li>
<li>这样的做法看起来很"不ruby", 因为dedicated的类继承,只有Java才做. Ruby再OO上
是更加务实的态度.Ruby也不像继承的过深, 这种情况下(需要另外一个类和当前类"有
关系", 却不是继承的关系), Ruby会倾向于创建一个内容有部分相似的类,但"绝不"踏
上继承的贼船
<div class="org-src-container">

<pre class="src src-ruby">class DocumentIdentifier
  attr_reader :folder, :name

  def initialize(folder, name)
    @folder = folder
    @name = name
  end

  def ==(other)
    return false unless other.instance_of?(self.class)
    folder == other.folder &amp;&amp; name == other.name
  end
end

class DocumentPointer
  attr_reader :folder, :name

  def initialize(folder, name)
    @folder = folder
    @name = name
  end

  def ==(other)
    return false unless other.respond_to?(:folder)
    return false unless other.respond_to?(:name)
    folder == other.folder &amp;&amp; name == other.name
  end
end

doc_id = DocumentIdentifier.new('secret/area51', 'phone list')
pointer= DocumentPointer.new('secret/area51', 'phone list')

puts pointer == doc_id

##################################################
# &lt;===================OUTPUT===================&gt; #
# true                                           #
##################################################
</pre>
</div>
</li>
<li>我们可以看到ruby使用了respond_to?这个函数来寻找other是否有"某个名字的函数",
这再次印证了Ruby duck type的特征:"只要有相应的功能(函数), 我们就认为是同一
种类"
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-12-5" class="outline-3">
<h3 id="sec-12-5">Well-Behaved Equality</h3>
<div class="outline-text-3" id="text-12-5">
<ul class="org-ul">
<li>无论是使用kind_of?还是respond_to?一个无法弥补的问题是,我们的==operator做不
到真正的==operator的"互换性",比如上面的例子,如果我们把doc_id放在前面,肯定做
不到相等.像这样
<div class="org-src-container">

<pre class="src src-ruby">doc_id == pointer
</pre>
</div>
</li>
<li>尽管有一些方法可以规避这种问题,但其实大多数情况下,你并不需要一个==operator,
一个名字非常友好的函数就解决了你的问题,而且非常"Ruby"
<div class="org-src-container">

<pre class="src src-ruby">def is_same_document?(other)
  other.folder == folder &amp;&amp; other.name == name
end
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-12-6" class="outline-3">
<h3 id="sec-12-6">Triple Equals for Case Statements</h3>
<div class="outline-text-3" id="text-12-6">
<ul class="org-ul">
<li>===operator是ruby特有的,主要用在case statement里面. 之所以要设计===其实是为
了一种扩展性: ===operator的作用:
<ul class="org-ul">
<li>如果case后面是常规的操作数,那么===operator(在case里面)就等同于==operator
</li>
<li>如果case后面是正则表达式, when后面是字符串,那么===operator(在case里面)就
等同于=~operator
</li>
<li>如果case后面是一个instance, when后面是Class, 那么===operator(再case里面)
就等同于kind_of?
</li>
<li>以后,Ruby还可以从容的再加上其他的扩展
</li>
</ul>
</li>
<li>所以,绝大多数情况下,不用改写==operator,除非你要写什么奇怪的case语句
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-12-7" class="outline-3">
<h3 id="sec-12-7">Hash Tables and the eql? Method</h3>
<div class="outline-text-3" id="text-12-7">
<ul class="org-ul">
<li>就像===是为了case statement而单独创作的一样, eql?是单独为了比较Hash的Key而
创作的
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-12-8" class="outline-3">
<h3 id="sec-12-8">Building a Well-Behaved Hash Key</h3>
<div class="outline-text-3" id="text-12-8">
<ul class="org-ul">
<li>eql? 默认的行为也是再Object里面定义的.默认的hash会以key的object_id作为key,所以
下面的例子中, second_id虽然内容和first_id一致,但是object_id却不一致,最后会
导致取不到值,因为first_id.eql?(second_id)为false
<div class="org-src-container">

<pre class="src src-ruby">class Document
end

class DocumentIdentifier
  attr_reader :folder, :name

  def initializ(folder, name)
    @folder = folder
    @name = name
  end
end

hash = {}
document = Document.new
first_id = DocumentIdentifier.new('public', 'CoverStory')

hash[first_id] = document
second_id = DocumentIdentifier.new('public', 'CoverStory')

p hash[second_id]
p hash[first_id]

p first_id.eql?(second_id)

##################################################
# &lt;===================OUTPUT===================&gt; #
# nil                                            #
# #&lt;Document:0x007fccc097db98&gt;                   #
# false                                          #
##################################################
</pre>
</div>
</li>
<li>所以,如果你创建了一个class,并且很有可能作为hash的key(显然DocumentIdentifier
是要做key的).那么,你一定要:
<ol class="org-ol">
<li>实现hash函数. a.hash == b.hash
</li>
<li>实现一下eql? a.eql?(b)
</li>
</ol>
<div class="org-src-container">

<pre class="src src-ruby">class DocumentIdentifier
  # Code omitted...

  def hash
    folder.hash ^ name.hash
  end

  def eql?(other)
    return false unless other.instance_of?(slef.clas)
    folder == other.folder &amp;&amp; name == other.name
  end
end
</pre>
</div>
</li>
<li>我们可以看到hash函数使用了操作符^,这是一种非常经济实惠的创建hash值的方法
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-12-9" class="outline-3">
<h3 id="sec-12-9">Staying Out of Trouble</h3>
<div class="outline-text-3" id="text-12-9">
<ul class="org-ul">
<li>让equality可以正常工作是非常痛苦的.你能做的只是"减少痛苦":其实你可以直接忽
略equality的书写&#x2013;直到你遇到问题,直到你的代码崩溃,你再去看看equality的问题.
因为大部分的class,一辈子也不会去做==操作,或者作为Hash的key
</li>
<li>对于equality的完成还可以把工作"交给别人来做", 比如你的class主要是包裹了array
一层,那么你的equality主要在内部调用array的equality就可以了
<div class="org-src-container">

<pre class="src src-ruby">class DisArray
  attr_reader :my_array

  def initialize
    @my_array = []
  end

  def ==(other)
    return false unless other.kind_of?(DisArray)
    @my_array == other.my_array
  end

  def eql?(other)
    return false unless other.kind_of?(DisArray)
    @my_array.eql?(other.my_array)
  end

  def hash
    @my_array.hash
  end

  # ...
end
</pre>
</div>
</li>
</ul>
</div>
<div id="outline-container-sec-12-9-1" class="outline-4">
<h4 id="sec-12-9-1">In the Wild</h4>
<div class="outline-text-4" id="text-12-9-1">
<ul class="org-ul">
<li>抛开我们设计的比较复杂的类而言,对于数学界的数字,Ruby当然有不同的处理.
</li>
<li>比如下面的例子中, Ruby会把integer先转化成float,然后去对比
<div class="org-src-container">

<pre class="src src-ruby">puts 1 == 1.0

##################################################
# &lt;===================OUTPUT===================&gt; #
#  true                                          #
##################################################
</pre>
</div>
</li>
<li>而且,像数学里面的数字,他们直接是有顺序的. 1肯定小于2,大于0. 这种有序的类,
可以再引入一个操作符&lt;=&gt;: 如果小于返回-1, 等于返回0, 大于返回1
</li>
<li>Ruby有一种机制叫做Module,能够"注入代码". &lt;=&gt;operator由于非常常用,所以引入
了Comparable Module, 这个Comparable Module里面会给你写&lt;,&lt;=,&gt;=, &gt; 都基于你
的&lt;=&gt;operator
<div class="org-src-container">

<pre class="src src-ruby">class RomanNumerals
  include Comparable

  # Actual guts of the class omitted...

  def &lt;=&gt;(other)
    # Return -1, 0, or 1
  end
end
</pre>
</div>
</li>
<li>前面我们说过case后面跟instance,而when后面为Class的时候,===operator其实就是
kind_of?
<div class="org-src-container">

<pre class="src src-ruby">the_object = 3.14159

case the_object
when String
  puts "It's a string"
when Float
  puts "It's a float"
when Fixnum
  puts "It's a fixnum"
else
  puts "Dunno!"
end

##################################################
# &lt;===================OUTPUT===================&gt; #
# It's a float                                   #
##################################################
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-13" class="outline-2">
<h2 id="sec-13">Chapter 13: Get the Behavior You Nedd with Singleton and Class Methods</h2>
<div class="outline-text-2" id="text-13">
<ul class="org-ul">
<li>OO编程的核心思想其实就是建模世界.但是很多时候处心积虑创建出来的class可能不一
定"百分之百的"符合某个instance的要求.比如我们创建一个叫做American的类,其中有
两个函数eat_hamburgers和watch_football. 一个美国人可能确实是喜欢吃汉堡包,但
是他不喜欢看足球啊!
</li>
<li>Ruby对待这种情况的办法是singleton函数
</li>
</ul>
</div>
<div id="outline-container-sec-13-1" class="outline-3">
<h3 id="sec-13-1">A Stubby Puzzle</h3>
<div class="outline-text-3" id="text-13-1">
<ul class="org-ul">
<li>所谓singleton method,就是某个instance特有的函数(不是java里面的instance函数
哦,那个的意思是所有instance都有,而不是某个类有).
</li>
<li>除了numeric class或者symbol,其他的class或者新创建的class都支持singleton method
</li>
<li>创建singleton method的方法如下,其和普通method没有任何区别&#x2013;除了它只属于某个instance
<div class="org-src-container">

<pre class="src src-ruby">hand_built_stub_printer = Object.new

def hand_built_stub_printer.available?
  true
end

def hand_built_stub_printer.render(content)
  nil
end

p hand_built_stub_printer.available?
p hand_built_stub_printer.render(0)

##################################################
# &lt;===================OUTPUT===================&gt; #
# true                                           #
# nil                                            #
##################################################
</pre>
</div>
</li>
<li>singleton method会override所有的常规的,或者class-defined的method,比如
<div class="org-src-container">

<pre class="src src-ruby">uncooperative = "Don't ask my class"

def uncooperative.class
  "I'm not telling"
end

puts uncooperative.class

##################################################
# &lt;===================OUTPUT===================&gt; #
# I'm not telling                                #
##################################################
</pre>
</div>
</li>
<li>每次都把instance写出来,然后定义singleton函数的方法看起来有点傻,如果定义很多
singleton函数的话,可以试试下面的方法
<div class="org-src-container">

<pre class="src src-ruby">hand_built_stub_printer = Object.new

class &lt;&lt; hand_built_stub_printer
  def available?                # A singleton method
    true
  end

  def render                    # Another one
    nil
  end
end
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-13-2" class="outline-3">
<h3 id="sec-13-2">A Hidden, but Real Class</h3>
<div class="outline-text-3" id="text-13-2">
<ul class="org-ul">
<li>singleton函数能够实现的原因是再object和其class之间,Ruby"偷偷的"为你创建了
Singleton函数
<pre class="example">
+-----------+
|  Object   |
|           |
+-----^-----+
      |
      +-----------+
                  |
            +-----------+
            | Singleton |
            |  Class    |
            +-----+-----+
                  |
      +-----------+
      |
+-----------+
|stub_print |
|instance   |
+-----------+
</pre>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-13-3" class="outline-3">
<h3 id="sec-13-3">Class Methods: Singletons in Plain Sight</h3>
<div class="outline-text-3" id="text-13-3">
<ul class="org-ul">
<li>我们费尽非常大的力气实现了singleton method,看起来用处不多,但其实一个背后的
目的是:他是为了实现Ruby的重要feature, class method. 换句话说,我们每天都在使
用的class method其实是一个singleton method,让我们慢慢道来
</li>
<li>下面是一个常规的class函数用法.my_object的self表示他是一个叫做#&lt;Document:0x007fccc08840e8&gt;
的instance, 它的是由class Document创建来的
<div class="org-src-container">

<pre class="src src-ruby">class Document
end

my_object = Document.new

def my_object.explain
  puts "self is #{self}"
  puts "and its class is #{self.class}"
end

my_object.explain

##################################################
# &lt;===================OUTPUT===================&gt; #
# self is #&lt;Document:0x007fccc08840e8&gt;           #
# and its class is Document                      #
##################################################
</pre>
</div>
</li>
<li>我们把Document的new去掉再来看看,输出变得大不同
<div class="org-src-container">

<pre class="src src-ruby">class Document
end

my_object = Document

def my_object.explain
  puts "self is #{self}"
  puts "and its class is #{self.class}"
end

my_object.explain

##################################################
# &lt;===================OUTPUT===================&gt; #
# self is Document                               #
# and its class is Class                         #
##################################################
</pre>
</div>
</li>
<li>输出变成了:
<ul class="org-ul">
<li>my_object是一个叫做Document的instance
</li>
<li>这个instance是由class Class创建来的!
</li>
</ul>
</li>
<li>这就像我们解释了:
<ul class="org-ul">
<li>所有的class(比如Document,或者Fixnum, 或者String)都是对象!
</li>
<li>它们是由Class实例化来的
</li>
<li>class是这些对象的singleton method,所以我们可以这样
<div class="org-src-container">

<pre class="src src-ruby">class Document
end

def Document.explain
  puts "self is #{self}"
  puts "and its class is #{self.class}"
end

Document.explain

##################################################
# &lt;===================OUTPUT===================&gt; #
# self is Document                               #
# and its class is Class                         #
##################################################
</pre>
</div>
</li>
</ul>
</li>
<li>一旦知道了class是类Class一个singleton函数, 而所有的class都是Class的instance
那么下面代码就容易理解了,其实就是定义instance Document的singleton method
<div class="org-src-container">

<pre class="src src-ruby">class Document
  # previously, we have this
  # class &lt;&lt; hand_built_stub_printer
  # here the self is actually the same meaning with hand_built_stub_printer
  class &lt;&lt; self
    def find_by_name(name)
      # Find a document by name
    end

    def fidn_by_id(doc_id)
      # Find a document by id
    end
  end
end
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-13-4" class="outline-3">
<h3 id="sec-13-4">In the Wild</h3>
<div class="outline-text-3" id="text-13-4">
<ul class="org-ul">
<li>其实除了上面说到的class method, singleton class的用处并不多(Rspec可能会用到很多)
</li>
<li>大多数情况下,类函数显得更加"合适".而不是把类看成是Class的instance,然后定义instance method
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-13-5" class="outline-3">
<h3 id="sec-13-5">Staying Out of Trouble</h3>
<div class="outline-text-3" id="text-13-5">
<ul class="org-ul">
<li>singleton method最大的问题是和class method容易混淆.使用的时候:
<ul class="org-ul">
<li>class method是: 类名.函数名
</li>
<li>singleton method是: instance名.函数名
</li>
</ul>
</li>
<li>class method使用的时候,self的意义会变化!我们来看看一个常见的class method的
创建方法. 我们可以看到,在class method里面self转换成了一个Class类型的instance
<div class="org-src-container">

<pre class="src src-ruby">class Parent
  def self.who_am_i
    puts "The value of self is #{self}"
  end
end

class Child &lt; Parent
end

Parent.who_am_i
Child.who_am_i

##################################################
# &lt;===================OUTPUT===================&gt; #
# The value of self is Parent                    #
# The value of self is Child                     #
##################################################
</pre>
</div>
</li>
<li>如果是普通的方法的话,就会导致如下结果. 我们可以看到, 在普通的method里面,self
就是当前class的一个instance.
<div class="org-src-container">

<pre class="src src-ruby">class Parent
  def who_am_i
    puts "The value of self is #{self}"
  end
end

class Child &lt; Parent
end

parent = Parent.new
child = Child.new

parent.who_am_i
child.who_am_i

###################################################
# &lt;===================OUTPUT===================&gt;  #
# The value of self is #&lt;Parent:0x007fccc1070298&gt; #
# The value of self is #&lt;Child:0x007fccc1070270&gt;  #
###################################################
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-14" class="outline-2">
<h2 id="sec-14">Chapter 14: Use Class Instance Variables</h2>
<div class="outline-text-2" id="text-14">
<ul class="org-ul">
<li>Ruby中使用@@表示class variable, 经验告诉我们,class variable通常不是一个好主
意,所以要使用class instance variable来替代class variable.
</li>
<li>注意!是class instance variable而不是instance variable.
</li>
<li>class instance variable是一个"中间状态":
<ul class="org-ul">
<li>它和instance variable长得很像都是一个@,但是它不在某个method里面
</li>
<li>它和class variable一样,再class里面,但是在所有的method的外面.
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-14-1" class="outline-3">
<h3 id="sec-14-1">A Quick Review of Class Variables</h3>
<div class="outline-text-3" id="text-14-1">
<ul class="org-ul">
<li>我们想给Document增加尺寸这个属性,先看看把它加成class variable的版本的效果
<div class="org-src-container">

<pre class="src src-ruby">class Document
  @@default_paper_size = :a4

  def self.default_paper_size
    @@default_paper_size
  end

  def self.default_paper_size=(new_size)
    @@default_paper_size = new_size
  end

  attr_accessor :title, :author, :content
  attr_accessor :paper_size

  def initialize(title, author, content)
    @title = title
    @author = author
    @content = content
    @paper_size = @@default_paper_size
  end

  # Rest of the class omitted...
end
</pre>
</div>
</li>
<li>看似完美的解决方法其实不堪一击,后面章节会进行解释
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-14-2" class="outline-3">
<h3 id="sec-14-2">Wandering Variables</h3>
<div class="outline-text-3" id="text-14-2">
<ul class="org-ul">
<li>先来了解一下编译器如何解析, 在Document class一进去看到@@default_paper_size
     的时候,编译器第一反应是找它第一次出现的位置,所以会"追根溯源"的找:
<ul class="org-ul">
<li>要么在某个base class里面找到了那个@@default_paper_size
</li>
<li>要么没有找到,就再当前的class里面设置一个new class variable
</li>
</ul>
</li>
<li>Resume是一种文档,所以继承了Document, 增加了一个class variable叫做default_font
<div class="org-src-container">

<pre class="src src-ruby">class Resume &lt; Document
  @@default_font = :arial

  def self.default_font = (font)
    @@default_font = font
  end

  def self.default_font
    @@default_font
  end

  attr_accessor :font

  def initialize
    @font = @@default_font
  end

  # Rest of the class omitted...
end
</pre>
</div>
</li>
<li>Presentation也是一种文档,也继承了Document, 也增加了一个叫做default_font的
     class variable
<div class="org-src-container">

<pre class="src src-ruby">class Presentation &lt; Document
  @@default_font = :nimbus

  def self.default_font = (font)
    @@default_font = font
  end

  def self.default_font
    @@default_font
  end

  attr_accessor :font

  def initialize
    @font = @@default_font
  end

  # ...
end
</pre>
</div>
</li>
<li>有一天你不知道哪根筋错了,竟然给Document,也就是Resume和Presentation的父类也
定义了一个名字相同的class variable. 然后,一切都毁灭了
<div class="org-src-container">

<pre class="src src-ruby">class Document
  @@dafault_font = :times
  # ...
end
</pre>
</div>
</li>
<li>我们用一个简单的例子来描绘一下"毁灭"的现场
<div class="org-src-container">

<pre class="src src-ruby">class Base
  @@cv = :hello
  attr_reader :out

  def initialize
    @out = @@cv
  end
end
b1 = Base.new
p b1.out

class Derived &lt; Base
  @@cv = :world
  attr_reader :out

  def initialize
    @out = @@cv
  end
end

b2 = Base.new
d = Derived.new

p b2.out
p d.out

##################################################
# &lt;===================OUTPUT===================&gt; #
# :hello                                         #
# :world                                         #
# :world                                         #
##################################################
</pre>
</div>
</li>
<li>也就是说如果我们Document系列代码有如下调用的话, 因为有Document再中间"牵线搭
桥", 会出现,所有的Document系列的字体都称了:arial
<div class="org-src-container">

<pre class="src src-ruby">require 'document'
require 'resume'                # Load Resume first
require 'presentation'          # then Presentation
</pre>
</div>
</li>
<li>出现上面这种问题的原因,是class variable的封装性不够,class variable其实和原
来面向过程编程中的全局变量很像. class variable和某个specific的class联系的不
够紧密,反而是和整个继承序列所有的class都有关系,被David Black称作"vertical
global variables" (非常生动哈)
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-14-3" class="outline-3">
<h3 id="sec-14-3">Getting Control of the Data in Your Class</h3>
<div class="outline-text-3" id="text-14-3">
<ul class="org-ul">
<li>解决方法也很简单,"去掉一个@", 我们使用class instance variable. 少了一个@后,
整个default_font就是和某个class紧密结合了.而且不出意外的再initialize的时候
给每个instance都赋好了值
<div class="org-src-container">

<pre class="src src-ruby">class Document
  @default_font = :times

  def self.default_font=(font)
    @default_font = font
  end

  def self.default_font
    @default_font
  end
  # ...
end
</pre>
</div>
</li>
<li>由于我们实现了default_font=函数,所以我们可以做到如下:
<div class="org-src-container">

<pre class="src src-ruby">Document.default_font = :arial
</pre>
</div>
</li>
<li>由于我们实现了default_font函数,所以我们可以直接在其他method,比如initialize
里面直接调用它
<div class="org-src-container">

<pre class="src src-ruby">def initialize(title, author)
  @title = title
  @author = author
  @font = Document.default_font
end
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-14-4" class="outline-3">
<h3 id="sec-14-4">Class Instance Variable and Subclasses</h3>
<div class="outline-text-3" id="text-14-4">
<ul class="org-ul">
<li>我们刚才发现class variable的问题是通过subclass,所以我们还是要看看class
instance variable在subclass存在时候的表现
<div class="org-src-container">

<pre class="src src-ruby">class Base
  @civ = :hello
  class &lt;&lt; self
    attr_accessor :civ
  end

  attr_reader :out

  def initialize
    @out = Base.civ
  end
end

class Derived &lt; Base
  @civ = :world

  class &lt;&lt; self
    attr_accessor :civ
  end

  attr_reader :out

  def initialize
    @out = Derived.civ
  end
end

b2 = Base.new
d = Derived.new

p b2.out
p d.out

##################################################
# &lt;===================OUTPUT===================&gt; #
# :hello                                         #
# :world                                         #
##################################################
</pre>
</div>
</li>
<li>表现不错,没有出现class variable的错误.其原因自然是因为class instance variable
是和某个specific的class紧密联系,而不和其他class分享的.而且我们上面非常巧妙
的使用了Singleton variable来减少代码量
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-14-5" class="outline-3">
<h3 id="sec-14-5">Adding Some Convenience to Your Class Instance</h3>
<div class="outline-text-3" id="text-14-5">
<ul class="org-ul">
<li>前面说过了我们替代class variable的选择是class instance variable, 他本质上是
instance variable(因为只有一个@),只是碰巧不小心再class里面,在method外面.
</li>
<li>我们第一个例子介绍class instance variable的时候,给他写了setter getter函数,
第二个例子就用了Ruby的attr_accessor来减少代码,还用了singleton method. 否则
instance是无法调动它们的
<div class="org-src-container">

<pre class="src src-ruby">class Document
  @default_font = :times
  class &lt;&lt; self
    attr_accessor :default_font
  end
  # ...
end
</pre>
</div>
</li>
<li>这样一设置.Document有了好几个singleton method可以调用.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-14-6" class="outline-3">
<h3 id="sec-14-6">In the Wild</h3>
<div class="outline-text-3" id="text-14-6">
<ul class="org-ul">
<li>Rails的ActiveRecord使用了很多的class instance variable.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-14-7" class="outline-3">
<h3 id="sec-14-7">Staying Out of Trouble</h3>
<div class="outline-text-3" id="text-14-7">
<ul class="org-ul">
<li>使用class variable的情况极其少见,要非常小心,推荐使用class instance variable
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-15" class="outline-2">
<h2 id="sec-15">Chapter 15: Use Modules as Name Spaces</h2>
<div class="outline-text-2" id="text-15">
</div><div id="outline-container-sec-15-1" class="outline-3">
<h3 id="sec-15-1">A Place for Your Stuff, with a Name</h3>
<div class="outline-text-3" id="text-15-1">
<ul class="org-ul">
<li>Ruby的class第一是一个创建object的工厂, 第二是一个把method和variable装在一起
的container
</li>
<li>而Ruby的Module,则只是一个container,它不能创建object. Module包罗万象,可以包
括:
<ul class="org-ul">
<li>method
</li>
<li>constant
</li>
<li>class
</li>
<li>other module
</li>
</ul>
</li>
<li>先看下面的一个module的例子,其中包括两个class, 其最明显的作用体现出来了:能把
相关联的class聚集在一起. 更重要的优点是,你在Rendering的module里面定义了Font
等于给Font了一层namespace,即便再其他Module里面也定义了Font,也不用害怕了.
<div class="org-src-container">

<pre class="src src-ruby">module Rendering
  class Font
    attr_accessor :name, :weight, :size

    def initialize(name, weight=:normal, size=10)
      @name = name
      @weight = weight
      @wize = size
    end

    # ...
  end

  class PaperSize
    attr_accessor :name, :width, :height

    def initialize(name='US Let', width=8.5, height=11.0)
      @name = name
      @width = width
      @height = height
    end
    # ...
  end
end
</pre>
</div>
</li>
<li>Module还可也用来"存放"const(其实class name也是一种const,所以放const没有什么
奇怪的)
<div class="org-src-container">

<pre class="src src-ruby">module Rendering
  # Font and PaperSize classes omitted...

  DEFAULT_FONT = Font.new('default')
  DEFAULT_PAPER_SIZE = PaperSize.new
end
</pre>
</div>
</li>
<li>使用方法是加::, 比如Render::DEFAULT_PAPER_SIZE
</li>
<li>Module还是相互间可以嵌套的
<div class="org-src-container">

<pre class="src src-ruby">module WordProcessor
  module Rndering
    # ...
  end
end
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-15-2" class="outline-3">
<h3 id="sec-15-2">A Home for Those Utility Methods</h3>
<div class="outline-text-3" id="text-15-2">
<ul class="org-ul">
<li>Module是一切helper函数(不知道放到哪里合适的函数)的理想的放置场所.比如我们的
文字处理的module里面可能会有一些设计进制转换的helper函数
<div class="org-src-container">

<pre class="src src-ruby">module WordProcessor
  def self.points_to_inches(points)
    points / 72.0
  end

  def self.inches_to_points(inches)
    inches * 72.0
  end

  # ...
end
</pre>
</div>
</li>
<li>调用module的常量,使用::, 函数的话也可以使用::, 但是更多的人喜欢使用"."
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-15-3" class="outline-3">
<h3 id="sec-15-3">Building Modules a Little at a Time</h3>
<div class="outline-text-3" id="text-15-3">
<ul class="org-ul">
<li>Module暴露自己是namespace的地方在于使用方法:
<ul class="org-ul">
<li>我们在font.rb里面写下如下代码
<div class="org-src-container">

<pre class="src src-ruby">module Rendering
  class Font
    # Bulk of class omitted...
  end
end
</pre>
</div>
</li>
<li>我们在paper_size.rb里面定义了下面的代码
<div class="org-src-container">

<pre class="src src-ruby">module Rendering
  class PaperSize
    # Bulk of class omitted...
  end

  DEFAULT_PAPER_SIZE = PaperSize.new
end
</pre>
</div>
</li>
</ul>
</li>
<li>我们的module被写在了两个地方.然后使用的时候一块require就可以了
<div class="org-src-container">

<pre class="src src-ruby">require 'font'
require 'paper_size'
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-15-4" class="outline-3">
<h3 id="sec-15-4">Treat Modules Like the Objects That They Are</h3>
<div class="outline-text-3" id="text-15-4">
<ul class="org-ul">
<li>Ruby中一切都是对象,Module也是.所以下面的代码可行:
<div class="org-src-container">

<pre class="src src-ruby">the_module = Rendering

times_new_roman_font = the_module::Font.new('times-new-roman')
</pre>
</div>
</li>
<li>Module既是namespace,又是object的特性,可以用来在running time替换底层的实际起
作用的代码,比如我们有两种打印机,所以我们把它们分别放到两个module里面:
<div class="org-src-container">

<pre class="src src-ruby">module TonsOToner
  class PrintQueue
  end

  class Administration
  end
end

module OceansOfInk
  class PrintQueue
  end

  class Administration
  end
end
</pre>
</div>
</li>
<li>在使用的时候,就可以根据不同的情况,替换底层的代码
<div class="org-src-container">

<pre class="src src-ruby">if use_laser_printer
  print_module = TonsOToner
else
  print_module = OceansOfInk
end

# Later...
admin = print_module::Administration.new
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-15-5" class="outline-3">
<h3 id="sec-15-5">Staying Out of Trouble</h3>
<div class="outline-text-3" id="text-15-5">
<ul class="org-ul">
<li>判断是否需要给class增加一个Module的方法,是看class名字是不是很多都有相同的前
缀.如果有很多HelloWorld_XXX,那么就干脆创建一个HelloWorld的Module
</li>
<li>Module和Module不要嵌套的太深,我们需要简洁的代码
</li>
<li>要理解两种Module里面"直接"嵌套的method的不同:
<ul class="org-ul">
<li>如果你像mix into其他代码,那么这么写
<div class="org-src-container">

<pre class="src src-ruby">module WordProcessor
  def points_to_inches(points)
    points / 72.0
  end
end
</pre>
</div>
</li>
<li>如果是要做helper函数,那么这么写
<div class="org-src-container">

<pre class="src src-ruby">module WordProcessor
  def self.points_to_inches(points)
    points / 72.0
  end
end
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-15-6" class="outline-3">
<h3 id="sec-15-6">In the Wild</h3>
<div class="outline-text-3" id="text-15-6">
<ul class="org-ul">
<li>DataMapper是一个运用Module非常好的例子
</li>
<li>RubyGems也是一个14000行的module的代码.
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-16" class="outline-2">
<h2 id="sec-16">Chapter 16: Use Modules as Mixins</h2>
<div class="outline-text-2" id="text-16">
<ul class="org-ul">
<li>上一节我们讲到ruby class(其实也是所有OO语言中的class)的两个作用:
<ul class="org-ul">
<li>instance的factory
</li>
<li>method和variable的container
</li>
<li>其实还有第三个,就是作为一个super class. 设计类第一步就是要选择是否继承,和
到底继承谁.继承了某个class,也就继承了一大笔财富(或者负担)
</li>
</ul>
</li>
<li>Ruby和其他语言不一样的地方.是它不单单可以通过"继承"来获取一些函数或者变量,还
可以通过mix in的方法来获取(在module的帮助下)
</li>
</ul>
</div>
<div id="outline-container-sec-16-1" class="outline-3">
<h3 id="sec-16-1">Better Books with Modules</h3>
<div class="outline-text-3" id="text-16-1">
<ul class="org-ul">
<li>我们经常会使用一些"陈词滥调", 我们设计了一段代码来统计content里面,有多少"陈
词滥调"
<div class="org-src-container">

<pre class="src src-ruby">class Document
  attr_accessor :content

  def initialize(content)
    @content = content
  end

  CLICHES = [ /play fast and loose/,
              /make no mistake/,
              /does the trick/,
              /off and running/,
              /my way or the highway/]

  def number_of_cliches
    CLICHES.inject(0) do |count, pharse|
      count += 1 if pharse =~ content
      count
    end
  end
end

doc = Document.new("off and running, make mistake,hello world, my way or the \
highway does the trick")
puts doc.number_of_cliches

##################################################
# &lt;===================OUTPUT===================&gt; #
# 3                                              #
##################################################
</pre>
</div>
</li>
<li>我可以看到上面代码中,再次使用了inject.
</li>
<li>这段代码经历了时间的考验,得到了很多人的认同,所以想不加更改的加入到一个新的
和原来完全没有关系的class(叫做ElectronicBook)里面.
</li>
<li>在其他语言里面,我们可能会把这段代码提交到一个公共的base class,比如叫做Tome,
把number_of_cliches放入Tome,然后让ElectronicBook和Document都去继承Tome.这种
做法评价起来也就是将将能用.如果公用的代码很多,也不方便重构到共同的base class里面
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-16-2" class="outline-3">
<h3 id="sec-16-2">Mixin Modules to the Rescue</h3>
<div class="outline-text-3" id="text-16-2">
<ul class="org-ul">
<li>Ruby当然有更好的解决方案啦.那就是使用Module进行mixin. 首先把number_of_cliche
     放入一个module里面
<div class="org-src-container">

<pre class="src src-ruby">module WritingQuality
  CLICHES =[ /play fast and loose/,
             /make no mistake/,
             /does the trick/,
             /off and running/,
             /my way or the highway/
           ]

  def number_of_cliches
    CLICHES.inject(0) do |count, phrae|
      count += 1 if pharse =~content
      count
    end
  end
end
</pre>
</div>
</li>
<li>注意, number_of_cliches在这里是一个instance method in the module(没有self),
而有self的叫做model-level method
</li>
<li>然后我们在两个class里面都include 这个module
<div class="org-src-container">

<pre class="src src-ruby">class Document
  include WritingQuality

  # Lots of stuff omitted...
end

class ElectronicBook &lt; ElectronicText
  include WritingQuality

  # Lots of stuff omitted...
end
</pre>
</div>
</li>
<li>Module的魅力,还在于能够在一个代码里面include多个module,这更减小了代码量,提
高了代码质量,非常灵活
<div class="org-src-container">

<pre class="src src-ruby">module ElectronicBook &lt; ElectronicText
  include WritingQuality
  include ProjectManagement
  include AuthorAccountTracking

  # Lots of stuff omitted
end
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-16-3" class="outline-3">
<h3 id="sec-16-3">Extending a Module</h3>
<div class="outline-text-3" id="text-16-3">
<ul class="org-ul">
<li>上面的做法,是把某个module里面的代码引入到某个class里面,成为其"instance method",
如果我想让module里面的代码变成"class method",那么就应该这样
<div class="org-src-container">

<pre class="src src-ruby">module Finders
  def find_by_name(name)
    # Find a doc by name
  end

  def find_by_id(doc_id)
    # Find a doc by id
  end
end

class Document
  # Most of the class omitted
  class &lt;&lt; self
    include Finders
  end
end
</pre>
</div>
</li>
<li>这实在是一招"语法糖"了,需要细细解释:
<ul class="org-ul">
<li>首先,我们的method在Module里面都是普通的instance method
</li>
<li>其次,我们使用了class &lt;&lt; self, 这里的self指的是类Class的instance(Document),
引入了Finder的话,那么就让instance Document有了两个singleton method.
</li>
<li>instance Document的singleton method,其实也就是class Document的class method
从使用方法就看出来了.都是调用Document(而不是其instance,比如doc)
<div class="org-src-container">

<pre class="src src-ruby">war_and_peace = Document.find_by_name('War And Peace')
</pre>
</div>
</li>
</ul>
</li>
<li>把module中的method作为singleton method引入Class的instance的做法,一是太难以
为新手所理解,二来使用频繁.所以Ruby直接发明了一个关键字extend
<div class="org-src-container">

<pre class="src src-ruby">class Document
  extend Finders
  # Most of the class omitted
end
</pre>
</div>
</li>
<li>这样一写,你的Document也就可以使用Document.find_by_name和Document.find_by_id
     了
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-16-4" class="outline-3">
<h3 id="sec-16-4">Staying Out of Trouble</h3>
<div class="outline-text-3" id="text-16-4">
<ul class="org-ul">
<li>Module插入的这种方法,和singleton插入的方法很类似,都是编译器默默的为你生成一
个"中间的状态".
<pre class="example">
+-----------+
|  Object   |
|           |
+-----^-----+
      |
      +-----------+
                  |
            +--------------+
            |WritingQuality|
            |              |
            +-----+--------+
                  |
      +-----------+
      |
+-----------+
|  Document |
|           |
+-----------+
</pre>
</li>
<li>但是你在使用class 函数的时候(mix in了),是发现不了中间状态的.但是你使用
Instance_Name.kind_of?(ModuleName)是可以发现你是否include或者extend了这个
module的. 注意一定要使用instance来调用kind_of?
<div class="org-src-container">

<pre class="src src-ruby">module M1
end

module M2
end

class Foo
  include M1
  extend M2
end

puts Foo.class
puts "---Foo.new is a instance---"
puts Foo.new.kind_of?(M1)
puts Foo.kind_of?(M1)

puts "---Foo is a class Class's instance---"
puts Foo.kind_of?(M2)
puts Foo.new.kind_of?(M2)

##################################################
# &lt;===================OUTPUT===================&gt; #
# Class                                          #
# ---Foo.new is a instance---                    #
# true                                           #
# false                                          #
# ---Foo is a class Class's instance---          #
# true                                           #
# false                                          #
##################################################
</pre>
</div>
</li>
<li>ancestors函数可以返回完整的"继承上的先驱", 但是只有include的,没有extend的
<div class="org-src-container">

<pre class="src src-ruby">module M1
end

module M2
end

class Foo
  include M1
  extend M2
end

p Foo.ancestors

##################################################
# &lt;===================OUTPUT===================&gt; #
# [Foo, M1, Object, Kernel, BasicObject]         #
##################################################
</pre>
</div>
</li>
<li>因为从原理上来讲,其实Module是创建了一个"隐藏的superclass",所以module引入的这
些函数都是从"superclass"来的"遗产". 所以当继承序列后面的class不想使用这些method
的时候,它们可以选择override这些函数(重新写一个函数,来掩盖原来的函数)
<div class="org-src-container">

<pre class="src src-ruby">class Document
  incldue WritingQuality
end

# For Political Book, cliche's number is None
class PoliticalBook &lt; Document
  def number_of_cliches
    0
  end
end
</pre>
</div>
</li>
<li>由于include一次module就会引入一个"隐藏的superclass", 多次include以后,多个
superclass排列的顺序是,先来的最root,后来的最接近当前的class,所以如果在多个被
include的module里面有同名的函数的话,最后include的module里面的函数会最终获得
胜利(当然,如果当前class也实现了一份,它是最最会获得胜利的)
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-16-5" class="outline-3">
<h3 id="sec-16-5">In the Wild</h3>
<div class="outline-text-3" id="text-16-5">
<ul class="org-ul">
<li>Rails代码里面使用Module定义了无数的help function
<div class="org-src-container">

<pre class="src src-ruby">module ActionView
  # Huge amouts of code and helpful documentation omitted...
  module Helpers
    module FormHelper
      def label(object_name, method, text = nil, options = {})
        # ...
      end

      def radio_button(ojbect_name, method, tag_value, options={})
      end
    end
  end
end
</pre>
</div>
</li>
<li>Module的另一大用处"放常量", 被sqlite3 gem使用的恰到好处
<div class="org-src-container">

<pre class="src src-ruby">module ErrorCode
  OK          = 0     # Successful result
  ERROR       = 1     # SQL error or missing database
  INTERNAL    = 2     # An internal logic error in SQLite
  # ...
end
</pre>
</div>
</li>
<li>前面说过常量要这样使用ErrorCode::OK, 但是你include了以后,肯定是可以直接使用的
<div class="org-src-container">

<pre class="src src-ruby">class SomeSQLiteApplication
  include ErrorCode

  def print_status_message(status)
    if status == ERROR
      puts "It failed!"
    elsif status == OK
      puts "It worked!"
    else
      puts "Status was #{status}"
    end
  end
end
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-17" class="outline-2">
<h2 id="sec-17">Chapter 17: Use Blocks to Iterate</h2>
<div class="outline-text-2" id="text-17">
<ul class="org-ul">
<li>code block是Ruby的瑞士军刀,基本上到处都会有code block的影子
</li>
</ul>
</div>
<div id="outline-container-sec-17-1" class="outline-3">
<h3 id="sec-17-1">A Quick Review of Code Blocks</h3>
<div class="outline-text-3" id="text-17-1">
<ul class="org-ul">
<li>在Ruby中,你可以把code block放到一个函数的后面,像如下一样使用
<div class="org-src-container">

<pre class="src src-ruby">do_domething do
  puts "Hello from inside the block"
end
</pre>
</div>
</li>
<li>或者使用一个{}来替代do/end
<div class="org-src-container">

<pre class="src src-ruby">do_something {puts "Hello from inside the block"}
</pre>
</div>
</li>
<li>其原理简单点说,就是每当你把一个code block "附着"在某个函数的后面的时候,其实
Ruby解释器内部是把这个code block包裹成一个"秘密参数", 然后把"秘密参数"发送
给这个函数.
</li>
<li>这个秘密参数也可以再函数内部,通过block_gen?来判断
<div class="org-src-container">

<pre class="src src-ruby">def do_something
  yield if block_given?
end

do_something {puts "testing"}
puts "-----------------------&gt;"
do_something

##################################################
# &lt;===================OUTPUT===================&gt; #
# testing                                        #
# -----------------------&gt;                       #
##################################################
</pre>
</div>
</li>
<li>code block和函数之间是可以相互交流数据的:
<ul class="org-ul">
<li>从函数到code block这个方向的交流方式是"参数":函数可以再yield后面加一个参
数,然后这个参数就可以在code block里面使用了
<div class="org-src-container">

<pre class="src src-ruby">def do_something_with_an_arg
  yield("Hello World") if block_given?
end

do_something_with_an_arg do |message|
  puts "The message is #{message}"
end

##################################################
# &lt;===================OUTPUT===================&gt; #
# The message is Hello World                     #
##################################################
</pre>
</div>
</li>
<li>从code block到函数这个方向的交流方式是"返回值":code block的最后一行(或者
return的数据)会作为yield函数的返回值在method里面有所体现
<div class="org-src-container">

<pre class="src src-ruby">def print_the_value_returned_by_the_block
  if block_given?
    value = yield
    puts "The block returned #{value}"
  end
end

print_the_value_returned_by_the_block {3.14159 / 4.0}

##################################################
# &lt;===================OUTPUT===================&gt; #
# 0.7853975                                      #
##################################################
</pre>
</div>
</li>
</ul>
</li>
<li>从code block和函数的相互交流方式来看. yield就是code block的代表:
<ul class="org-ul">
<li>yield函数的参数,会作为code block的变量
</li>
<li>code block的返回值,会作为yield函数的返回值
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-17-2" class="outline-3">
<h3 id="sec-17-2">One Word after Another</h3>
<div class="outline-text-3" id="text-17-2">
<ul class="org-ul">
<li>我们可以试着给自己的Document类添加一个遍历的函数each_word, 其也是把每一个元
素都作为yield的参数,yield的参数也就是code block的变量啦
<div class="org-src-container">

<pre class="src src-ruby">class Document
  attr_accessor :content, :words

  def initialize(content)
    @content = content
    @words = content.split
  end

  def each_word
    word_array = words
    index = 0
    while index &lt; words.size
      yield(word_array[index])
      index += 1
    end
  end
end

d = Document.new('Life is like a box of ...')
d.each_word {|word| puts word}

##################################################
# &lt;===================OUTPUT===================&gt; #
# Life                                           #
# is                                             #
# like                                           #
# a                                              #
# box                                            #
# of                                             #
# ...                                            #
##################################################
</pre>
</div>
</li>
<li>当然了,我们真正实现each_word的方法是依赖已经存在的Array#each函数
<div class="org-src-container">

<pre class="src src-ruby">def each_word
  words.each {|word| yield(word)}
end
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-17-3" class="outline-3">
<h3 id="sec-17-3">As Many Iterators as You Like</h3>
<div class="outline-text-3" id="text-17-3">
<ul class="org-ul">
<li>除了each_word,我们还可以有很多很多的iterator, 因为这种函数总是很受欢迎,但是
命名规则一定是each_xxx
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-17-4" class="outline-3">
<h3 id="sec-17-4">Iterating over the Ethereal</h3>
<div class="outline-text-3" id="text-17-4">
<ul class="org-ul">
<li>Ruby的iterator甚至可以在"不创建collection"的情况下,就打印出"某个臆想的
collection"所有的数据
<div class="org-src-container">

<pre class="src src-ruby">12.times {|x| puts "The number is #{x}"}

##################################################
# &lt;===================OUTPUT===================&gt; #
# The number is 0                                #
# The number is 1                                #
# The number is 2                                #
# The number is 3                                #
# The number is 4                                #
# The number is 5                                #
# The number is 6                                #
# The number is 7                                #
# The number is 8                                #
# The number is 9                                #
# The number is 10                               #
# The number is 11                               #
##################################################
</pre>
</div>
</li>
<li>我们也可以通过code block来创建这种"虚拟的collection",比如Document中,我们想
把所有的单词"两两"结合的打印出来.于是就有了下面的代码.可是我们从来没有创建
过这种"两个"单词为一组的,长度为4的array
<div class="org-src-container">

<pre class="src src-ruby">class Document

  def initialize(content)
    @content = content
    @words = content.split
  end

  def each_word_pair
    word_array = words
    index = 0
    while index &lt; (word_array.size-1)
      yield word_array[index], word_array[index+1]
      index += 1
    end
  end
end

doc = Document.new('I love donuts mmmm donuts')
doc.each_word_pair{|first, second| puts "#{first} #{second}"}

##################################################
# &lt;===================OUTPUT===================&gt; #
# I love                                         #
# love donuts                                    #
# donuts mmmm                                    #
# mmmm donuts                                    #
##################################################
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-17-5" class="outline-3">
<h3 id="sec-17-5">Enumerable: Your Iterator on Steroids</h3>
<div class="outline-text-3" id="text-17-5">
<ul class="org-ul">
<li>前面说过,你的iterator最好是以each_xx命名,而最重要的那个iterator,一定要以each
来命名,这是有原因的:因为Ruby有一个很好用的Module Enumerable, 它可以mix in到
一个class起作用,前提是:这个class的iterator的名字是each!(因为each已经写死在
Enumerable的代码里面了)
</li>
<li>Enumerable的功能代码非常的多,比如, each实现之后,再加include Enumerable就能
使用Enumerable提供的helper函数
<div class="org-src-container">

<pre class="src src-ruby">class Document
  include Enumerable

  attr_accessor :words

  def initialize(content)
    @content = content
    @words = content.split
  end


  def each
    words.each {|word| yield(word)}
  end
end

doc = Document.new('Go ahead make my day')
puts doc.include?("make")
puts doc.include?("Punk")

##################################################
# &lt;===================OUTPUT===================&gt; #
# true                                           #
# false                                          #
##################################################
</pre>
</div>
</li>
<li>Enumerable还提供了each_cons, 也就是会把相邻的n个参数组成数组,并返回
<div class="org-src-container">

<pre class="src src-ruby">class Document
  include Enumerable

  attr_accessor :words

  def initialize(content)
    @content = content
    @words = content.split
  end

  def each
    words.each {|word| yield(word)}
  end
end

doc = Document.new('Go ahead make my day')
doc.each_cons(2) {|array| p array}

##################################################
# &lt;===================OUTPUT===================&gt; #
# ["Go", "ahead"]                                #
# ["ahead", "make"]                              #
# ["make", "my"]                                 #
# ["my", "day"]                                  #
##################################################
</pre>
</div>
</li>
<li>如果你提供了&lt;=&gt;操作函数的话(也就是你的instance可以比较大小),那么你还可以使
用sort函数
</li>
<li>Array其实也include Enumerable,所以上面的这些method,它都有.
</li>
<li>除了提供函数, Enumerable还在内部实现了Enumerator class
<div class="org-src-container">

<pre class="src src-ruby">class Document
  include Enumerable

  attr_accessor :words

  def initialize(content)
    @content = content
    @words = content.split
  end

  def each
    words.each {|word| yield word}
  end

  def each_characters
    index = 0
    while index &lt; @content.size
      yield(@content[index])
      index += 1
    end
  end
end

doc = Document.new('hello world, american')
enum = Enumerator.new(doc, :each)
p enum.sort
enum = Enumerator.new(doc, :each_characters)
p enum.sort

##################################################
# &lt;===================OUTPUT===================&gt; #
# ["american", "hello", "world,"]                #
# [" ", " ", ",", "a", "a", "c", "d", "e", "e",  #
#  "h", "i", "l", "l", "l", "m", "n", "o", "o",  #
#  "r", "r", "w"]                                #
##################################################
</pre>
</div>
</li>
<li>我们可以从上面的例子看到Enumerator class的初始化方法是提供两个参数:
<ol class="org-ol">
<li>collection: 把我们的Document的实例化成员doc看成是一个我们自己customize的
collection.
</li>
<li>遍历方法: 提供了collection,我们还可以提供默认的遍历方法: each_xx
</li>
</ol>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-17-6" class="outline-3">
<h3 id="sec-17-6">Staying Out of Trouble</h3>
<div class="outline-text-3" id="text-17-6">
<ul class="org-ul">
<li>自己书写的iterator是为code block服务的,但是code block很可能是其他人的code,
如何保证你的代码不会被别人中断(比如通过exception). 下面的例子就是这种情况,
我们再iterator申请了某个资源,但是code block使用的时候就直接exception了(去了
其他不知道哪里的代码流程)
<div class="org-src-container">

<pre class="src src-ruby"># iterator code in one place

def each_name
  name_server = open_name_server # Get some expensive resource
  while name_server.has_more?
    yield name_server.read_name
  end
  name_server.close             # may never closed
end

# code bloc code in somewhere else
doc.each_word do |word|
  raise 'boom' if word == 'now'
end
</pre>
</div>
</li>
<li>解决的办法当然有: ensure
<div class="org-src-container">

<pre class="src src-ruby">def each_name
  name_server = open_name_server # Get some expensive resouce
  begin
    while name_server.has_more?
      yield name_server.read_name
    end
  ensure
    name_server.close           # Close the expensive resource
  end
end
</pre>
</div>
</li>
<li>不止exception, break 和显式的return都会触发ensure.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-17-7" class="outline-3">
<h3 id="sec-17-7">In the Wild</h3>
<div class="outline-text-3" id="text-17-7">
<ul class="org-ul">
<li>Array和Hash有each不奇怪,奇怪的是Dir也有each函数
<div class="org-src-container">

<pre class="src src-ruby">puts "Contents of /etc directory:"
etc_dir = Dir.new("/Users/hfeng/tmp")
etc_dir.each {|entry| puts entry}

##################################################
# &lt;===================OUTPUT===================&gt; #
# Contents of /etc directory:                    #
# .                                              #
# ..                                             #
# passwd.txt                                     #
# sel-intro.txt                                  #
##################################################
</pre>
</div>
</li>
<li>还有一个非常有趣的函数, Resolv#each_address:能够找出某个域名的所有的ip地址
<div class="org-src-container">

<pre class="src src-ruby">require 'resolv'
Resolv.each_address("www.google.com") {|x| puts x}

##################################################
# &lt;===================OUTPUT===================&gt; #
# 173.194.127.179                                #
# 173.194.127.180                                #
# 173.194.127.176                                #
# 173.194.127.177                                #
# 173.194.127.178                                #
##################################################
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-18" class="outline-2">
<h2 id="sec-18">Chapter 18: Execute Around with a Block</h2>
<div class="outline-text-2" id="text-18">
</div><div id="outline-container-sec-18-1" class="outline-3">
<h3 id="sec-18-1">Add a Little Logging</h3>
<div class="outline-text-3" id="text-18-1">
<ul class="org-ul">
<li>Logging是非常好的debug方式, 所以我们在创建下面的应用的时候,非常希望创建一个
log来记录异常
<div class="org-src-container">

<pre class="src src-ruby">class SomeApplication
  def initialize(logger)
    @logger = logger
  end

  def do_something
    begin
      @logger.debug('Starging Document load')
      doc = Document.load('resume.txt')
      @logger.debug('Completed Document load')
    rescue
      @logger.error('Load failed!')
    end

    # Do something interesting with the document
    begin
      @logger.debug('Starting Document save')
      doc.save
      @logger.debug('Completed Document save')
    rescue
      @logger.error('Save failed!')
    end
  end
end
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-18-2" class="outline-3">
<h3 id="sec-18-2">Carring the Answers Back</h3>
<div class="outline-text-3" id="text-18-2">
<ul class="org-ul">
<li>上面做法的缺点是看起来很不清晰,而且,大部分是重复的代码:在操作之前怎样怎样,
在操作之后,怎样怎样. 我们可以使用code block大幅减少代码
<div class="org-src-container">

<pre class="src src-ruby">class SomeApplication

  def do_something
    with_logging('load') {@doc = Document.load('resume.txt')}

    # Do something with the document
    with_logging('save') {@doc.save}
  end

  # Rest of the class omitted...

  def with_logging(description)
    begin
      @logger.debug('Staring #{description}')
      yield
      @logger.debug('Completed #{description}')
    rescue
      @logger.error('#{description} failed')
    end
  end
end
</pre>
</div>
</li>
<li>with_logging的代码非常通用,我们可以用来处理各种函数.其原理就是在某个操作的
"前后"进行log记录
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-18-3" class="outline-3">
<h3 id="sec-18-3">When It Absolutely Must Happen</h3>
<div class="outline-text-3" id="text-18-3">
<ul class="org-ul">
<li>其实code block非常自由,你也可以选择在"前"或者"后"记录log
<div class="org-src-container">

<pre class="src src-ruby">def log_before(description)
  @logger.debug('Starting #{description}')
end

def log_after(description)
  yield
  @logger.debug('Done #{description}')
end
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-18-4" class="outline-3">
<h3 id="sec-18-4">Setting Up Objects with an Initialization Block</h3>
<div class="outline-text-3" id="text-18-4">
<ul class="org-ul">
<li>你甚至可以使用code block来初始化initialize函数
<div class="org-src-container">

<pre class="src src-ruby">class Document
  attr_accessor :title, :author, :content

  def initialize(title, author, content= '')
    @title = title
    @author = author
    @content = content
    yield(self) if block_given?
  end
end

new_doc = Document.new('US Constitution', 'Madison', '') do |d|
  d.content &lt;&lt; 'We the people'
  d.content &lt;&lt; 'In order to form a more perfect union'
  d.content &lt;&lt; 'provide for the common defense'
end

puts new_doc.content

##################################################
# &lt;===================OUTPUT===================&gt; #
# We the peopleIn order to form a more perfect   #
# unionprovide for the common defense            #
##################################################
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-18-5" class="outline-3">
<h3 id="sec-18-5">Dragging Your Scope along with the Block</h3>
<div class="outline-text-3" id="text-18-5">
<ul class="org-ul">
<li>书写这种"around method"的关键,是要了解输入是什么,输出是什么
</li>
<li>同样的,在函数中产生对象,然后传入到code block中,也是正确的写法,比如我们要打
开一个数据库,然后把数据库"句柄"放入到code block中去
<div class="org-src-container">

<pre class="src src-ruby">def with_database_connection(connection_info)
  connection = Database.new(connection_info)
  begin
    yield(connection)
  ensure
    connection.close
  end
end
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-18-6" class="outline-3">
<h3 id="sec-18-6">Carrying the Answers Back</h3>
<div class="outline-text-3" id="text-18-6">
<ul class="org-ul">
<li>"有来就有往", 有时候我们也希望code block能够返回一些代码回来.我们前面讲过
yield函数的返回值就是code block的返回值. 但是"around method"后面可能会加入
一些代, 所以yield可能不是最后一句代码, 所以我们要手动设计一个变量,然后返回
<div class="org-src-container">

<pre class="src src-ruby">def do_something_silly
  with_logging('Compute miles in a light year') do
    186000 * 60 * 60 * 24 * 365
  end
end

def with_logging(description)
  begin
    @logger.debug('Starting #{description}')
    return_value = yield
    @logger.debug('Completed #{description}')
    return return_value
  rescue
    @logger.error('#{description} failed!')
  end
end
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-18-7" class="outline-3">
<h3 id="sec-18-7">Staying Out of Trouble</h3>
<div class="outline-text-3" id="text-18-7">
<ul class="org-ul">
<li>要把with_logging这种"around method"看做是像while或者if这种常用的高度,才能足
够的"抽象",取出"with_logging"这种名字,而不是"execute_between_logging_statement"
这种名字
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-18-8" class="outline-3">
<h3 id="sec-18-8">In the Wild</h3>
<div class="outline-text-3" id="text-18-8">
<ul class="org-ul">
<li>在ruby代码中有很多使用code block,来完成"around method"的例子
</li>
<li>打开数据库,然后把"句柄"给code block,然后自己负责释放的例子,其实在Ruby代码中,
<a href=":open就是这么实现的">:open就是这么实现的</a>.
<div class="org-src-container">

<pre class="src src-ruby"># No open file here

File.open('/etc/passwd') do |f|
  # File open here!
  # Begin cracking the passwords on Russ' computer...
end

# The password file is guaranteed to be closed here
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-19" class="outline-2">
<h2 id="sec-19">Chapter 19: Save Blocks to Execute Later</h2>
<div class="outline-text-2" id="text-19">
<ul class="org-ul">
<li>前面两章,我们讲了code block的两个作用:
<ul class="org-ul">
<li>做循环
</li>
<li>做around method
</li>
</ul>
</li>
<li>这一章讲如何把你的代码暂时保存,一会过来执行
</li>
</ul>
</div>
<div id="outline-container-sec-19-1" class="outline-3">
<h3 id="sec-19-1">Explicit Blocks</h3>
<div class="outline-text-3" id="text-19-1">
<ul class="org-ul">
<li>前面我们的函数体里面,是没有明确写出code block的: code block是作为一个implict
的参数传入的. 然后根据block_given?的值来判断是否提供,除了这种方法以外,我们还
可以使用"explicit"的把code block作为函数的一个参数
<div class="org-src-container">

<pre class="src src-ruby">def run_the_block(&amp;that_block)
  puts "About to run the block"
  that_block.call if that_block
  puts "Done running the block"
end
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-19-2" class="outline-3">
<h3 id="sec-19-2">The Call Back Problem</h3>
<div class="outline-text-3" id="text-19-2">
<ul class="org-ul">
<li>假设你现在碰到了一个问题,一个文本编辑器想要使用你的Document class. 它想在你
在"载入"和"保存"的时候,得到提醒.
</li>
<li>常规的做法是为这两个行为设计两个listener class
<div class="org-src-container">

<pre class="src src-ruby">class DocumentSaveListener
  def on_save(doc, path)
    puts " Hey, I've been saved!"
  end
end

class DocumentLoadListener
  def on_load(doc, path)
    puts " Hey, I've been loaded!"
  end
end
</pre>
</div>
</li>
<li>然后再Document里面注入这些listener
<div class="org-src-container">

<pre class="src src-ruby">class Document
  attr_accesor :load_listener
  attr_accesor :save_listener

  def load(path)
    @content = File.read(path)
    load_listener.on_load(self, path) if load_listener
  end

  def save(path)
    File.open(path, 'w') { |f| f.print(@content)}
    save_listener.on_save(self, path) if save_listener
  end
end
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-19-3" class="outline-3">
<h3 id="sec-19-3">Banking Blocks</h3>
<div class="outline-text-3" id="text-19-3">
<ul class="org-ul">
<li>不说传统的好坏吧,反正我们是为了引出Ruby是如何做listener的
<div class="org-src-container">

<pre class="src src-ruby">class Document
  def initialize(content)
    @content = content
  end

  def on_save(&amp;block)
    @save_listener = block
  end

  def on_load(&amp;block)
    @load_listener = block
  end

  def load(path)
    # @content = File.read(path)
    @load_listener.call if @load_listener
  end

  def save(path)
    # File.open(path, 'w') {|f| f.print(@content)}
    @save_listener.call if @save_listener
  end
end

my_doc = Document.new('Block Based Example')

my_doc.on_load do |doc|
  puts "Hey, I've been loaded! #{doc}"
end

my_doc.on_save do |doc|
  puts "Hey, I've been saved! #{doc}"
end

puts "----------------------&gt;"
my_doc.load(nil)
my_doc.save(nil)

##################################################
# &lt;===================OUTPUT===================&gt; #
# ----------------------&gt;                        #
# Hey, I've been loaded!                         #
# Hey, I've been saved!                          #
##################################################
</pre>
</div>
</li>
<li>初始化的时候就给了on_save函数的code block(也就是puts saved什么的), 但是不会
马上执行,一定要打调用Document#save或者Document#load的时候才会调用,所以叫做
bank么
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-19-4" class="outline-3">
<h3 id="sec-19-4">Saving Code Blocks for Lazy Initialization</h3>
<div class="outline-text-3" id="text-19-4">
<ul class="org-ul">
<li>假设我们有新的需求,再读取存档的文档的时候,我们倾向于只读取题目和作者,只有在
个别需要的时候才读取内容,所以我们立马有了如下的代码
<div class="org-src-container">

<pre class="src src-ruby">class ArchivalDocument
  attr_reader :title, :author

  def initialize(title, author, path)
    @title = title
    @author = author
    @path = path
  end

  def content
    @content ||= File.read(@path)
  end
end
</pre>
</div>
</li>
<li>第一个例子的肯定能做到lazy initialization,因为直到用到content的时候才会用path
去读取相应内容. 但是,这种方法有一定的局限性:你只能使用path来打开文件.如果文
件是以其他形式,比如HTTP或者FTP的方式来打开的话,那么就只能望洋兴叹了.幸好, code
block能够解决这个问题
<div class="org-src-container">

<pre class="src src-ruby">class BlockBasedArchivalDocument
  attr_reader :title, :author

  def initialize(title, author, &amp;block)
    @title = title
    @author = author
    @initializer_block = block
  end

  def content
    if @initializer_block
      @content = @initializer_block.call
      @initializer_block = nil
    end
    @content
  end
end

# You can use all kind of resource
file_doc = BlockBasedArchivalDocument.new('file', 'russ') do
  File.read('some_text.txt')
end

google_doc = BlockBasedArchivalDocument.new('http', 'russ') do
  Net::HTTP.get_response('www.google.com', '/index.html').body
end

boring_doc = BlockBasedArchivalDocument.new('sily', 'russ') do
  'Ya' * 100
end
</pre>
</div>
</li>
<li>上面的代码中,"有且只有"当你调用content函数的时候才会真正的调用类似File.read
这样的代码.否则这些代码都是不会调用的.真正的做到了lazy initialization
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-19-5" class="outline-3">
<h3 id="sec-19-5">Instant Block objects</h3>
<div class="outline-text-3" id="text-19-5">
<ul class="org-ul">
<li>code block其实只是Proc这个类的instance
</li>
<li>如果你像创造一个code block(Proc的instance), 但是却不像让某个method 和它有联
系(而是保留自己的名分,以后给自己喜欢的method使用).你可以使用lambda
</li>
<li>lambda函数的输入为code block,输出为Proc object
<div class="org-src-container">

<pre class="src src-ruby">class Document
  DEFAULT_LOAD_LISTENER = lambda do |doc, path|
    puts "Loaded: #{path}"
  end
end
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-19-6" class="outline-3">
<h3 id="sec-19-6">Staying Out of Trouble</h3>
<div class="outline-text-3" id="text-19-6">
<ul class="org-ul">
<li>还有一种最原始的创建的Proc objec他方法是Proc.new
<div class="org-src-container">

<pre class="src src-ruby">from_proc_new = Proc.new {puts "hello from a block"}
</pre>
</div>
</li>
<li>lambda的效果和Proc.new的效果是一样, 除了两个方面:
<ul class="org-ul">
<li>Proc.new object不会去检查其call 函数的参数个数. lambda创建的Proc object在
调用call的时候,会细心检查传入的参数个数
</li>
<li>Proc.new object 的code block里面如果有return的话, 代码会尝试从code block和
调用这个code block的函数"两个地方同时return". lambda创建的code block里面有
return的话,就只会从code block里面退出.
</li>
</ul>
</li>
<li>code block有一个不为人知的特性,它会把它创建的所在的local域里面的所有的local
variable都记着(都放在内存里面).所以下面的代码(使用了非常大的数组, 又在附近
创建code block),就会导致这些数组和code block会一直存在内存里面.非常浪费
<div class="org-src-container">

<pre class="src src-ruby">def some_method(doc)
  big_array = Array.new(100000000)

  # Do something with big_array

  doc.on_load do |d|
    puts "Hey, I've been loaded!"
  end
end
</pre>
</div>
</li>
<li>应对的办法很简单, 把big_array用完后,设置为nil
<div class="org-src-container">

<pre class="src src-ruby">def some_method(doc)
  big_array = Array.new(100000000)

  # Do something with big_array

  # And now get rid of it!
  big_array = nil

  doc.on_load do |d|
    puts "Hey, I've been loaded!"
  end
end
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-19-7" class="outline-3">
<h3 id="sec-19-7">In the Wild</h3>
<div class="outline-text-3" id="text-19-7">
<ul class="org-ul">
<li>#TODO#
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-20" class="outline-2">
<h2 id="sec-20">Chapter 20: Use Hooks to Keep Your Program Informed</h2>
<div class="outline-text-2" id="text-20">
<ul class="org-ul">
<li>对于ruby来说,元编程没有那么深奥,其展示给我们的表象就是使用less code来让你获
得计算结果
</li>
<li>如果你能更近一步呢,你甚至可以让你的ruby代码会在如下的n种情况下被通知:
<ul class="org-ul">
<li>新的class的诞生
</li>
<li>某个method被调用
</li>
<li>application要退出的时候.
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-20-1" class="outline-3">
<h3 id="sec-20-1">Waking Up to a New Subclass</h3>
<div class="outline-text-3" id="text-20-1">
<ul class="org-ul">
<li>所谓hook,在哪里都是一个意义:一个事情(要发生)或者已经发生了.那么一段代码(叫做
hook)就会被通知.
</li>
<li>下面是一个简单的例子, inherited函数会在当前class被继承的第一瞬间,调用puts语
句.
<div class="org-src-container">

<pre class="src src-ruby">class SimpleBaseClass
  def self.inherited(new_subclass)
    puts "Hey #{new_subclass} is now a subclass of #{self}"
  end
end

class ChildClassOne &lt; SimpleBaseClass
end

##########################################################
# &lt;===================OUTPUT===================&gt;         #
# Hey ChildClassOne is now a subclass of SimpleBaseClass #
##########################################################
</pre>
</div>
</li>
<li>d
<div class="org-src-container">

<pre class="src src-ruby">class YAMLReader &lt; DocumentReader
  def self.can_read?(path)
    /.*\.yaml/ =~ path
  end

  def initialize(path)
    @path = path
  end

  def read(path)
    # Lots of simple YAML stuff omitted
  end
end

class XMLReader &lt; DocumentReader
  def self.can_read?(path)
    /.*\.xml/ =~ path
  end

  def initialize(path)
    @path = path
  end

  def read(path)
    # Lots of simple XML stuff omitted
  end
end

class DocumentReader

  class &lt;&lt; self
    attr_reader :reader_classes
  end

  @reader_classes = []

  def self.read(path)
    reader = reader_for(path)
    return nil unless reader
    reader.read(path)
  end

  def self.reader_for(path)
    reader_class = DocumentReader.reader_classes.find do |klass|
      klass.can_read?(path)
    end
    return reader_class.new(path) if reader_class
    nil
  end

  def self.inherited(subclass)
    DocumentReader.reader_classes &lt;&lt; subclass
  end
  # One critical bit omitted, but stay tuned...
end

yam = YAMLReader.new('cc.yaml')
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

         <!-- Disqus Comment BEGIN -->
          <div id="disqus_thread"></div>
          <script type="text/javascript">
              var disqus_shortname = 'harrifeng';

              (function() {
                  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
              })();
          </script>
          <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

         <!-- Disqus Comment END -->
</div>
</body>
</html>
