<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Chapter 6</title>
<!-- 2014-02-22 Sat 15:37 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="your name" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>

         <link href="http://fonts.googleapis.com/css?family=Droid+Sans+Mono|Galdeano|Open+Sans:600italic,400,600|Roboto+Condensed:400,700" rel="stylesheet" type="text/css">
         <link rel="stylesheet" type="text/css" href="/static/css/main.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="http://harrifeng.github.io/sitemap.html"> UP </a>
 |
 <a accesskey="H" href="http://harrifeng.github.io/index.html"> HOME </a>
</div><div id="preamble" class="status">

         <div id="header">
            <div id="header-top">
                <div id="blog-title">Harrifeng's Path</div>
                <div id="blog-sub-title">纸上得来终觉浅,绝知此事要Coding</div>
            </div>
            <div id="nav">
                <ul>
                    <li><a href="/">首页</a></li>
                    <li><a href="/notes.html">读书笔记</a></li>
                    <li><a href="/about.html">About</a></li>
                    <li><a href="/atom.xml">RSS</a></li>
                    <li>
                    </li>
                </ul>
            </div>
         </div>
</div>
<div id="content">
<h1 class="title">Chapter 6</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">I/O Multiplexing: The select and poll Functions</a>
<ul>
<li><a href="#sec-1-1">Introduction</a></li>
<li><a href="#sec-1-2">I/O Models</a>
<ul>
<li><a href="#sec-1-2-1">Blocking I/O Model</a></li>
<li><a href="#sec-1-2-2">Nonblocking I/O Model</a></li>
<li><a href="#sec-1-2-3">I/O Multiplexing Model</a></li>
<li><a href="#sec-1-2-4">Signal-Driven I/O Model</a></li>
<li><a href="#sec-1-2-5">Asynchronous I/O Model</a></li>
<li><a href="#sec-1-2-6">Comparison of the I/O Models</a></li>
<li><a href="#sec-1-2-7">Synchronous I/O versus Asynchronous I/O</a></li>
</ul>
</li>
<li><a href="#sec-1-3">select Function</a>
<ul>
<li><a href="#sec-1-3-1">Under What Conditions Is a Descriptor Ready?</a></li>
<li><a href="#sec-1-3-2">Maximum Number of Descriptors for select</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">I/O Multiplexing: The select and poll Functions</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Introduction</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>前面TCP client是同时处理两个input: standard input和TCP socket, 这个体系有很
大的问题:
<ul class="org-ul">
<li>client会被block在fgets上面
</li>
<li>当server被kill的时候,会发送FIN到client,但是因为client一直在处理standard的
IO,所以一直等到有机会处理socket IO的时候,才发现,原来我已经被server抛弃了.
</li>
</ul>
</li>
<li>所以,我们希望能够有一种新的功能:
<pre class="example">
       我们能够在某个IO ready的情况下,被kernel通知(这样一来,我们就不必通过循环做busy waiting了).
</pre>
</li>
<li>这种功能已经存在了,名字叫做I/O multiplexing并且是通过select和poll函数实现的
</li>
<li>I/O multiplexing在网络中的应用场景有如下:
<ul class="org-ul">
<li>当一个client处理多个descriptor的情况,I/O multiplexing必须得应用(这也是前面
提到的场景)
</li>
<li>一个client同时处理多个sockets的情况(不是很常见)
</li>
<li>一个server同时吹离listenng socket和connected socket的情况
</li>
<li>一个server同时处理TCP和UDP的情况
</li>
<li>一个server处理多个服务,并且属于多个协议的情况.
</li>
</ul>
</li>
<li>I/O multiplexing不仅仅限于网络编程, 也在其他领域有作用
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">I/O Models</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>在我们解释select和poll之前,我们先总结一下Unix下面的五种I/O models:
<ul class="org-ul">
<li>blocking I/O
</li>
<li>nonblocking I/O
</li>
<li>I/O multiplexing (select and poll)
</li>
<li>signal driven I/O (SIGIO)
</li>
<li>asynchronous I/O(the POSIX aio_ functions)
</li>
</ul>
</li>
<li>通过前面的例子,我们也知道对于"输入"这个操作, 有两个不同的阶段:
<ol class="org-ol">
<li>等待数据的到来
</li>
<li>把数据从kernel拷贝到进程
</li>
</ol>
</li>
<li>对于socket来说,1)就是等待数据从网络上传来,然后数据拷贝到kernel的buffer 2)就
是把kernel buffer的数据传递到进程的buffer
</li>
</ul>
</div>
<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">Blocking I/O Model</h4>
<div class="outline-text-4" id="text-1-2-1">
<ul class="org-ul">
<li>最常见的IO模型是blocking I/O, 默认情况下所有的socket都是blocking的
<pre class="example">
                    application       system call          kernel
                /   recvfrom      ------------------&gt;   no datagram ready \
                |                                             |           |
                |                                             |           |
                |                                             |           |
                |                                             |           |&gt; wait for data
                |                                             |           |
                |                                             V           |
                |                                       datagram ready    /
                |
process blocks  |                                       copy datagram     \
   in call to  &lt;|                                             |           |
   recvfrom     |                                             |           |
                |                                             |           |
                |                                             |           |
                |                                             |           |
                |                                             |           |
                |                                             |           |&gt; copy data from
                |                                             |           |  kernel to user
                |                                             |           |
                |                                             |           |
                |                                             |           |
                |                                             V           |
                \                   return OK                             |
                   process      &lt;---------------------- copy complete     /
                   datagram
</pre>
</li>
<li>我们上面的例子使用的是UDP,因为UDP不涉及到拆分数据包,重组数据包.对于UDP来说,
数据的"ready"就是要么一个datagram全来了,要么都没来
</li>
<li>在整个调用system call recvfrom的时候,我们的process都是被block的,当我们从
recvfrom函数返回, 我们的application就会开始处理传来的datagram
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2">Nonblocking I/O Model</h4>
<div class="outline-text-4" id="text-1-2-2">
<ul class="org-ul">
<li>如果设置了socket为nonblocking,我们就有了如下的流程图,言简意赅的解释就是"如
果我要求的IO操作无法马上返回要被迫进入sleep状态的话,请不要sleep,直接返回给
我错误得了"
<pre class="example">
                    application       system call          kernel
                /   recvfrom      ---------------&gt;      no datagram ready \
                |                   EWOULDBLOCK               |           |
                |                 &lt;--------------             |           |
                |                                             |           |
                |   recvfrom      ---------------&gt;      no datagram ready |
                |                   EWOULDBLOCK               |           |
                |                 &lt;--------------             |           |
                |                                             |           |&gt; wait for data
process repeatly|   recvfrom      ---------------&gt;      no datagram ready |
calls recvfrom  |                   EWOULDBLOCK               |           |
waiting for    &lt;|                 &lt;--------------             |           |
an OK           |                                             |           |
                |   recvfrom      ---------------&gt;      datagram ready    /
                |
                |                                       copy datagram     \
                |                                             |           |
                |                                             |           |
                |                                             |           |
                |                                             |           |&gt; copy data from
                |                                             |           |  kernel to user
                |                                             |           |
                \                   return OK                             |
                   process      &lt;---------------------- copy complete     /
                   datagram
</pre>
</li>
<li>这种设置了nonblocking,然后在循环里面不停调用函数的做法叫做polling.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-2-3" class="outline-4">
<h4 id="sec-1-2-3">I/O Multiplexing Model</h4>
<div class="outline-text-4" id="text-1-2-3">
<ul class="org-ul">
<li>I/O Multiple Model其实就是利用select来探测数据,然后用recvfrom在确定数据已
经在的情况下,去调用.
<pre class="example">
                    application       system call          kernel
                   /   select        -----------------&gt;    no datagram ready \
process blocks     |                                             |           |
in call to select, |                                             |           |
waiting for one of |                                             |           |
possibly many     &lt;|                                             |           |&gt; wait for data
sockets to become  |                                             |           |
readable           |                    return readable          |           |
                   |                  &lt;----------------    datagram ready    /
                   |                     system call
                   \   recvfrom       ----------------&gt;    copy datagram     \
                   /                                             |           |
                   |                                             |           |
                   |                                             |           |
                   |                                             |           |
process blocks     |                                             |           |
while data copied  |                                             |           |
into application  &lt;|                                             |           |&gt; copy data from
buffer             |                                             |           |  kernel to user
                   |                                             |           |
                   |                                             |           |
                   |                                             |           |
                   |                                             |           |
                   \                   return OK                             |
                      process        &lt;-----------------    copy complete     /
                      datagram
</pre>
</li>
<li>看上去好像非但不比blocking模型有优势,反而多调用了一次select system call. 其
实不然,因为select函数可以同时等待不止一个descriptor
</li>
<li>所以，如果处理的连接数不是很高的话，使用select/epoll的web server不一定比使
用multi-threading + blocking IO的web server性能更好，可能延迟还更大。
select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-2-4" class="outline-4">
<h4 id="sec-1-2-4">Signal-Driven I/O Model</h4>
<div class="outline-text-4" id="text-1-2-4">
<ul class="org-ul">
<li>Unix系统还为IO设计了一个SIGIO的信号,我们可以通过设置这个信号的handler来达到类
似select的作用
<pre class="example">
                                       sigaction
                    application       system call             kernel
                   / establish SIGIO  ----------------&gt;                      \
                   | signal handler   &lt;----------------                      |
       process     |                  return                                 |
       continues  &lt;|                                                         |&gt; wait for data
      executing    |                    deliveer SIGIO                       |
                   |  signale handler &lt;----------------    datagram ready    /
                   |                     system call
                   \   recvfrom       ----------------&gt;    copy datagram     \
                   /                                             |           |
                   |                                             |           |
process blocks     |                                             |           |
while data copied &lt;|                                             |           |
into application   |                                             |           |
buffer             |                                             |           |
                   |                                             |           |&gt; copy data from
                   |                                             |           |  kernel to user                        .
                   |                                             |           |
                   |                                             |           |
                   |                                             |           |
                   |                                             V           |
                   \                   return OK                             |
                      process        &lt;-----------------    copy complete     /
                      datagram
</pre>
</li>

<li>这种处理方法已经有非常大的效率上面的优势了, 这是第一种能有半天空闲的调用方法:
在第一个阶段,我们通过sigaction之后,进程的main函数可以正常的运行不会block,
而只有在收到信号,知道肯定有数据ready,正式开始读取数据的适合才block
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-2-5" class="outline-4">
<h4 id="sec-1-2-5">Asynchronous I/O Model</h4>
<div class="outline-text-4" id="text-1-2-5">
<ul class="org-ul">
<li>Asynchronous IO是比SIGIO信号法效率更高的处理方式:在数据处理的整个过程中进程
的main函数都可以自由的运行, 没有block!
</li>
<li>我们通过aio_read把descriptor, buffer pointer,buffer size和通知成功的方法
传递给内核, 这个系统调用会马上返回的(不返回就是block了) 当我们要传的数据都已经
到我们制定的buffer里面了, 会有一个signal传递给我们的.
<pre class="example">
                 application       system call          kernel
             /   aio_read      ------------------&gt;   no datagram ready \
             |                 -------------------         |           |
             |                                             |           |
             |                                             |           |
             |                                             |           |&gt; wait for data
             |                                             |           |
             |                                             V           |
             |                                       datagram ready    /
             |                                    
process      |                                       copy datagram     \
continues   &lt;|                                             |           |
executing    |                                             |           |
             |                                             |           |
             |                                             |           |
             |                                             |           |
             |                                             |           |
             |                                             |           |&gt; copy data from
             |                                             |           |  kernel to user
             |                                             |           |
             |                                             |           |
             |                                             |           |
             |                                             V           |
             \                   deliver signal                        |
                process      &lt;---------------------- copy complete     /
                datagram      specified in aio_read
</pre>
</li>
<li>和上面signal-driven IO不同的是:
<ul class="org-ul">
<li>上面的signal-driven是说"等IO准备好可以开始拷贝了,再通知我, 我调用其他函
数来拷贝"
</li>
<li>而Asynchronous IO是说"等IO全部拷贝好了再通知我"
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-2-6" class="outline-4">
<h4 id="sec-1-2-6">Comparison of the I/O Models</h4>
<div class="outline-text-4" id="text-1-2-6">
<ul class="org-ul">
<li>下面是五种IO的对比,前四种的第二个phase都是一样的:block在recvfrom里面等待
着读取.Asynchronous IO最不同
<table border="2" cellspacing="0" cellpadding="6" rules="all" frame="border">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">blocking</th>
<th scope="col" class="left">nonblocking</th>
<th scope="col" class="left">I/O mulitplexing</th>
<th scope="col" class="left">signal-driven I/O</th>
<th scope="col" class="left">asynchronous I/O</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">initiate</td>
<td class="left">check</td>
<td class="left">check</td>
<td class="left">&#xa0;</td>
<td class="left">initiate</td>
</tr>

<tr>
<td class="left">V</td>
<td class="left">check</td>
<td class="left">V</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">V</td>
<td class="left">check</td>
<td class="left">V</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">V</td>
<td class="left">check</td>
<td class="left">ready</td>
<td class="left">notification</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">V</td>
<td class="left">V</td>
<td class="left">initiate</td>
<td class="left">initiate</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">V</td>
<td class="left">V</td>
<td class="left">V</td>
<td class="left">V</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">V</td>
<td class="left">V</td>
<td class="left">V</td>
<td class="left">V</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">complete</td>
<td class="left">complete</td>
<td class="left">complete</td>
<td class="left">complete</td>
<td class="left">notification</td>
</tr>
</tbody>
</table>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-2-7" class="outline-4">
<h4 id="sec-1-2-7">Synchronous I/O versus Asynchronous I/O</h4>
<div class="outline-text-4" id="text-1-2-7">
<ul class="org-ul">
<li>POSIX定义下面的两个术语:
<ul class="org-ul">
<li>synchronous I/O 操作沪会导致进程阻塞,知道IO操作完成
</li>
<li>asynchronous I/O 操作不会导致提出IO要求的进程的阻塞
</li>
</ul>
</li>
<li>通过定义发现,前四种(blocking, nonblocking, I/O multiplexing, signal-driven
IO)统统都是synchronous IO. 只有Asynchrous IO符合asynchronous IO的定义.
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">select Function</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>这个函数运行进程指导kernel,让其在某些特定条件下通知自己,比如:
<ul class="org-ul">
<li>集合{1,4,5}中有任何一个descriptor准备好读取了
</li>
<li>集合{2,7}里面有任何一个descriptor准备好写入了
</li>
<li>集合{1,4}里面有任何一个descriptor有了exception情况
</li>
<li>10.2秒已经过去了.
</li>
</ul>
</li>
<li>select的定义如下:
<div class="org-src-container">

<pre class="src src-c"><span style="color: #d08770;">#include</span> <span style="color: #a3be8c;">&lt;sys/select.h&gt;</span>
<span style="color: #d08770;">#include</span> <span style="color: #a3be8c;">&lt;sys/time.h&gt;</span>

<span style="color: #c0c5ce;">/*************************************************/</span>
<span style="color: #c0c5ce;">/* </span><span style="color: #65737e;">Returns: positive count of ready descriptors, </span><span style="color: #c0c5ce;">*/</span>
<span style="color: #c0c5ce;">/* </span><span style="color: #65737e;">0 on timeout, -1 on error                     </span><span style="color: #c0c5ce;">*/</span>
<span style="color: #c0c5ce;">/*************************************************/</span>
<span style="color: #c0c5ce;">int</span> <span style="color: #8fa1b3;">select</span>(<span style="color: #c0c5ce;">int</span> <span style="color: #bf616a;">maxfdp1</span>, <span style="color: #c0c5ce;">fd_set</span>* <span style="color: #bf616a;">readset</span>, <span style="color: #c0c5ce;">fd_set</span>* <span style="color: #bf616a;">writeset</span>,
           <span style="color: #c0c5ce;">fd_set</span>* <span style="color: #bf616a;">exceptset</span>, <span style="color: #b48ead;">const</span> <span style="color: #b48ead;">struct</span> <span style="color: #c0c5ce;">timeval</span>* <span style="color: #bf616a;">timeout</span>);
</pre>
</div>
</li>
<li>其中timeval的结构如下:
<div class="org-src-container">

<pre class="src src-c"><span style="color: #b48ead;">struct</span> <span style="color: #c0c5ce;">timeval</span> {
    <span style="color: #c0c5ce;">long</span>   <span style="color: #bf616a;">tv_sec</span>;         <span style="color: #c0c5ce;">/* </span><span style="color: #65737e;">secondes </span><span style="color: #c0c5ce;">*/</span>
    <span style="color: #c0c5ce;">long</span>   <span style="color: #bf616a;">tv_usec</span>;        <span style="color: #c0c5ce;">/* </span><span style="color: #65737e;">microseconds </span><span style="color: #c0c5ce;">*/</span>
};
</pre>
</div>
</li>
<li>我们在时间设置上面有如下几种情况:
<ol class="org-ol">
<li>一直等待下去: 我们只希望等待我们指定的descriptor,不想设置超时,那么就把
timeout参数为NULL
</li>
<li>等待一个固定的时间:等待指定的descriptor,但是不能超过一定的时间.那么就把
timeout设置为具体数据
</li>
<li>根本就不等待.如果我们把timeout参数设置为0的话,那么就退化成了busy wait
的polling.
</li>
</ol>
</li>
<li>上面所述的1,2两种情况都会受到signal的影响而让select中断(errno为EINTR), 某些
系统还是可以重启select(设置SA_RESTART), 某些系统还是要while loop重启
</li>
<li>timeval的设置还会出现两种"不准"的情况:
<ul class="org-ul">
<li>有些系统支持的最小时间精度是10ms,应用到最小精度为ms的tv_usec可能会出现一
些错误
</li>
<li>有些系统不允许tv_sec设置为某些特别大的不合理的时间(比如1亿秒)
</li>
</ul>
</li>
<li>timeout的参数有一个const,也就是说,你无法通过返回值来判断,真实的系统完成时间
为多少(有可能在指定时间之前就完成返回了)
</li>
<li>中间三个参数readset, writeset和exceptset的类型都是fd_set*.其实fd_set*
就是int*(整形数组). 所有的descriptor号码都用整形数组的一个bit表述,比如,
descritpr为31,那么就是整形数组的第一个参数arr的最后一位bit,通过下面的
宏,我们可以让fd_set跨平台
<div class="org-src-container">

<pre class="src src-c"><span style="color: #c0c5ce;">void</span> <span style="color: #8fa1b3;">FD_ZERO</span>(<span style="color: #c0c5ce;">fd_set</span> *<span style="color: #bf616a;">fdset</span>);         <span style="color: #c0c5ce;">/* </span><span style="color: #65737e;">clear all bitst in fdset </span><span style="color: #c0c5ce;">*/</span>
<span style="color: #c0c5ce;">void</span> <span style="color: #8fa1b3;">FD_SET</span>(<span style="color: #c0c5ce;">int</span> <span style="color: #bf616a;">fd</span>, <span style="color: #c0c5ce;">fd_set</span> *<span style="color: #bf616a;">fdset</span>);  <span style="color: #c0c5ce;">/* </span><span style="color: #65737e;">turn on the bit for fd in fdset </span><span style="color: #c0c5ce;">*/</span>
<span style="color: #c0c5ce;">void</span> <span style="color: #8fa1b3;">FD_CLR</span>(<span style="color: #c0c5ce;">int</span> <span style="color: #bf616a;">fd</span>, <span style="color: #c0c5ce;">fd_set</span> *<span style="color: #bf616a;">fdset</span>);  <span style="color: #c0c5ce;">/* </span><span style="color: #65737e;">turn off the bit for fd in fdset </span><span style="color: #c0c5ce;">*/</span>
<span style="color: #c0c5ce;">int</span> <span style="color: #8fa1b3;">FD_ISSET</span>(<span style="color: #c0c5ce;">int</span> <span style="color: #bf616a;">fd</span>, <span style="color: #c0c5ce;">fd_set</span> *<span style="color: #bf616a;">fdset</span>); <span style="color: #c0c5ce;">/* </span><span style="color: #65737e;">is the bit for fd on in fdset? </span><span style="color: #c0c5ce;">*/</span>
</pre>
</div>
</li>
<li>对于exceptset参数来说,其只有下面两种选择(两个bit就够了)
<ol class="org-ol">
<li>out-of-band 数据在socket上出现
</li>
<li>控制信息出现在了pseudo-terminal上
</li>
</ol>
</li>
<li>如果我们把中间的三个fd_set*类型的数据设置为NULL的话,我们就得到了一个精度更
高的sleep(精度为ms). 实际上APUE上面就曾利用过select河poll来实现sleep_us
</li>
<li>maxfdp1参数的意思是前多少个descriptor被测试, 比如0,1,2,就是前"三"个descriptor
被测试(也就是最大的2+1,这也是maxfdp1中, 1的来历),设置"max file descriptor
加1"的目的是,我们能够减轻内核的负担. "我们保证只有前maxfdp1的会有问题",那么
就只需要检测[0,mafdp1)的数据啦.
</li>
<li>每个进程能够拥有的descriptor的数目是一定的,在&lt;sys/select.h&gt;里面我们定义了
一个极值FD_SETSIZE(通常是1024)
</li>
<li>如果我们把中间的三个fd_set*类型的数据都没有const,也就意味着select会改变他们
的值:
<ul class="org-ul">
<li>在调用select之前我们会把我们感兴趣的bit设置为1, 比如{1,3,4}有兴趣,就都设置
为1.那么输入就是01011
</li>
<li>select返回的时候,所有数据准备好的域都是1, 没准备好的(或者我们开始就设置为0的)
就还是0.比如13准备好了,那么返回值就是01010
</li>
</ul>
</li>
<li>函数的返回值代表了此次select有多少的descriptor可以readay了(当然是在我们关注
的那些descriptor中去选择)
</li>
<li>返回值为-1,代表错误(比如返回-1,同时errno为EINTR,那么代表着函数被中断)
</li>
</ul>
</div>
<div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1">Under What Conditions Is a Descriptor Ready?</h4>
<div class="outline-text-4" id="text-1-3-1">
<ul class="org-ul">
<li>对于一个regular file来说,ready for "读"或者"写",都是很容易理解的.但是对于
socket来说(Unix下面一切皆文件,socket也被看做是一种文件),情况会复杂的多:
<ol class="org-ol">
<li>如果一个socket 满足下面任意一个condition就说它"准备好可读"了
<ul class="org-ul">
<li>socket receive buffer的值比low-water mark要大(这样read就不会block,
并且会返回一个大于0的数字), 一般来说SO_RCVLOWAT为这个low-water mark的
默认值(一般为1)
</li>
<li>TCP处于半关闭状态,而且是read半关闭(收到FIN),这个时候read不会block,并且
会返回0
</li>
<li>socket是listening socket,并且completed queue里面的数目大于0, accept
这个listening socket不会block(有种timing condition会block accept,
后面会讲到)
</li>
<li>会存在socket错误,存在错误的时候,read肯定会返回-1,也肯定不会block
</li>
</ul>
</li>
<li>如果一个socket 满足下面任意一个condition就说它"准备好可写"了
<ul class="org-ul">
<li>在socket send buffer里面的空间大于send buffer的low-water mark,并且要么
socket是connected, 要么socket不需要connection(UDP).send buffer的low-water
mark一般数值为SO_SNDLOWAT(一般为2048)
</li>
<li>TCP处于半关闭状态,而且是write半关闭(发送FIN),这个时候write会产生SIGPIPE
信号
</li>
<li>使用nonblocing的connect:要么成功完成了connection,要么connect失败
</li>
<li>会存在socket错误,存在错误的时候,write肯定会置errno为一个错误状态的.这些错误
我们是可以通过getsockopt来读取的.
</li>
</ul>
</li>
<li>如果一个socket有out-of-band的数据,那么肯定返回exception condition pending
</li>
</ol>
</li>
<li>我们可以看到如果socket上发生了错误,select会标记他"即可读又可写"
</li>
<li>如果我们的读写在某一个数值下是无意义的,比如小于64个数据读取无意义,我们可以设置low-water
mark 为64
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-3-2" class="outline-4">
<h4 id="sec-1-3-2">Maximum Number of Descriptors for select</h4>
<div class="outline-text-4" id="text-1-3-2">
<ul class="org-ul">
<li>我们前面说过,大部分的应用都只会使用一小部分的descriptor,所以FD_SETSIZE的定
义足够用了.但是如果select想要使用更大数目的descriptor,那么仅仅简单的重定义
头文件里面的FD_SETSIZE是不够的,还需要重新编译内核.
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

         <!-- Duoshuo Comment BEGIN -->
         <div class="ds-thread"></div>
         <script type="text/javascript">
             var duoshuoQuery = {short_name:"harrifeng"};
             (function() {
             var ds = document.createElement('script');
             ds.type = 'text/javascript';ds.async = true;
             ds.src = 'http://static.duoshuo.com/embed.js';
             ds.charset = 'UTF-8';
             (document.getElementsByTagName('head')[0]
             || document.getElementsByTagName('body')[0]).appendChild(ds);
             })();
         </script>
         <!-- Duoshuo Comment END -->
</div>
</body>
</html>
