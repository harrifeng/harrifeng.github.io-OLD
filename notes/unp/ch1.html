<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Chapter 1: Introduction</title>
<!-- 2014-03-23 Sun 18:38 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="your name" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>

         <link href="http://fonts.googleapis.com/css?family=Droid+Sans+Mono|Galdeano|Open+Sans:600italic,400,600|Roboto+Condensed:400,700" rel="stylesheet" type="text/css">
         <link rel="stylesheet" type="text/css" href="/static/css/main.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="http://harrifeng.github.io/sitemap.html"> UP </a>
 |
 <a accesskey="H" href="http://harrifeng.github.io/index.html"> HOME </a>
</div><div id="preamble" class="status">

         <div id="header">
            <div id="header-top">
                <div id="blog-title">Harrifeng's Path</div>
                <div id="blog-sub-title">纸上得来终觉浅,绝知此事要Coding</div>
            </div>
            <div id="nav">
                <ul>
                    <li><a href="/">首页</a></li>
                    <li><a href="/notes.html">读书笔记</a></li>
                    <li><a href="/algo.html">算法</a></li>
                    <li><a href="/about.html">About Me</a></li>
                    <li>
                    </li>
                </ul>
            </div>
         </div>
</div>
<div id="content">
<h1 class="title">Chapter 1: Introduction</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Introduction</a>
<ul>
<li><a href="#sec-1-1">Introduction</a></li>
<li><a href="#sec-1-2">A Simple Daytime Client</a></li>
<li><a href="#sec-1-3">Protocol Independence</a></li>
<li><a href="#sec-1-4">Error Handling: Wrapper Function</a></li>
<li><a href="#sec-1-5">A Simple Daytime Server</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Introduction</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Introduction</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>Web server是长期运行的程序, 而Web client(比如浏览器)就是发出请求的程序.
</li>
<li>一般来说,都是client端发送请求, 也有异步回调(asynchronous callback)通信,是
server端先发起的.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">A Simple Daytime Client</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>下面是一个简单的请求时间和日期的client
<div class="org-src-container">

<pre class="src src-c"><span style="color: #93a1a1;">/*************************/</span>
<span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">intro/daytimectpcli.c </span><span style="color: #93a1a1;">*/</span>
<span style="color: #93a1a1;">/*************************/</span>

include <span style="color: #2aa198;">"unp.h"</span>

<span style="color: #b58900;">int</span> main(<span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span>[])
{
    <span style="color: #b58900;">int</span>                 <span style="color: #268bd2;">sockfd</span>;
    <span style="color: #b58900;">int</span>                 <span style="color: #268bd2;">n</span>;
    <span style="color: #b58900;">char</span>                <span style="color: #268bd2;">recvline</span>[MAXLINE + 1];
    <span style="color: #859900; font-weight: bold;">struct</span> <span style="color: #b58900;">sockadr_in</span>   <span style="color: #268bd2;">servaddr</span>;

    <span style="color: #859900; font-weight: bold;">if</span> (argc != 2) {
        err_quit(<span style="color: #2aa198;">"usage: a.out &lt;IPaddress&gt;"</span>);
    }

    <span style="color: #859900; font-weight: bold;">if</span> ((sockfd = socket(AF_INET, SOCK_STREAM, 0)) &lt; 0) {
        err_sys(<span style="color: #2aa198;">"socket error"</span>);
    }

    bzero(&amp;servaddr, <span style="color: #859900; font-weight: bold;">sizeof</span>(servaddr));
    servaddr.sin_family = AF_INET;
    servaddr.sin_port = htons(13);    <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">daytime server port </span><span style="color: #93a1a1;">*/</span>
    <span style="color: #859900; font-weight: bold;">if</span> (inet_pton(AF_INET, argv[1], &amp;servaddr.sin_addr) &lt;= 0) {
        err_quit(<span style="color: #2aa198;">"inet_pton error for %s"</span>, argv[1]);
    }
    <span style="color: #93a1a1;">/**********************************************/</span>
    <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">in unp.h, #define SA to be struct sockaddr </span><span style="color: #93a1a1;">*/</span>
    <span style="color: #93a1a1;">/**********************************************/</span>
    <span style="color: #859900; font-weight: bold;">if</span> (connect(sockfd, (<span style="color: #b58900;">SA</span> *) &amp;servaddr, <span style="color: #859900; font-weight: bold;">sizeof</span>(servaddr)) &lt; 0) {
        err_sys(<span style="color: #2aa198;">"connect error"</span>);
    }

    <span style="color: #859900; font-weight: bold;">while</span> ((n = read(sockfd, recvline, MAXLINE)) &gt; 0) {
        recvline[n] = 0;
        <span style="color: #859900; font-weight: bold;">if</span> (fputs(recvline, stdout) == EOF) {
            err_sys(<span style="color: #2aa198;">"fputs error"</span>);
        }
    }
    <span style="color: #859900; font-weight: bold;">if</span> (n &lt; 0) {
        err_sys(<span style="color: #2aa198;">"read error"</span>);
    }
    <span style="color: #859900; font-weight: bold;">return</span> 0;
}
</pre>
</div>
</li>
<li>使用方法:
<div class="org-src-container">

<pre class="src src-sh">~/test/unpbook/intro$ ./daytimetcpcli 127.0.0.1
Wed Nov 20 14:33:08 2013
</pre>
</div>
</li>
<li>socket 函数创建一个socket, 其返回参数为sockfd, 其参数为AF_INET表示为IPv4, 
SOCK_STREAM表示为TCP socket
</li>
<li>后面我们就创建一个socket的数据结构(类型为struct sockadr_in), 我们使用bzero
这个函数把整个数据结构全部清零.
</li>
<li>servaddr(类型为struct sockadr_in)是整个函数的重点, 在用bzero清零以后,后面
是给他的每个部分赋值的过程 
<ol class="org-ol">
<li>sin_family
</li>
<li>sin_port
</li>
<li>使用inet_pton函数把一个AF_INET类型ip地址, 转换成合适的格式,然后赋值给sin_addr
</li>
</ol>
</li>
<li>connect函数通过第二个参数来知道要连接哪个地址(第三个长度起辅助作用),然后把server
返回的结果都返回给第一个参数
</li>
<li>通过read函数来读取connect带来的结果. daytime server的返回值都是26个bytes,
但是根据网络情况的不同,这些bytes可能通过不同数量的TCP segment返回., 所以我们得
用while来接收.然后把recvline最后一个赋值成0 (因为TCP里面的字符串不是c语言字符串,
没有以NULL结尾)
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Protocol Independence</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>我们上面的例子使用的是IPV4的IP地址, 如果使用IPV6的IP地址,那么就用sockaddr_in6
替换上面例子的sockaddr_in
</li>
<li>同时AF_INET ==&gt; AF_INET6
</li>
<li>sin_family ==&gt; sin6_port
</li>
<li>sin_port ==&gt; sin6_port
</li>
<li>sin_addr ==&gt; sin6_addr
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">Error Handling: Wrapper Function</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>老是测试返回值是不是0,太麻烦了,所以设计了wrapper function,特点是另外设计一些函数
首字母大写,里面测试返回值是不是0, 我们以socket函数为例.
<div class="org-src-container">

<pre class="src src-c">sockfd = socket(AF_INET, SOCK_STREAM, 0);
<span style="color: #b58900;">int</span> <span style="color: #268bd2;">Socket</span>(<span style="color: #b58900;">int</span> <span style="color: #268bd2;">family</span>, <span style="color: #b58900;">int</span> <span style="color: #268bd2;">type</span>, <span style="color: #b58900;">int</span> <span style="color: #268bd2;">protocol</span>) {
    <span style="color: #b58900;">int</span> <span style="color: #268bd2;">n</span>;
    <span style="color: #859900; font-weight: bold;">if</span> ((n = socket(family, type, protocol)) &lt; 0) {
        err_sys(<span style="color: #2aa198;">"socket error"</span>);
    }
    <span style="color: #859900; font-weight: bold;">return</span> (n);
}
</pre>
</div>
</li>
<li>在Unix函数里面如果出现了错误, 那么一个全局变量errno就会被设置成一个正数, 同时函数返回
负数-1. 我们的err_sys函数就是通过查看errno,并且打印error错误
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">A Simple Daytime Server</h3>
<div class="outline-text-3" id="text-1-5">
<ul class="org-ul">
<li>我们再来看看server端如何写:
<div class="org-src-container">

<pre class="src src-c"><span style="color: #93a1a1;">/**************************/</span>
<span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">intro/daytimetcpsrv.c  </span><span style="color: #93a1a1;">*/</span>
<span style="color: #93a1a1;">/**************************/</span>
<span style="color: #268bd2; font-weight: bold;">#include</span> <span style="color: #2aa198;">"unp.h"</span>
<span style="color: #268bd2; font-weight: bold;">#include</span> <span style="color: #2aa198;">&lt;time.h&gt;</span>

<span style="color: #b58900;">int</span> <span style="color: #268bd2;">main</span>(<span style="color: #b58900;">int</span> <span style="color: #268bd2;">argc</span>, <span style="color: #b58900;">char</span> *<span style="color: #268bd2;">argv</span>[])
{
    <span style="color: #b58900;">int</span>       <span style="color: #268bd2;">listenfd</span>;
    <span style="color: #b58900;">int</span>       <span style="color: #268bd2;">connfd</span>;
    <span style="color: #b58900;">char</span>      <span style="color: #268bd2;">buff</span>[MAXLINE];
    <span style="color: #b58900;">time_t</span>    <span style="color: #268bd2;">ticks</span>;

    listenfd = Socket(AF_INET, SOCK_STREAM, 0);

    bzeros(&amp;servaddr, <span style="color: #859900; font-weight: bold;">sizeof</span>(servaddr));
    servaddr.sin_family = AF_INET;
    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);
    servaddr.sin_port = htons(13); <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">daytime server port </span><span style="color: #93a1a1;">*/</span>

    Bind(listenfd, (<span style="color: #b58900;">SA</span>*) &amp;servaddr, siezeof(servaddr));
    <span style="color: #93a1a1;">/**********************************************************/</span>
    <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">LISTENQ is from unp.h, it specifies the maximum number </span><span style="color: #93a1a1;">*/</span>
    <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">of client connections that kernel will queue for this  </span><span style="color: #93a1a1;">*/</span>
    <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">listening descriptor                                   </span><span style="color: #93a1a1;">*/</span>
    <span style="color: #93a1a1;">/**********************************************************/</span>
    Listen(listenfd, LISTENQ);

    <span style="color: #859900; font-weight: bold;">for</span> ( ; ;) {
        connfd = Accept(listenfd, (<span style="color: #b58900;">SA</span>*)<span style="color: #268bd2; font-weight: bold;">NULL</span>, <span style="color: #268bd2; font-weight: bold;">NULL</span>);

        ticks = time(<span style="color: #268bd2; font-weight: bold;">NULL</span>);
        snprintf(buff, <span style="color: #859900; font-weight: bold;">sizeof</span>(buff), <span style="color: #2aa198;">"%.24s\n\n"</span>, ctime(&amp;ticks));
        Write(connfd, buff, strlen(buff));
        Close(connfd);
    }
    <span style="color: #859900; font-weight: bold;">return</span> 0;
}
</pre>
</div>
</li>
<li>Socket函数首先建立一个socket
</li>
<li>bzeros初始化socket的数据结构servaddr, 然后给各部分赋值, 和client程序一样, 
sin_family和sin_port被赋了AF_INET和htons(13)
</li>
<li>而sin_addr.s_addr在client是仅仅赋值了目标server的值(通过a.out的第二个参数得到),
这里却赋值INADDR_ANY, 这是为了让server接受来自本机任意一个网卡的数据(因为一个host
可能有多个网卡)
</li>
<li>client的socket数据结构赋值完之后,就是connect,然后read, server的操作要多一点
</li>
<li>server端和client的connect相似的命令是bind: 都是把socket和socket数据结构联系
起来
</li>
<li>bind之后,就用listen函数,就把一个socket变成了listening socket
</li>
<li>TCP使用的是三次握手协议来建立连接, accept函数返回的时候,就是三次握手成功完成的时候,
accept函数的返回值是一个新的descriptor,叫做connected descriptor. server会同时
接受多个client的请求,server会给每个client一个connected descriptor
</li>
<li>时间经过字符串处理以后,通过Write发送给connfd
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

         <!-- Disqus Comment BEGIN -->
          <div id="disqus_thread"></div>
          <script type="text/javascript">
              var disqus_shortname = 'harrifeng'; 
          
              (function() {
                  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
              })();
          </script>
          <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

         <!-- Disqus Comment END -->
</div>
</body>
</html>
