<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Chapter 3</title>
<!-- 2014-03-08 Sat 17:48 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="your name" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>

         <link href="http://fonts.googleapis.com/css?family=Droid+Sans+Mono|Galdeano|Open+Sans:600italic,400,600|Roboto+Condensed:400,700" rel="stylesheet" type="text/css">
         <link rel="stylesheet" type="text/css" href="/static/css/main.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="http://harrifeng.github.io/sitemap.html"> UP </a>
 |
 <a accesskey="H" href="http://harrifeng.github.io/index.html"> HOME </a>
</div><div id="preamble" class="status">

         <div id="header">
            <div id="header-top">
                <div id="blog-title">Harrifeng's Path</div>
                <div id="blog-sub-title">纸上得来终觉浅,绝知此事要Coding</div>
            </div>
            <div id="nav">
                <ul>
                    <li><a href="/">首页</a></li>
                    <li><a href="/notes.html">读书笔记</a></li>
                    <li><a href="/about.html">About</a></li>
                    <li><a href="/atom.xml">RSS</a></li>
                    <li>
                    </li>
                </ul>
            </div>
         </div>
</div>
<div id="content">
<h1 class="title">Chapter 3</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Sharing Objects</a>
<ul>
<li><a href="#sec-1-1">Visibility</a>
<ul>
<li><a href="#sec-1-1-1">Stale Date</a></li>
<li><a href="#sec-1-1-2">Non-atomic 64-bit Operations</a></li>
<li><a href="#sec-1-1-3">Locking and Visiility</a></li>
<li><a href="#sec-1-1-4">Volatile Variables</a></li>
</ul>
</li>
<li><a href="#sec-1-2">Publication and Escape</a>
<ul>
<li><a href="#sec-1-2-1">Safte Construction Practices</a></li>
</ul>
</li>
<li><a href="#sec-1-3">Thread Confinement</a>
<ul>
<li><a href="#sec-1-3-1">Ad-hoc Thread Confinement</a></li>
<li><a href="#sec-1-3-2">Stack Confinement</a></li>
<li><a href="#sec-1-3-3">ThreadLocal</a></li>
</ul>
</li>
<li><a href="#sec-1-4">Immutability</a>
<ul>
<li><a href="#sec-1-4-1">Final Fields</a></li>
<li><a href="#sec-1-4-2">Example: Using Volatile to Publish Immutable Objects</a></li>
</ul>
</li>
<li><a href="#sec-1-5">Safe Publication</a>
<ul>
<li><a href="#sec-1-5-1">Improper Publication: When Good Objects Go Bad</a></li>
<li><a href="#sec-1-5-2">Immutable Objects and Initialization Safety</a></li>
<li><a href="#sec-1-5-3">Safe Publication Idioms</a></li>
<li><a href="#sec-1-5-4">Effectively Immutable Objects</a></li>
<li><a href="#sec-1-5-5">Mutable Objects</a></li>
<li><a href="#sec-1-5-6">Sharing Objects Safety</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Sharing Objects</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>第二章我们讲到过了,并发编程的关键,是管理对共享,可变数据的访问.
</li>
<li>所以第二章主要讲的是,如何利用同步来防止多个线程在同一时间访问同一个数据. 这
一章讲的则是,通过"其他技巧"让对象能够共享,而且被多个线程同时访问,当然是线程
安全的访问
</li>
<li>第二章的介绍,很容易让人误以为同步"只能":
<ol class="org-ol">
<li>让操作原子化
</li>
<li>创建critical section
</li>
</ol>
</li>
<li>其实同步还有其他的不易察觉却非常重要的作用:内存的可见性(memory visibility):
我们不仅仅想阻止线程A在线程B使用数据X的时候得到这个数据, 我们还想让A可以在B
使用更改X的时候,能够"看到"数据X的最新值
</li>
</ul>
</div>
<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Visibility</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>下面这个例子,有两个线程,main线程和reader线程, main线程首先启动reader线程, 
然后设置ready为true, 并给予number一个非零值.reader线程不停的check readay
的状态是否为true,如果是的情况下,就打印number的值
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">NoVisibility</span> {
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #b58900;">boolean</span> <span style="color: #268bd2;">ready</span>;
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">number</span>;

    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">ReaerThread</span> <span style="color: #859900; font-weight: bold;">extends</span> <span style="color: #b58900;">Thread</span> {
        <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">run</span>() {
            <span style="color: #859900; font-weight: bold;">while</span> (<span style="color: #b58900; font-weight: bold;">!</span>ready) {
                Thread.yield();
            }
            System.out.println(number);
        }
    }

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">main</span>(<span style="color: #b58900;">String</span>[] <span style="color: #268bd2;">args</span>) {
        <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">ReaerThread</span>().start();
        number = 42;
        ready = <span style="color: #268bd2; font-weight: bold;">true</span>;
    }
}
</pre>
</div>
</li>

<li>虽然上面的例子在大多数情况下都能成功打印42, 但是还是存在着下面两种可能的错误:
<ol class="org-ol">
<li>死循环:因为读不到ready变成true
</li>
<li>打印0:因为读不到number变成42
</li>
</ol>
</li>
<li>造成上面两种错误的原因是:在没有同步的情况下, JVM有权利把所有的指令按照自己
的想法重新安排顺序(通常是为了缓存,效率等原因)
</li>
<li>如果想避免上述情况的发生,说起来也是很简单的:如果一个数据会在多个线程间共享,
那么就一定要使用合适的同步机制
</li>
</ul>
</div>
<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">Stale Date</h4>
<div class="outline-text-4" id="text-1-1-1">
<ul class="org-ul">
<li>上面错误发生的原因根本上在于,如果不使用同步机制, 某个线程很多时候会发现"失效"
的数据, 更坏的是,"失效"数据很可能是部分发作的,比如上面的例子, 有两个变量,可能
有时候是一个失效,或另一个失效,或者都失效
</li>
<li>失效的数据,会造成巨大的危害.下面的例子MutableInteger不是线程安全的,线程A正在
getter的时候,线程B可能在setter.
<div class="org-src-container">

<pre class="src src-java"><span style="color: #268bd2; font-weight: bold;">@NotThreadSafe</span>
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">MutableInteger</span> {
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">value</span>;

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">get</span>() {
        <span style="color: #859900; font-weight: bold;">return</span> value;
    }
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">set</span>(<span style="color: #b58900;">int</span> <span style="color: #268bd2;">value</span>) {
        <span style="color: #859900; font-weight: bold;">this</span>.value = value;
    }
}
</pre>
</div>
</li>
<li>更改的方法,就是给两个函数都加上同步机制:仅仅给予setter同步是不够的,因为某个线程
还是可以在getter的时候,得到"失效"的数据
<div class="org-src-container">

<pre class="src src-java"><span style="color: #268bd2; font-weight: bold;">@ThreadSafe</span>
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">SynchronizedInteger</span> {
    <span style="color: #268bd2; font-weight: bold;">@GuardeBy</span>(<span style="color: #2aa198;">"this"</span>) <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">value</span>;

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">synchronized</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">get</span>() {
        <span style="color: #859900; font-weight: bold;">return</span> value;
    }
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">synchronized</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">set</span>(<span style="color: #b58900;">int</span> <span style="color: #268bd2;">value</span>) {
        <span style="color: #859900; font-weight: bold;">this</span>.value = value;
    }
}
</pre>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">Non-atomic 64-bit Operations</h4>
<div class="outline-text-4" id="text-1-1-2">
<ul class="org-ul">
<li>如果没有使用同步机制,线程可能会读取到"失效"的变量,但至少这个变量还是其他线
程更改的,还不是很离谱.有些时候,会遇到更离谱的情况:读取的值直接就是一个随机
值
</li>
<li>这种随机值的情况,主要发生在64位的变量(long 和double)上面,JVM读取和存储32
位的数字是原子的,但是读取和存储64位的数字是分两次读取的(64位java应该就没有
这个问题).所以如果读写64位在两个不同的线程里面,会出现前32位和后32位的数字
来自不同64位数字的尴尬随机数.
</li>
<li>所以即便你不担心会读取到"失效"的变量,如果一旦有64位变量存在被多个线程读取的
情况(而且没有加锁,没有标记成volatile), 还是加个同步机制吧
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-1-3" class="outline-4">
<h4 id="sec-1-1-3">Locking and Visiility</h4>
<div class="outline-text-4" id="text-1-1-3">
<ul class="org-ul">
<li>内置锁可以用来保证一个线程可以"保证"看到另一个线程所做的操作, 比如下面的例
子, 如果没有同步机制, 线程B无法保证看到x的新值1, 因为它可能由于优化的原因
直接取用了x在缓存里面的值
<pre class="example">
    Thread A
+---------------+
|   y = 1       |
+---------------+

+---------------+
|   lock M      |
+---------------+

+---------------+
|   x = 1       |
+---------------+

+---------------+
|   unlock M    |                            Thread B
+---------------+ ---------------------&gt;  +---------------+
                                          |  lock M       |
                                          +---------------+

                                          +---------------+
                                          |  i = x        |
                                          +---------------+

                                          +---------------+
                                          |  unlock M     |
                                          +---------------+

                                          +---------------+
                                          |  j = y        |
                                          +---------------+
</pre>
</li>
<li>所以,"锁"并不是只是为了"互相排斥(mutual excusion)", 而且也为了能够让其他
线程看到"有效的"内存值
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-1-4" class="outline-4">
<h4 id="sec-1-1-4">Volatile Variables</h4>
<div class="outline-text-4" id="text-1-1-4">
<ul class="org-ul">
<li>Java还提供了一个简单,轻量级的synchronizated, 就是关键字volatile.编译器
看到volatile的时候,就知道这个变量是共享的, 所以:
<ol class="org-ol">
<li>编译器不会把对volatile变量的操作reorder
</li>
<li>编译器不会把volatile变量放入寄存器进行缓存
</li>
</ol>
</li>
<li>既然是轻量级的lock,那么volatile还有其局限性:
<ul class="org-ul">
<li>lock可以保证原子性和内存可见性
</li>
<li>轻量级lock, volatile变量只能保证内存可见性
</li>
</ul>
</li>
<li>volatile非常的脆弱,甚至无法保证++的原子性(count++), 最常见的volatile变量
的用法也就是flag:
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">volatile</span> <span style="color: #b58900;">boolean</span> <span style="color: #268bd2;">asleep</span>;

<span style="color: #859900; font-weight: bold;">while</span>(<span style="color: #b58900; font-weight: bold;">!</span>asleep) {
    countSomeSheep();
}
</pre>
</div>
</li>
<li>只有保证如下的三个条件,才能使用volatile变量:
<ol class="org-ol">
<li>对这个变量的写入操作,不涉及到它原来的值
</li>
<li>这个变量不涉及其他变量的"不变式"(invariants)
</li>
<li>没有任何理由要为访问此变量加锁
</li>
</ol>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Publication and Escape</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>发布(publish)一个对象的意思是,扩展某个对象的作用域,让它以前作用域以外的代码
能够看到它, 方法有一下:
<ol class="org-ol">
<li>存储一个指向对象的引用reference
</li>
<li>从一个非私有的函数里面返回某个对象
</li>
<li>把一个对象当作某个函数的参数
</li>
</ol>
</li>
<li>发布一个内部的state是对封装的妥协,会更加难以保证"不变式"
</li>
<li>发布一个还没有创建好的对象,是对线程安全的妥协
</li>
<li>如果一个对象还没准备好, 就被不小心的发布了,叫做逃逸(escaped)
</li>
<li>最明显的发布方式,就是存储一个对象的引用在public static的变量里面, 这样所有
的人都可以通过knownSecrets得到引用然后知道了Secret的所有内容
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #b58900;">Set</span>&lt;Secret&gt; knownSecrets;

<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">initialize</span>() {
    knownSecrets = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">HashSet</span>&lt;Secret&gt;();
}
</pre>
</div>
</li>
<li>通过从非private的函数里面返回值的方式,也容易publish不合适的内容, 比如下面这
个例子,通过返回的引用,我可以轻松的改动本来private的值
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">UnsafeStates</span> {
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">String</span>[] <span style="color: #268bd2;">getStates</span>() {
        <span style="color: #859900; font-weight: bold;">return</span> states;
    }

    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900;">String</span>[] <span style="color: #268bd2;">states</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">String</span>[] { <span style="color: #2aa198;">"AA"</span>, <span style="color: #2aa198;">"BB"</span>};

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">main</span>(<span style="color: #b58900;">String</span>[] <span style="color: #268bd2;">args</span>) {
        <span style="color: #b58900;">UnsafeStates</span> <span style="color: #268bd2;">us</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">UnsafeStates</span>();
        System.out.println(us.getStates()[0]);
        us.getStates()[0] = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">String</span>(<span style="color: #2aa198;">"ZZ"</span>);
        System.out.println(us.getStates()[0]);
    }

}
</pre>
</div>
</li>
<li>最后一种可能的发布内部state的方法,是返回一个inner class instance的时候,比如
下面虽然看似是publish了EventListener, 但是其实EventListener里面含有ref到
ThisEscape, 所以其实也同时publish了ThisEscape
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">ThisEscape</span> {
    <span style="color: #859900; font-weight: bold;">public</span> ThisEscape(<span style="color: #b58900;">EventSource</span> <span style="color: #268bd2;">source</span>) {
        source.registerListener(<span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">EventListener</span>() {
            <span style="color: #268bd2; font-weight: bold;">@Override</span>
            <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">onEvent</span>(<span style="color: #b58900;">Event</span> <span style="color: #268bd2;">e</span>) {
                doSomething(e);
            }
        });
    }

    <span style="color: #b58900;">void</span> <span style="color: #268bd2;">doSomething</span>(<span style="color: #b58900;">Event</span> <span style="color: #268bd2;">e</span>) {
    }

    <span style="color: #859900; font-weight: bold;">interface</span> <span style="color: #b58900;">EventSource</span> {
        <span style="color: #b58900;">void</span> <span style="color: #268bd2;">registerListener</span>(<span style="color: #b58900;">EventListener</span> <span style="color: #268bd2;">e</span>);
    }

    <span style="color: #859900; font-weight: bold;">interface</span> <span style="color: #b58900;">EventListener</span> {
        <span style="color: #b58900;">void</span> <span style="color: #268bd2;">onEvent</span>(<span style="color: #b58900;">Event</span> <span style="color: #268bd2;">e</span>);
    }

    <span style="color: #859900; font-weight: bold;">interface</span> <span style="color: #b58900;">Event</span> {
    }
}
</pre>
</div>
</li>
</ul>
</div>
<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">Safte Construction Practices</h4>
<div class="outline-text-4" id="text-1-2-1">
<ul class="org-ul">
<li>上面的例子告诉我们,在ctor里面publish 对象的结果,很可能是publish了一个没有构造
好的对象
</li>
<li>一个常见的在构造阶段escape this引用的做法就是在构造函数里面开启线程. 因为构造
函数里面this是和其他线程共享的, 所以:
<ul class="org-ul">
<li>this引用可以作为参数"显示"的传递给线程
</li>
<li>this引用也可以"隐性"的被调用,因为Thread是inner class
</li>
</ul>
</li>
<li>从ctor里面调用线程不是错误的关键,关键是不要那么着急. 从构造函数里面调用被重载的
函数(比如上面的调用public void onEvent)肯定即不是private,也不是final, 肯定会
this引用泄漏.
</li>
<li>如果实在想在构造函数里面注册一个event listenr或者开启一个线程,那么可以选择把构造
函数设计成private, 然后用public的工厂方法,如下:
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">SafeListener</span> {
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">EventListener</span> <span style="color: #268bd2;">listener</span>;

    <span style="color: #859900; font-weight: bold;">private</span> SafeListener() {
        listener = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">EventListener</span>() {
            <span style="color: #268bd2; font-weight: bold;">@Override</span>
            <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">onEvent</span>(<span style="color: #b58900;">Event</span> <span style="color: #268bd2;">e</span>) {
                doSomething();
            }
        };
    }

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #b58900;">SafeListener</span> <span style="color: #268bd2;">newInstance</span>(<span style="color: #b58900;">EventSource</span> <span style="color: #268bd2;">source</span>) {
        <span style="color: #b58900;">SafeListener</span> <span style="color: #268bd2;">safe</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">SafeListener</span>();
        source.registerListener(safe.listener);
        <span style="color: #859900; font-weight: bold;">return</span> safe;
    }

    <span style="color: #b58900;">void</span> <span style="color: #268bd2;">doSomething</span>() {
    }

    <span style="color: #859900; font-weight: bold;">interface</span> <span style="color: #b58900;">EventSource</span> {
        <span style="color: #b58900;">void</span> <span style="color: #268bd2;">registerListener</span>(<span style="color: #b58900;">EventListener</span> <span style="color: #268bd2;">e</span>);
    }

    <span style="color: #859900; font-weight: bold;">interface</span> <span style="color: #b58900;">EventListener</span> {
        <span style="color: #b58900;">void</span> <span style="color: #268bd2;">onEvent</span>(<span style="color: #b58900;">Event</span> <span style="color: #268bd2;">e</span>);
    }

    <span style="color: #859900; font-weight: bold;">interface</span> <span style="color: #b58900;">Event</span> {
    }
}
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Thread Confinement</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>前面说过, "共享且可变"的函数访问必须需要同步机制, 一个不需要同步的方法说来
简单,就是"不要共享", 如果一个变量只被一个线程访问,当然用不到同步机制.
</li>
<li>不共享数据的方法又较thread confinement,是最简单的线程安全的方法.
</li>
<li>一个常见的使用thread confinment来实现线程安全的例子是JDBC(Java Database
Connectivity): 在一个服务器端, 一个线程会从connection 池中请求一个connection
然后等用完了之后,再换回去,期间不会把这个connection共享给其他线程.所以,通过
不共享资源的方法, 实现了线程安全.
</li>
<li>不共享资源的方法不是从java语言的角度来保证的.(前面的JDBC的例子, JDBC的spec
没有要求一定要线程安全, 而线程不共享connection是由servlet 和EJB request的
结构造成的), 而是要求软件的设计来保证的(当然可以借助本地变量, ThreadLocal类)
</li>
</ul>
</div>
<div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1">Ad-hoc Thread Confinement</h4>
<div class="outline-text-4" id="text-1-3-1">
<ul class="org-ul">
<li>临时性的线程封闭(ad-hoc thread confinement)只是说如果你的代码保证是单线程了
才可以使用(比如GUI), 其实不是很鼓励使用
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-3-2" class="outline-4">
<h4 id="sec-1-3-2">Stack Confinement</h4>
<div class="outline-text-4" id="text-1-3-2">
<ul class="org-ul">
<li>stack confinement是thread confinement的一种, 其实就是用local variable来
代替全局或者作用域更大的变量.
</li>
<li>之所以叫stack,是因为local variable一般都是存放在stack上的, 而每个thread都有
自己的stack, 不和其他thread共享.
</li>
<li>stack confinement更易于实现,健壮性也强于ad-hoc thread confinement
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">import</span> <span style="color: #268bd2; font-weight: bold;">java</span>.<span style="color: #268bd2; font-weight: bold;">util</span>.*;

<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Animals</span> {
    <span style="color: #b58900;">Ark</span> <span style="color: #268bd2;">ark</span>;
    <span style="color: #b58900;">Species</span> <span style="color: #268bd2;">species</span>;
    <span style="color: #b58900;">Gender</span> <span style="color: #268bd2;">gender</span>;

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">loadTheArk</span>(Collection&lt;Animal&gt; candidates) {
        SortedSet&lt;Animal&gt; animals;
        <span style="color: #b58900;">int</span> <span style="color: #268bd2;">numPairs</span> = 0;
        <span style="color: #b58900;">Animal</span> <span style="color: #268bd2;">candidate</span> = <span style="color: #268bd2; font-weight: bold;">null</span>;

        <span style="color: #586e75;">//</span><span style="color: #586e75;">animals confined to method, don't let them escape!</span>
        animals = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">TreeSet</span>&lt;Animal&gt;(<span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">SpeciesGenderComparator</span>());
        animals.addAll(candidates);

        <span style="color: #859900; font-weight: bold;">for</span> (<span style="color: #b58900;">Animal</span> <span style="color: #268bd2;">a</span> : animals) {
            <span style="color: #859900; font-weight: bold;">if</span> (candidate == <span style="color: #268bd2; font-weight: bold;">null</span> || <span style="color: #b58900; font-weight: bold;">!</span>candidate.isPotentialMate(a))
                candidate = a;
            <span style="color: #859900; font-weight: bold;">else</span> {
                ark.load(<span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">AnimalPair</span>(candidate, a));
                ++numPairs;
                candidate = <span style="color: #268bd2; font-weight: bold;">null</span>;
            }
        }
        <span style="color: #859900; font-weight: bold;">return</span> numPairs;
    }
    <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Animal</span> {
        <span style="color: #b58900;">Species</span> <span style="color: #268bd2;">species</span>;
        <span style="color: #b58900;">Gender</span> <span style="color: #268bd2;">gender</span>;

        <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">boolean</span> <span style="color: #268bd2;">isPotentialMate</span>(<span style="color: #b58900;">Animal</span> <span style="color: #268bd2;">other</span>) {
            <span style="color: #859900; font-weight: bold;">return</span> species == other.species &amp;&amp; gender != other.gender;
        }
    }

    <span style="color: #859900; font-weight: bold;">enum</span> <span style="color: #b58900;">Species</span> {
        <span style="color: #268bd2;">AARDVARK</span>, <span style="color: #268bd2;">BENGAL_TIGER</span>, <span style="color: #268bd2;">CARIBOU</span>, <span style="color: #268bd2;">DINGO</span>, <span style="color: #268bd2;">ELEPHANT</span>, <span style="color: #268bd2;">FROG</span>, <span style="color: #268bd2;">GNU</span>, <span style="color: #268bd2;">HYENA</span>,
        <span style="color: #268bd2;">IGUANA</span>, <span style="color: #268bd2;">JAGUAR</span>, <span style="color: #268bd2;">KIWI</span>, <span style="color: #268bd2;">LEOPARD</span>, <span style="color: #268bd2;">MASTADON</span>, <span style="color: #268bd2;">NEWT</span>, <span style="color: #268bd2;">OCTOPUS</span>,
        <span style="color: #268bd2;">PIRANHA</span>, <span style="color: #268bd2;">QUETZAL</span>, <span style="color: #268bd2;">RHINOCEROS</span>, <span style="color: #268bd2;">SALAMANDER</span>, <span style="color: #268bd2;">THREE_TOED_SLOTH</span>,
        <span style="color: #268bd2;">UNICORN</span>, <span style="color: #268bd2;">VIPER</span>, <span style="color: #268bd2;">WEREWOLF</span>, <span style="color: #268bd2;">XANTHUS_HUMMINBIRD</span>, <span style="color: #268bd2;">YAK</span>, <span style="color: #268bd2;">ZEBRA</span>
    }

    <span style="color: #859900; font-weight: bold;">enum</span> <span style="color: #b58900;">Gender</span> {
        <span style="color: #268bd2;">MALE</span>, <span style="color: #268bd2;">FEMALE</span>
    }

    <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">AnimalPair</span> {
        <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">Animal</span> <span style="color: #268bd2;">one</span>, <span style="color: #268bd2;">two</span>;

        <span style="color: #859900; font-weight: bold;">public</span> AnimalPair(<span style="color: #b58900;">Animal</span> <span style="color: #268bd2;">one</span>, <span style="color: #b58900;">Animal</span> <span style="color: #268bd2;">two</span>) {
            <span style="color: #859900; font-weight: bold;">this</span>.one = one;
            <span style="color: #859900; font-weight: bold;">this</span>.two = two;
        }
    }

    <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">SpeciesGenderComparator</span> <span style="color: #859900; font-weight: bold;">implements</span> <span style="color: #b58900;">Comparator</span>&lt;Animal&gt; {
        <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">compare</span>(<span style="color: #b58900;">Animal</span> <span style="color: #268bd2;">one</span>, <span style="color: #b58900;">Animal</span> <span style="color: #268bd2;">two</span>) {
            <span style="color: #b58900;">int</span> <span style="color: #268bd2;">speciesCompare</span> = one.species.compareTo(two.species);
            <span style="color: #859900; font-weight: bold;">return</span> (speciesCompare != 0) ? speciesCompare : one.gender.compareTo(two.gender);
        }
    }

    <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Ark</span> {
        <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">Set</span>&lt;AnimalPair&gt; loadedAnimals = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">HashSet</span>&lt;AnimalPair&gt;();

        <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">load</span>(<span style="color: #b58900;">AnimalPair</span> <span style="color: #268bd2;">pair</span>) {
            loadedAnimals.add(<span style="color: #b58900;">pair</span>);
        }
    }
}
</pre>
</div>
</li>
<li>在线程内部使用线程不安全的对象(保证其local)也是可以保证整个线程安全的, 但是要
注意:
<ul class="org-ul">
<li>这个线程不安全对象只属于这个线程
</li>
<li>这个线程不安全这件事情要文档记录
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-3-3" class="outline-4">
<h4 id="sec-1-3-3">ThreadLocal</h4>
<div class="outline-text-4" id="text-1-3-3">
<ul class="org-ul">
<li>最正式的保护线程confinement的方法就是ThreadLocal
</li>
<li>其实ThreadLocal这个东西叫做ThreadLocalVariable 更合适, 其实现机制就是为每一个
使用该变量的线程提供一个变量值的副本(通过new)
</li>
<li>ThreadLocal为每个线程创建了私有的变量, 这个其实就是"用空间换时间", 每个线程
都有自己的变量,就不会打架了.
</li>
<li>而同步机制,就是"用时间换空间":只有一份变量,大家排好队依次取用.
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">ConnectionDispenser</span> {
    <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #b58900;">String</span> <span style="color: #268bd2;">DB_URL</span> = <span style="color: #2aa198;">"jdbc:mysql://localhost/mydatabase"</span>;

    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900;">ThreadLocal</span>&lt;Connection&gt; connectionHolder
        = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">ThreadLocal</span>&lt;Connection&gt;() {
        <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">Connection</span> <span style="color: #268bd2;">initialValue</span>() {
            <span style="color: #859900; font-weight: bold;">try</span> {
                <span style="color: #859900; font-weight: bold;">return</span> DriverManager.getConnection(DB_URL);
            } <span style="color: #859900; font-weight: bold;">catch</span> (<span style="color: #b58900;">SQLException</span> <span style="color: #268bd2;">e</span>) {
                <span style="color: #859900; font-weight: bold;">throw</span> <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">RuntimeException</span>(<span style="color: #2aa198;">"Unable to acquire Connection, e"</span>);
            }
        }
    };

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">Connection</span> <span style="color: #268bd2;">getConnection</span>() {
        <span style="color: #859900; font-weight: bold;">return</span> connectionHolder.get();
    }
}
</pre>
</div>
</li>
<li>ThreadLocal最开始的初衷就是建立thread confinement的,为每个线程创建一份自己
的数据,所以不要在其他方面滥用
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">Immutability</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>同步的对象是"共享的变量", 我们打完"共享"的主意,现在是打"变量"主意的时候了,
把"变量"变成"常量"是一个更简单的注意:常量天生就线程安全
</li>
<li>当然我们这里的常量是immutable objects: 就是在构造之后就无法改变的对象
</li>
<li>immutable对象不是所有的域都是final, 那远不够, 要达到下面的条件
<ul class="org-ul">
<li>对象的state在构造以后无法改变
</li>
<li>对象所有的域都是final的
</li>
<li>对象构造的过程是没有差错的(不会导致引用逃逸 reference escape)
</li>
</ul>
</li>
<li>Immutable对象的内部还是可以使用mutable,只是要好好设计.比如下面这个例子, Set
是可以改变的,但是下面的设计让构造之后,就只有final且private的stooges才可以
接触到这个Set
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">ThreeStooges</span> {
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">Set</span>&lt;String&gt; stooges = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">HashSet</span>&lt;String&gt;();

    <span style="color: #859900; font-weight: bold;">public</span> ThreeStooges() {
        stooges.add(<span style="color: #2aa198;">"Moe"</span>);
        stooges.add(<span style="color: #2aa198;">"Larry"</span>);
        stooges.add(<span style="color: #2aa198;">"Curly"</span>);
    }

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">boolean</span> <span style="color: #268bd2;">isStooge</span>(<span style="color: #b58900;">String</span> <span style="color: #268bd2;">name</span>) {
        <span style="color: #859900; font-weight: bold;">return</span> stooges.contains(name);
    }

}
</pre>
</div>
</li>
<li>即便是使用了immutable的对象,其实也是可以"改变"它的值的:使用一个新的对象
只不过值不同(allocation比你想象的要高效, immutable会带来更多的优势)
</li>
</ul>
</div>
<div id="outline-container-sec-1-4-1" class="outline-4">
<h4 id="sec-1-4-1">Final Fields</h4>
<div class="outline-text-4" id="text-1-4-1">
<ul class="org-ul">
<li>final变量无法改变(虽然他们指向的对象可能改变). 使用final能够保证:
<ul class="org-ul">
<li>初始化安全(initialization safety)
</li>
<li>不需要同步机制,保证线程安全
</li>
</ul>
</li>
<li>除非某个变量可能会改变,把所有的变量声明为final是一个good practice
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-4-2" class="outline-4">
<h4 id="sec-1-4-2">Example: Using Volatile to Publish Immutable Objects</h4>
<div class="outline-text-4" id="text-1-4-2">
<ul class="org-ul">
<li>下面这个例子就是创建了一个immutable holder class,来确保线程安全
</li>
<li>如果用mutable holder object,你必须使用lock. 下面的immutable object
一旦创建就无法更改. 如果想要更改变量,那么就要创建一个新的immutable 
object.
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">OneValueCache</span> {
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">BigInteger</span> <span style="color: #268bd2;">lastNumber</span>;
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">BigInteger</span>[] <span style="color: #268bd2;">lastFactors</span>;

    <span style="color: #859900; font-weight: bold;">public</span> OneValueCache(<span style="color: #b58900;">BigInteger</span> <span style="color: #268bd2;">i</span>, <span style="color: #b58900;">BigInteger</span>[] <span style="color: #268bd2;">factors</span>) {
        lastNumber = i;
        lastFactors = Arrays.copyOf(factors, factors.length);
    }

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">BigInteger</span>[] <span style="color: #268bd2;">getLastFactors</span>(<span style="color: #b58900;">BigInteger</span> <span style="color: #268bd2;">i</span>) {
        <span style="color: #859900; font-weight: bold;">if</span> (lastNumber == <span style="color: #268bd2; font-weight: bold;">null</span> || <span style="color: #b58900; font-weight: bold;">!</span>lastNumber.equals(i)) {
            <span style="color: #859900; font-weight: bold;">return</span> <span style="color: #268bd2; font-weight: bold;">null</span>;
        } <span style="color: #859900; font-weight: bold;">else</span> {
            <span style="color: #859900; font-weight: bold;">return</span> Arrays.copyOf(lastFactors, lastFactors.length);
        }
    }
}
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>







<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">Safe Publication</h3>
<div class="outline-text-3" id="text-1-5">
<ul class="org-ul">
<li>到现在为止,我们的策略主要是"堵":就是不让对象publish,当然就不会有问题
</li>
<li>但是有时候,我们的确要发布一个对象,这个时候就要注意很多问题, 下面的这种简单
的把一个指向对象的ref抛到public区域的做法无法保证publish的安全
<div class="org-src-container">

<pre class="src src-java"><span style="color: #586e75;">// </span><span style="color: #586e75;">Unsafe publication</span>
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">Holder</span> <span style="color: #268bd2;">holder</span>;

<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">initialize</span>() {
    holder = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Holder</span>(42);
}
</pre>
</div>
</li>
<li>这个例子主要的问题是可能会展示给其他线程一个"不完全构造"的对象
</li>
</ul>
</div>
<div id="outline-container-sec-1-5-1" class="outline-4">
<h4 id="sec-1-5-1">Improper Publication: When Good Objects Go Bad</h4>
<div class="outline-text-4" id="text-1-5-1">
<ul class="org-ul">
<li>看下面的例子, 由于没有进行必要的"同步", 一个线程可能开始看到一个值是"过时的",
但是紧接着,它有看到了正确的值,这种情况下,会让下面的assertSanity函数抛出
AssertionError
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Holder</span> {
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">n</span>;
    <span style="color: #859900; font-weight: bold;">public</span> Holder(<span style="color: #b58900;">int</span> <span style="color: #268bd2;">n</span>) {
        <span style="color: #859900; font-weight: bold;">this</span>.n = n;
    }
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">assertSanity</span>() {
        <span style="color: #859900; font-weight: bold;">if</span> (n != n) {
            <span style="color: #859900; font-weight: bold;">throw</span> <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">AssertionError</span>(<span style="color: #2aa198;">"This is statement is false"</span>);
        }
    }
}
</pre>
</div>
</li>
<li>不光是我们刚才描述的那些情况,一旦数据在多个线程间共享,而且没有正确的进行同
步,那么很多更加奇怪的事情会发生.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-5-2" class="outline-4">
<h4 id="sec-1-5-2">Immutable Objects and Initialization Safety</h4>
<div class="outline-text-4" id="text-1-5-2">
<ul class="org-ul">
<li>因为immutable对象如此重要, java虚拟机专门提供了一个保证:"共享的不变量的
初始化是安全的"
</li>
<li>java虚拟机提供的这一保证特别重要, 它让线程间共享数据有了一个捷径(不使用同
步手段的捷径),那就是使用不变对象(不变对象的条件:无法更改的state, 所有域都
是final的, prper的创建过程).
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-5-3" class="outline-4">
<h4 id="sec-1-5-3">Safe Publication Idioms</h4>
<div class="outline-text-4" id="text-1-5-3">
<ul class="org-ul">
<li>如果我们不能使用不变对象,那么就要采用"同步"的手段来保证publish的正确,而且:
<ul class="org-ul">
<li>不仅仅要同"步发布(publish)对象"的线程
</li>
<li>还要同步"消费这些发布的对象"的线程
</li>
</ul>
</li>
<li>我们首先讨论的是,如何"消费这些发布的对象"看到"发布的对象":
<ul class="org-ul">
<li>最常见的办法:用static initializer来初始化object reference, JVM会在
class初始化的时候,就初始化static initializer, 借助于JVM内部的同步机制,
这种初始化的方法可以保证安全的发布(publish)对象
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">static</span> <span style="color: #b58900;">Holder</span> <span style="color: #268bd2;">holder</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Holder</span>(42);
</pre>
</div>
</li>
<li>把object reference存储到一个volatile或者AutomicReference里面
</li>
<li>把object reference存储到一个properly constructed对象的final域里面
</li>
<li>把object reference存储到一个被lock很好保护的域里面(比如collection), 
这一条举例就是线程A把对象X放入到线程安全的vector里面(或者其他collection), 
线程B紧接着从这个vector里面读取对象X,虽然没有任何的"同步"手段,但是我们能
保证线程B能够看到准确的X的state
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-5-4" class="outline-4">
<h4 id="sec-1-5-4">Effectively Immutable Objects</h4>
<div class="outline-text-4" id="text-1-5-4">
<ul class="org-ul">
<li>如果一个对象被某个线程"安全的publish"出来了以后,其他线程就可以看到它的值了.但是
还不一定能成功的取得这个值,因为要考虑到其他线程会修改这个对象,那么如果不使用"同步"
的话,取得的值是不值得信任
</li>
<li>我们这里首先假设能够保证这个值在安全publish以后,就不再改变了,那么其他线程再取用
这个线程的时候,就不需要其他的同步手段了. 这种不是严格医院上的"不变"(不是final修
饰的),而是程序业务逻辑上的"不变",导致publish后不需要"同步手段"的情景,我们叫做
effectively immutable.
</li>
<li>下面是一个effectively immutable的例子,用一个Map来存储上次登陆的用户,用户对象
放入到线程安全的Map中以后,就可以被其他线程看到了.如果我们再能保证这个数据不再改变,
那么就可以不使用任何其他的"同步"手段,而达到安全正确取用publish完的数据
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">Map</span>&lt;String, Date&gt; lastLogin =
    Collections.synchronizedMap(<span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">HashMap</span>&lt;String, Date&gt;());
</pre>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-5-5" class="outline-4">
<h4 id="sec-1-5-5">Mutable Objects</h4>
<div class="outline-text-4" id="text-1-5-5">
<ul class="org-ul">
<li>如果我们不能保证一个对象在"安全发布"之后保证不更改,那么"安全发布"仅仅能保证其他
线程能够看到这个"发布的state", 但是如果他们想使用,那么每次都要加上"同步"来保证
取值的正确性. 同步的手段主要是线程安全,或者是锁.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-5-6" class="outline-4">
<h4 id="sec-1-5-6">Sharing Objects Safety</h4>
<div class="outline-text-4" id="text-1-5-6">
<ul class="org-ul">
<li>无论合适,你要取得一个对象的reference的时候,你一定要知道你可以对它做什么(下面的问题
也是文档中需要积极记录的):
<ul class="org-ul">
<li>你需要获得锁,然后访问它么
</li>
<li>你可以更改它的值么,还是仅仅能读取它的值
</li>
</ul>
</li>
<li>在线程间共享对象的方法简单总结如下:
<ul class="org-ul">
<li>Thread-confined, 每个线程都自己的一份数据
</li>
<li>Shared read-only, 只读数据可以在没有锁的情况下被分享. immutable 是只读, 
effectively immutable也是只读
</li>
<li>Shared thread-safe, 线程安全的对象自己内部就能实现同步,可以不加"同步方法"
在线程间共享
</li>
<li>Guarded, guarded对象一定要通过特定的锁来访问. guarded对象要么是在其他线程
安全对象里面的对象,要么是被特定锁保护的对象.
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

         <!-- Duoshuo Comment BEGIN -->
         <div class="ds-thread"></div>
         <script type="text/javascript">
             var duoshuoQuery = {short_name:"harrifeng"};
             (function() {
             var ds = document.createElement('script');
             ds.type = 'text/javascript';ds.async = true;
             ds.src = 'http://static.duoshuo.com/embed.js';
             ds.charset = 'UTF-8';
             (document.getElementsByTagName('head')[0]
             || document.getElementsByTagName('body')[0]).appendChild(ds);
             })();
         </script>
         <!-- Duoshuo Comment END -->
</div>
</body>
</html>
