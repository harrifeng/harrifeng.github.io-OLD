<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Chapter 1</title>
<!-- 2014-03-18 Tue 08:19 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="your name" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>

         <link href="http://fonts.googleapis.com/css?family=Droid+Sans+Mono|Galdeano|Open+Sans:600italic,400,600|Roboto+Condensed:400,700" rel="stylesheet" type="text/css">
         <link rel="stylesheet" type="text/css" href="/static/css/main.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="http://harrifeng.github.io/sitemap.html"> UP </a>
 |
 <a accesskey="H" href="http://harrifeng.github.io/index.html"> HOME </a>
</div><div id="preamble" class="status">

         <div id="header">
            <div id="header-top">
                <div id="blog-title">Harrifeng's Path</div>
                <div id="blog-sub-title">纸上得来终觉浅,绝知此事要Coding</div>
            </div>
            <div id="nav">
                <ul>
                    <li><a href="/">首页</a></li>
                    <li><a href="/notes.html">读书笔记</a></li>
                    <li><a href="/algo.html">算法</a></li>
                    <li><a href="/about.html">About Me</a></li>
                    <li>
                    </li>
                </ul>
            </div>
         </div>
</div>
<div id="content">
<h1 class="title">Chapter 1</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Introduction</a>
<ul>
<li><a href="#sec-1-1">A (Very) Brief History of Concurrency</a></li>
<li><a href="#sec-1-2">Benefits of Threads</a>
<ul>
<li><a href="#sec-1-2-1">Exploiting Multiple Processors</a></li>
<li><a href="#sec-1-2-2">Simplicity of Modeling</a></li>
<li><a href="#sec-1-2-3">Simplified Handling of Asynchronous Events</a></li>
<li><a href="#sec-1-2-4">More Responsive User Interfaces</a></li>
</ul>
</li>
<li><a href="#sec-1-3">Risks of Threads</a>
<ul>
<li><a href="#sec-1-3-1">Safety Hazards</a></li>
<li><a href="#sec-1-3-2">Liveness Hazards</a></li>
<li><a href="#sec-1-3-3">Performance Hazards</a></li>
<li><a href="#sec-1-3-4">Threads are Everywhere</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Introduction</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>线程是JAVA无法回避的重要特性，它可以帮助我们把复杂的异步程序变成简单的几行代码
</li>
<li>另外，线程是最容易利用多核威力的方法,随着cpu核心数的增加, 提高并发效率就变的
尤为重要
</li>
</ul>
</div>
<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">A (Very) Brief History of Concurrency</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>在计算机的原始时代, 是没有操作系统的, 在计算机上一个程序从头跑到尾,而且能动
用计算机所有的资源.这种系统,不仅仅是写程序麻烦,而且每次只能运行一个程序,对于
计算机资源来说,是极大的浪费
</li>
<li>操作系统的引入,让两个以上的程序同时允许成为了可能:
<ul class="org-ul">
<li>程序都被操作系统设计成一个进程, 进程之间的资源是操作系统分配的, 相互之间是
独立的,相互隔离的
</li>
<li>如果两个进程之间想相互通信, 那么可以通过以下几种方式:
<ol class="org-ol">
<li>sockets
</li>
<li>signal handlers
</li>
<li>shared memory
</li>
<li>semaphores
</li>
<li>file
</li>
</ol>
</li>
</ul>
</li>
<li>操作系统设计成多个程序(运行起来才叫进程)可以同事允许的初衷有以下几点:
<ol class="org-ol">
<li>资源的利用: 程序可能会时常需要等待外部的输入输出, 在等待的时候,如果能够做
一些其他的事情,有助于资源更好的利用
</li>
<li>公平: 多个用户在同时使用一台机器的时候, 都有平等的使用资源的权利, 这种
平等的实现应该是通过时间片的等额分割,而不是说某个用户的一个程序执行完,然后
让另外一个用户执行其他程序
</li>
<li>方便:写多个程序,每个简单的功能,然后让多个程序合作,比起写一个"多功能"的
程序要方便的多
</li>
</ol>
</li>
<li>早期的共享时间的系统当中, 每个进程都是一个虚拟的"冯诺依曼计算机":
<ul class="org-ul">
<li>每个进程都有自己的内存空间, 包括数据和指令(代码)
</li>
<li>顺序执行当前的指令, 对于每一个指令来说,永远存在"下一条"指令, 指令的指定
要么是事先写好的,要么逻辑控制的
</li>
<li>通过操作系统指定的一系列的IO原语与外界进行联系
</li>
</ul>
</li>
<li>线性的编程模型是自然的而直观的, 因为人类活动就和它很像:每次只做一件事情,
大部分情况下,顺序执行,举个例子:
<ol class="org-ol">
<li>起床
</li>
<li>穿好衣服
</li>
<li>下楼
</li>
<li>打开茶叶盒,放入茶杯茶叶
</li>
<li>查看是否有足够的热水:
</li>
<li>if 有足够的热水, 开始泡茶
</li>
<li>else 没有足够热水, 开始烧水
</li>
</ol>
</li>
<li>上面7)是烧水,在烧水的空间,你可以选择烤面包,或者看报纸. 烤面包机和烧水壶这种
设备知道自己经常会被"异步使用",所以它们会发出声音来提示使用者
</li>
<li>找到"线性"工作和"异步"使用的平衡是一个高效人士的要务,这对程序来说也是一样的
</li>
<li>发明进程的几个原因(资源利用, 公平, 方便)也催生出了线程的发明.线程的特点有:
<ol class="org-ol">
<li>允许多个程序控制流在一个进程里面同时存在:
</li>
<li>这多个线程共享进程的资源:内存,文件描述符;但是这些线程拥有自己的程序计数器,
stack,和局部变量
</li>
<li>多个线程在同一时间可以被调度到不同的CPU,而达到共同运行的目的
</li>
</ol>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Benefits of Threads</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>如果运用的得当,线程可以减少开发和维护的费用,提高复杂系统的性能.
</li>
<li>线程是一种通过把"线性"模式转换成"异步"陌生,来提高效率的方法
</li>
<li>线程在GUI应用中开业大幅度的提高用户借口的响应率,在服务器开发中
可以提高资源的利用率和输出
</li>
</ul>
</div>
<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">Exploiting Multiple Processors</h4>
<div class="outline-text-4" id="text-1-2-1">
<ul class="org-ul">
<li>因为调度的最小单位是线程,所以如果一个程序只有一个线程,那么每次
它只能运行在一个核上. 如果这个CPU是双核的,那么它放弃了50%的计
算力,如果是100核,那就是99%&#x2026;
</li>
<li>即便是在单核的CPU上面,多线程也是可以提高效率的,比如一个程序是
单线程的,那么如果遇到了I/O,操作,那么唯一的线程就得busy waiting
了. 如果这个程序还有其他线程B,那么可以在线程A等待I/O的空隙里面,
被调度到,然后运转. (就好像,一边看着报纸,一边等待水开)
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2">Simplicity of Modeling</h4>
<div class="outline-text-4" id="text-1-2-2">
<ul class="org-ul">
<li>生活中我们有这样的体验, 如果专心做一件事情,比如修复12个bug,通常要比干很多
乱七八糟的事情(比如,同时修复bug,面试,给自己的下属打分)要来的复杂的多
</li>
<li>线程就是这样一种架构: 在程序内部,把不同的事情分开,每种事情写到一块,相互尽量
不打扰
</li>
<li>我们说到的这些好处,通常是各种框架帮我们完成的.框架一般要处理各种细节:相应要求,
创建线程,处理负载,等等. 而servlet用户完全不用关心这些东西
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-2-3" class="outline-4">
<h4 id="sec-1-2-3">Simplified Handling of Asynchronous Events</h4>
<div class="outline-text-4" id="text-1-2-3">
<ul class="org-ul">
<li>作为一个server端程序的话,如果只有一个线程,那么如果和外界connect成功了的话,如果
当前线程不结束,后续的其他connect也就被block住了,这显然是不对的.
</li>
<li>所以server端的一种做法是对每一个connection都设置一个线程
</li>
<li>但是由于历史原因, 操作系统对于每个进程能创建的最大线程是有限制的,顶多几百个. 这就
导致了在Unix系统上面select和poll等系统调用的产生(这些叫做non-blocking I/O,也就
说没有数据的时候,轮询所有的connection,但是所有connection只有一个线程)
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-2-4" class="outline-4">
<h4 id="sec-1-2-4">More Responsive User Interfaces</h4>
<div class="outline-text-4" id="text-1-2-4">
<ul class="org-ul">
<li>GUI应用曾经是单线程的(Emacs现在还是&#x2026;), 也就是说,你要么频繁的应付相应输入操
作,要么在间接的在"main event loop"里面执行代码. 如果"main event loop"里面
的代码执行时间过长,那么用户界面就会看起来"卡", 因为只有前面的代码返回以后,用户
的操作才能进行.
</li>
<li>现代的GUI框架,都使用了EDT(event dispatch thread),也就当用户按一个按钮的时候,
一个相应的thread会运行.
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Risks of Threads</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>java内置的对线程的支持是一把双刃剑,这提高了对程序员的要求, 一旦使用多线程,
就要明白什么是线程安全
</li>
</ul>
</div>
<div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1">Safety Hazards</h4>
<div class="outline-text-4" id="text-1-3-1">
<ul class="org-ul">
<li>下面这段代码就是线程不安全的
<div class="org-src-container">

<pre class="src src-java"><span style="color: #268bd2; font-weight: bold;">@NotThreadSafe</span>
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">UnsafeSequence</span> {
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">value</span>;

    <span style="color: #93a1a1;">/* </span><span style="color: #93a1a1;">Returns a unique value */</span>
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">getNext</span>() {
        <span style="color: #859900; font-weight: bold;">return</span> value++;
    }
}
</pre>
</div>
</li>
<li>代码线程不安全的原因,是存在下面一种调用过程(非常巧合是吧..对的,就是非常巧,
也就是说线程的错误不是每次都能重现的)让两个线程调用getNext函数,却得到了同
样的值(本来这个函数是希望返回值都是独一无二的)
<pre class="example">
       +--------+        +--------+        +--------+
A      | value  +-------&gt;| 9+1    +-------&gt;+ value  |
       |   9    |        | = 10   |        |  10    |
       +--------+        +--------+        +--------+


                +--------+        +--------+        +--------+ 
B      --------&gt;| value  +-------&gt;| 9+1    +-------&gt;+ value  | 
                |   9    |        | = 10   |        |  10    | 
                +--------+        +--------+        +--------+
</pre>
</li>
<li>因为所有的线程共享内存,而且同时运行, 他们就可能更改其他用户正在使用的数据,
这本来是一个巨大的方便之处,因为比起其他的进程间通信, 这种使用数据的方式明
显容易很多. 但是这样也会存在前面说到的你无法知道当前变量是否正被使用. 这个
时候,就要java提供的同步方法(synchronization mechanism)
<div class="org-src-container">

<pre class="src src-java"><span style="color: #268bd2; font-weight: bold;">@ThreadSafe</span>
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Sequence</span> {
    <span style="color: #268bd2; font-weight: bold;">@GuardedBy</span>(<span style="color: #2aa198;">"this"</span>) <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">nextValue</span>;

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">synchronized</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">getNext</span>() {
        <span style="color: #859900; font-weight: bold;">return</span> nextValue++;
    }
}
</pre>
</div>
</li>
<li>如果没有这些同步方法(synchronization mechanism), 编译器,硬件会被赋予相当
大的自由, 比如会缓存当前变量到寄存器(这个还好,全局可见), 或者缓存变量到某个
核(processor-local)的cache,这就麻烦了,因为如果线程不在这个核上运行的,根本
看不到这个cache. 这些操作原本是为了提高程序的运行效率,但是这些操心无法让多个
线程安全的共享数据
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-3-2" class="outline-4">
<h4 id="sec-1-3-2">Liveness Hazards</h4>
<div class="outline-text-4" id="text-1-3-2">
<ul class="org-ul">
<li>前面说的safety意味着"nothing bad ever happens", 而这里的liveness意味着"something
good eventually happens". 也就是说不关保证没错就行,还要保证我们要做的事情做到!
</li>
<li>一个常见不能达到liveness的非多线程例子,就是死循环. 到了多线程阶段,又引入了非常多的这种
例子:
<ul class="org-ul">
<li>deadlock
</li>
<li>starvation
</li>
<li>livelock
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-3-3" class="outline-4">
<h4 id="sec-1-3-3">Performance Hazards</h4>
<div class="outline-text-4" id="text-1-3-3">
<ul class="org-ul">
<li>前面说的liveness意味着"something good eventually happens", 这个eventually有时候
远远不够,因为我们想好事情快快来.也就是说我们要提高多线程程序的效率
</li>
<li>效率这个东西涉及到很多:
<ul class="org-ul">
<li>服务时间
</li>
<li>响应率
</li>
<li>输出
</li>
<li>资源消耗
</li>
<li>可扩展性
</li>
</ul>
</li>
<li>就像liveness一样,多线程程序的效率的难题不仅仅来自传统的问题,还来自于多线程
的引入带来的问题
</li>
<li>在理想的情况下,利用多核系统带来的都是净收益,但这明显不现实的.线程多的情况下, 
上下文切换更加频繁, 也意味着更多的资源消耗:
<ul class="org-ul">
<li>保存上下文
</li>
<li>CPU调度
</li>
<li>使用syn, 无法享受编译器优化, 无法享受缓存
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-3-4" class="outline-4">
<h4 id="sec-1-3-4">Threads are Everywhere</h4>
<div class="outline-text-4" id="text-1-3-4">
<ul class="org-ul">
<li>即便你没有显示创建过线程, 框架可能就为你创建过进程,而调用这些进程的代码必
须线程安全
</li>
<li>每一个Java程序都使用了线程
<ol class="org-ol">
<li>当JVM开始的时候,会创建houskeeping task 线程负责回收, 还有一个main
线程来运行main方法.
</li>
<li>AWT(Abstract Windows Tookit) 创建了一个线程来管理用户事件
</li>
<li>Timer创建了一个线程来管理被拒绝的任务
</li>
<li>Servlet创建了线程池,并且调用这些线程里面的方法
</li>
</ol>
</li>
<li>如果你是使用了前面的这些工具, 就需要了解线程安全, 因为框架会使用线程来调用
你的代码, 你的代码会访问到应用的状态.这就要求所有跟这些状态相关的代码线程
安全
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

         <!-- Duoshuo Comment BEGIN -->
         <div class="ds-thread"></div>
         <script type="text/javascript">
             var duoshuoQuery = {short_name:"harrifeng"};
             (function() {
             var ds = document.createElement('script');
             ds.type = 'text/javascript';ds.async = true;
             ds.src = 'http://static.duoshuo.com/embed.js';
             ds.charset = 'UTF-8';
             (document.getElementsByTagName('head')[0]
             || document.getElementsByTagName('body')[0]).appendChild(ds);
             })();
         </script>
         <!-- Duoshuo Comment END -->
</div>
</body>
</html>
