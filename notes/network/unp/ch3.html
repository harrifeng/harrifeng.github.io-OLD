<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Chapter 3: Sockets Introduction</title>
<!-- 2015-03-18 Wed 17:26 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="your name" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>

         <link href="http://fonts.googleapis.com/css?family=Droid+Sans+Mono|Galdeano|Open+Sans:600italic,400,600|Roboto+Condensed:400,700" rel="stylesheet" type="text/css">
         <link rel="stylesheet" type="text/css" href="/static/css/main.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="http://harrifeng.github.io/sitemap.html"> UP </a>
 |
 <a accesskey="H" href="http://harrifeng.github.io/index.html"> HOME </a>
</div><div id="preamble" class="status">

         <div id="header">
            <div id="header-top">
                <div id="blog-title">Harrifeng's Path</div>
                <div id="blog-sub-title">纸上得来终觉浅,绝知此事要Coding</div>
            </div>
            <div id="nav">
                <ul>
                    <li><a href="/">首页</a></li>
                    <li><a href="/about.html">About Me</a></li>
                    <li>
                    </li>
                </ul>
            </div>
         </div>
</div>
<div id="content">
<h1 class="title">Chapter 3: Sockets Introduction</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Sockets Introduction</a>
<ul>
<li><a href="#sec-1-1">Introduction</a></li>
<li><a href="#sec-1-2">Socket Address Structure</a>
<ul>
<li><a href="#sec-1-2-1">IPv4 Socket Address Structure</a></li>
<li><a href="#sec-1-2-2">Generic Socket Address Structure</a></li>
<li><a href="#sec-1-2-3">IPv6 Socket Address Structure</a></li>
<li><a href="#sec-1-2-4">New Generic Socket Address Structure</a></li>
<li><a href="#sec-1-2-5">Comparison of Socket Address Structures</a></li>
</ul>
</li>
<li><a href="#sec-1-3">Value-Result Arguments</a></li>
<li><a href="#sec-1-4">Byte Ordering Functions</a></li>
<li><a href="#sec-1-5">Byte Manipulation Functions</a></li>
<li><a href="#sec-1-6">inet_aton, inet_addr, and inet_ntoa Funtions</a></li>
<li><a href="#sec-1-7">inet_pton and inet_ntop Functions</a></li>
<li><a href="#sec-1-8">sock_ntop and Related Function</a></li>
<li><a href="#sec-1-9">readn, writen, and readline Functions</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Sockets Introduction</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Introduction</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>socket address structure是最基础的socket数据结构,通常有两个方向的传递:
<ul class="org-ul">
<li>从process到内核
</li>
<li>从内核到process
</li>
</ul>
</li>
<li>在网络上传递的数据必须是binary, text类型是网络地址转换成binary的形式,使用的
函数是下面两个:
<ul class="org-ul">
<li>inet_addr &amp; inet_ntoa (for IPv4)
</li>
<li>inet_pton &amp; inet_ntop (for IPv4 and IPv6)
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Socket Address Structure</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>不同的协议都有自己的socket结构体, 以sockaddr_开头,加上不同的字符串以区别协议
</li>
</ul>
</div>
<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">IPv4 Socket Address Structure</h4>
<div class="outline-text-4" id="text-1-2-1">
<ul class="org-ul">
<li>IPv4 socket address structure, 一般叫做"Internet socket address structure"
在&lt;netinet/in.h&gt;里面创建了一个叫做sockaddr_in的数据结构
<div class="org-src-container">

<pre class="src src-c"><span style="color: #AE5825;">struct</span> <span style="color: #C6B032; font-style: italic;">in_addr</span> {
    <span style="color: #C6B032; font-style: italic;">in_addr_t</span> <span style="color: #46657B;">s_addr</span>;           <span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">32-bit IPv4 address  </span><span style="color: #4C565D;">*/</span>
                                <span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">network byte ordered </span><span style="color: #4C565D;">*/</span>
};

<span style="color: #AE5825;">struct</span> <span style="color: #C6B032; font-style: italic;">sockaddr_in</span> {
    <span style="color: #C6B032; font-style: italic;">uint8_t</span>            <span style="color: #46657B;">sin_len</span>;            <span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">length of structure (16) </span><span style="color: #4C565D;">*/</span>
    <span style="color: #C6B032; font-style: italic;">sa_family_t</span>        <span style="color: #46657B;">sin_family</span>;         <span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">AF_INET </span><span style="color: #4C565D;">*/</span>
    <span style="color: #C6B032; font-style: italic;">in_port_t</span>          <span style="color: #46657B;">sin_port</span>;           <span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">16-bit TCP or UDP port number </span><span style="color: #4C565D;">*/</span>
                                           <span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">network byte ordered </span><span style="color: #4C565D;">*/</span>
    <span style="color: #AE5825;">struct</span> <span style="color: #C6B032; font-style: italic;">in_addr</span>     <span style="color: #46657B;">sin_addr</span>;           <span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">32-bit IPv4 address </span><span style="color: #4C565D;">*/</span>
                                           <span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">network byte ordered </span><span style="color: #4C565D;">*/</span>
    <span style="color: #C6B032; font-style: italic;">char</span>               <span style="color: #46657B;">sin_zero</span>[8];        <span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">unused </span><span style="color: #4C565D;">*/</span>
};
</pre>
</div>
</li>
<li>这个例子中有如下需要了解的:
<ul class="org-ul">
<li>sin_len是后加上去的,之前最开始的成员变量是sin_family (unsigned short). 因
为来的晚,所以不是所有的实现都支持它
</li>
<li>uint8_t是Unsigned 8-bit integer
</li>
<li>len虽然列在这里,但是我们用来不去设置或者使用它(唯一的例外是我们处理routing
socket 的时候)
</li>
<li>有四个函数把socket address structure从进程拷贝到kernerl,他们是bind, connect,
sendto, sendmsg. 他们四个都是通过sockargs函数, 而sockargs函数,则会设置sin_len.
不幸的是,sockargs是Berkeley的实现方法,其他实现有没有设置这个sin_len就无法判断了,
但是IPv6确是明确要求设置SIN6_LEN这个域的
</li>
<li>POSIX规范只要求了sin_family, sin_port和sin_addr,但是所有的实现都加上了sin_zero
        这样所有的socket address structure都至少有16 bytes
</li>
<li>TCP UDP的 port number和IP地址都必须是用网络比特顺序存储的(network byte order)
</li>
<li>因为我们的IP地址在这里是使用了in_addr这个结构体,所以一个IP地址的表示就有
两种方式, 如下(serv表示一个sockaddr_in类型数据):
<ol class="org-ol">
<li>serv.sin_addr.s_addr 是 in_addr_t类型的IP地址(通常就是unsigned 32-bit integer)
</li>
<li>serv.sin_addr是 struct in_addr类型的IP地址
</li>
</ol>
</li>
<li>历史上struct in_addr的设计比这个复杂,里面曾经可以通过union的成
员让, A类, B类地址来取得自己的网络部分, 随着subnet的出现, struct in_addr
就开始只有一个成员变量啦
</li>
<li>sin_zero全部都是零.
</li>
<li>socket address structure是每个host有自己的,相互之间不交流的. 虽然某些数
据,比如sin_addr用来指导数据交换
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2">Generic Socket Address Structure</h4>
<div class="outline-text-4" id="text-1-2-2">
<ul class="org-ul">
<li>socket address structure总是以pass by reference的方式传入到socket function
当中去的,但是问题是socket function要处理多种协议,而每种协议都有自己的socket address
structure.
</li>
<li>放到1989年以后,我们可以使用void* 来指代所有的指针. 但是socket function诞生于1982
年.所以它不得不为所有的socket address structure创造了一个generic 的socket address
structure.
<div class="org-src-container">

<pre class="src src-c"><span style="color: #AE5825;">struct</span> <span style="color: #C6B032; font-style: italic;">sockaddr</span> {
    <span style="color: #C6B032; font-style: italic;">uint8_t</span>        <span style="color: #46657B;">sa_len</span>;
    <span style="color: #C6B032; font-style: italic;">sa_family_t</span>    <span style="color: #46657B;">sa_family</span>;     <span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">address family: AF_xxx value </span><span style="color: #4C565D;">*/</span>
    <span style="color: #C6B032; font-style: italic;">char</span>           <span style="color: #46657B;">sa_data</span>[14];   <span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">protocol-specific address </span><span style="color: #4C565D;">*/</span>
};
</pre>
</div>
</li>
<li>我们可以看到多有的socket function都是用的generic的socket address structure
作为其函数的参数的
<div class="org-src-container">

<pre class="src src-c"><span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #C6B032;">bind</span>(<span style="color: #C6B032; font-style: italic;">int</span>, <span style="color: #AE5825;">struct</span> <span style="color: #C6B032; font-style: italic;">sockaddr</span>*, <span style="color: #C6B032; font-style: italic;">socklen_t</span>);
</pre>
</div>
</li>
<li>generic指针的坏处就是每次某个协议的socket address structure一定要进行一次
类型转换(casting)
<div class="org-src-container">

<pre class="src src-c"><span style="color: #AE5825;">struct</span> <span style="color: #C6B032; font-style: italic;">socketaddr_in</span> <span style="color: #46657B;">serv</span>;           <span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">IPv4 socket address structure </span><span style="color: #4C565D;">*/</span>

<span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">fill in serv{} </span><span style="color: #4C565D;">*/</span>
bind(sockfd, (<span style="color: #AE5825;">struct</span> <span style="color: #C6B032; font-style: italic;">sockaddr</span> *)&amp;serv, <span style="color: #AE5825;">sizeof</span>(serv));
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2-3" class="outline-4">
<h4 id="sec-1-2-3">IPv6 Socket Address Structure</h4>
<div class="outline-text-4" id="text-1-2-3">
<ul class="org-ul">
<li>IPv6在&lt;netinet/in.h&gt;里面定义了自己的socket address structure
<div class="org-src-container">

<pre class="src src-c"><span style="color: #AE5825;">struct</span> <span style="color: #C6B032; font-style: italic;">in6_addr</span> {
    <span style="color: #C6B032; font-style: italic;">uint8_t</span> <span style="color: #46657B;">s6_addr</span>[16];             <span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">128-bit IPv6 address </span><span style="color: #4C565D;">*/</span>
                                     <span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">network byte ordered </span><span style="color: #4C565D;">*/</span>
};

<span style="color: #007575;">#define</span> <span style="color: #46657B;">SIN6_LEN</span>      <span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">required for compile-time tests </span><span style="color: #4C565D;">*/</span>

<span style="color: #AE5825;">struct</span> <span style="color: #C6B032; font-style: italic;">sockaddr_in6</span> {
    <span style="color: #C6B032; font-style: italic;">uint8_t</span>             <span style="color: #46657B;">sin6_len</span>;              <span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">length of this struct (28) </span><span style="color: #4C565D;">*/</span>
    <span style="color: #C6B032; font-style: italic;">sa_family_t</span>         <span style="color: #46657B;">sin6_family</span>;           <span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">AF_INET6 </span><span style="color: #4C565D;">*/</span>
    <span style="color: #C6B032; font-style: italic;">in_port_t</span>           <span style="color: #46657B;">sin6_port</span>;             <span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">transport layer port# </span><span style="color: #4C565D;">*/</span>
                                               <span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">network byte ordered </span><span style="color: #4C565D;">*/</span>
    <span style="color: #C6B032; font-style: italic;">uint32_t</span>            <span style="color: #46657B;">sin6_flowinfo</span>;         <span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">flow information, undefined </span><span style="color: #4C565D;">*/</span>
    <span style="color: #AE5825;">struct</span> <span style="color: #C6B032; font-style: italic;">in6_addr</span>     <span style="color: #46657B;">sin6_addr</span>;             <span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">IPv6 address </span><span style="color: #4C565D;">*/</span>
                                               <span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">network byte ordered </span><span style="color: #4C565D;">*/</span>
    <span style="color: #C6B032; font-style: italic;">uint32_t</span>            <span style="color: #46657B;">sin6_scope_id</span>;         <span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">set of interfaces for a scope </span><span style="color: #4C565D;">*/</span>
};
</pre>
</div>
</li>
<li>上面例子需要了解的是:
<ul class="org-ul">
<li>如果系统支持socket address structure的长度, 那么就要设置SIN6_LEN
</li>
<li>这个布局是惊喜设计的,可以达到64-bit aligned的效果,在64位处理器上效果好
</li>
<li>sin6_flowinfo分成两部分:
<ol class="org-ol">
<li>low-order 20 bits 是 flow lable
</li>
<li>high-order 13 bits是保留字
</li>
</ol>
</li>
</ul>
</li>
<li>sin6_scope_id用来指示scope zone
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2-4" class="outline-4">
<h4 id="sec-1-2-4">New Generic Socket Address Structure</h4>
<div class="outline-text-4" id="text-1-2-4">
<ul class="org-ul">
<li>为了迎合新的IPv6协议,一个新的generic socket address structure也就设计出来了
<div class="org-src-container">

<pre class="src src-c"><span style="color: #AE5825;">struct</span> <span style="color: #C6B032; font-style: italic;">sockaddr_storage</span> {
    <span style="color: #C6B032; font-style: italic;">uint8_t</span>        <span style="color: #46657B;">ss_len</span>;       <span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">length of this struct (implementation dependent) </span><span style="color: #4C565D;">*/</span>
    <span style="color: #C6B032; font-style: italic;">sa_family_t</span>    <span style="color: #46657B;">ss_family</span>;    <span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">address family: AF_xxx value </span><span style="color: #4C565D;">*/</span>
    <span style="color: #4C565D;">/*******************************************************************/</span>
    <span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">implementation-dependent elements to provide:                   </span><span style="color: #4C565D;">*/</span>
    <span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">a) alignment sufficient to fulfill the alignment requirement of </span><span style="color: #4C565D;">*/</span>
    <span style="color: #4C565D;">/*    </span><span style="color: #333B40; font-style: italic;">all socket address types that the system supports            </span><span style="color: #4C565D;">*/</span>
    <span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">b) enough storage to hold any type of socket address that the   </span><span style="color: #4C565D;">*/</span>
    <span style="color: #4C565D;">/*    </span><span style="color: #333B40; font-style: italic;">system supports                                              </span><span style="color: #4C565D;">*/</span>
    <span style="color: #4C565D;">/*******************************************************************/</span>
};
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2-5" class="outline-4">
<h4 id="sec-1-2-5">Comparison of Socket Address Structures</h4>
<div class="outline-text-4" id="text-1-2-5">
<ul class="org-ul">
<li>下面用一个图来对比所有的socket address structure

<div class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/org_dot/master/notes/network/sas.png" alt="sas.png" />
</p>
<p><span class="figure-number">Figure 1:</span> socket-address-structure.png</p>
</div>
</li>
<li>我们原来总是看到socket函数的第三个参数为socket address structures的size,比
如第一章的例子中(如下). 如果length field 不是在4.3BSD reno中引入,而是第一个
版本(设计bind的时候)就引入, 那么,我们可能就不需要每次都多加一个参数了
<div class="org-src-container">

<pre class="src src-c">Bind(listenfd, (<span style="color: #C6B032; font-style: italic;">SA</span>*) &amp;servaddr, siezeof(servaddr));
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Value-Result Arguments</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>我们刚才已经讨论过了socket address structure, 他们主要是在process和kernel之
间传递.传递的方向不同,导致length of the structure的使用方法不同.
<ul class="org-ul">
<li>从process到kernel:例子有, 函数bind, connect, sendto, 由于被告知了指针地址,
和数据长度.所以,内核知道要从进程拷贝多少东西
<div class="org-src-container">

<pre class="src src-c"><span style="color: #AE5825;">struct</span> <span style="color: #C6B032; font-style: italic;">sockaddr_in</span> <span style="color: #46657B;">serv</span>;

<span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">fill in serv{} </span><span style="color: #4C565D;">*/</span>
connect(sockfd, (<span style="color: #C6B032; font-style: italic;">SA</span> *)&amp;serv, <span style="color: #AE5825;">sizeof</span>(serv));
</pre>
</div>


<div class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/org_dot/master/notes/network/process-to-kernel.png" alt="process-to-kernel.png" />
</p>
<p><span class="figure-number">Figure 2:</span> process-to-kernel.png</p>
</div>
</li>

<li>从kernel到process:例子有accept, recvfrom, getsockname, getpeername.这些函数
里面的len不再是一个int,而是pointer to int. 其目的有两点
<div class="org-src-container">

<pre class="src src-c"><span style="color: #AE5825;">struct</span> <span style="color: #C6B032; font-style: italic;">sockaddr_un</span> <span style="color: #46657B;">cli</span>;    <span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">Unix domain </span><span style="color: #4C565D;">*/</span>
<span style="color: #C6B032; font-style: italic;">socklen_t</span>  <span style="color: #46657B;">len</span>;

len = <span style="color: #AE5825;">sizeof</span>(cli);         <span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">len is a value </span><span style="color: #4C565D;">*/</span>
getpeername(unixfd, (<span style="color: #C6B032; font-style: italic;">SA</span> *) &amp;cli, &amp;len);
<span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">len may have changed </span><span style="color: #4C565D;">*/</span>
</pre>
</div>

<div class="figure">
<p><img src="https://raw.githubusercontent.com/harrifeng/org_dot/master/notes/network/kernel-to-process.png" alt="kernel-to-process.png" />
</p>
<p><span class="figure-number">Figure 3:</span> kernel-to-process.png</p>
</div>
<ol class="org-ol">
<li>能够返回到底拷贝了多少的值(这个很显然,因为是copy by reference嘛)
</li>
<li>len在做参数之前,是有原来的值的(通过sizeof取得), 为的是告诉kernel界限在
哪里,不要拷贝数据到process的时候越界. 如果socket address structure是
长度不变,那么返回值一定:比如16 for IPv4 sockaddr_in, 28 for IPv6
sockaddr_in6. 对于长度可变的socket address structure,比如sockadr_un,
可能会改变len的值
</li>
</ol>
</li>
</ul>
</li>
<li>除了kernel 到process拷贝时候的returned socket address structure, 会出现
value-result argument, 另外会出现value-result argument的函数有:
<ul class="org-ul">
<li>select
</li>
<li>getsockopt
</li>
<li>recvmsg
</li>
<li>ifconf
</li>
<li>sysctl
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">Byte Ordering Functions</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>假设一个Integer是16bit,那么就是由两个bytes组成的.在计算机里面有两种放置方式:
<ul class="org-ul">
<li>big-endian : with the high-order byte at the starting address:
<ol class="org-ol">
<li>网络数据使用的就是这个endian, 其兼容性不好:,所以下面的例子只能在integer 为4bytes的
时候,成立啦,哪天换了64位cpu,integer成了8bytes,下面的代码两个s的值额就不相等了
<div class="org-src-container">

<pre class="src src-c"><span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">i MUST be 4bytes, as we have to fetch the last byte</span>
<span style="color: #C6B032; font-style: italic;">short</span> <span style="color: #46657B;">s</span> = (<span style="color: #C6B032; font-style: italic;">short</span>)i;
<span style="color: #C6B032; font-style: italic;">short</span> <span style="color: #46657B;">s</span> = ((<span style="color: #C6B032; font-style: italic;">short</span>*)&amp;i)[1];
</pre>
</div>
</li>
<li>另外,摩托罗拉的power cpu使用的是big endian, 因为big endian会产生更好看
的hex dumps, 对的,你没看错.摩托罗拉的工程师认为,这个比兼容性更重要.为了更
好的读dump,因为程序崩溃的时候不是用printf读取数据的,直接是把内存内容打印
出来,如下,内存内容排列的顺序跟我们输入的顺序0x01020304是一样的:
<div class="org-src-container">

<pre class="src src-c"><span style="color: #007575;">#include</span> <span style="color: #5A7644;">&lt;stdio.h&gt;</span>

<span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #C6B032;">main</span>(<span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #46657B;">argc</span>, <span style="color: #C6B032; font-style: italic;">char</span> *<span style="color: #46657B;">argv</span>[])
{
    <span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #46657B;">ii</span> = 0x01020304;
    <span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #46657B;">i</span> = 0;
    <span style="color: #C6B032; font-style: italic;">char</span>* <span style="color: #46657B;">ptr</span> = &amp;ii;
    <span style="color: #AE5825;">for</span> (i = 0; i &lt; 4; i++) {
        printf(<span style="color: #5A7644;">"%x\n"</span>, *ptr);
        ptr++;
    }

    <span style="color: #AE5825;">return</span> 0;
}

<span style="color: #4C565D;">/***********************************/</span>
<span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">===Result==                     </span><span style="color: #4C565D;">*/</span>
<span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">lvtest@auto-inst:~/tmp$ ./a.out </span><span style="color: #4C565D;">*/</span>
<span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">1                               </span><span style="color: #4C565D;">*/</span>
<span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">2                               </span><span style="color: #4C565D;">*/</span>
<span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">3                               </span><span style="color: #4C565D;">*/</span>
<span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">4                               </span><span style="color: #4C565D;">*/</span>
<span style="color: #4C565D;">/***********************************/</span>
</pre>
</div>
</li>
</ol>
</li>
<li>little-endian : with the low-order byte at the starting address, 
<ol class="org-ol">
<li>英特尔设计的x86 cpu都是使用little endian, 因为little-endian在cast
的时候,不需要知道原型的长度,所以有很好的向后兼容性, 下面两条在x86上面的
结果一致.
<div class="org-src-container">

<pre class="src src-c"><span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">i can be 4 byte int, can ALSO be 8 bytes int. We just fetch the first byte</span>
<span style="color: #C6B032; font-style: italic;">short</span> <span style="color: #46657B;">s</span> = (<span style="color: #C6B032; font-style: italic;">short</span>)i;
<span style="color: #C6B032; font-style: italic;">short</span> <span style="color: #46657B;">s</span> = *(<span style="color: #C6B032; font-style: italic;">short</span>*)&amp;i;
</pre>
</div>
</li>
<li>little endian里面地址最小的byte,也同时是数据最小的一个byte,如果不用
printf(coredump的时候)打印出来的顺序和人类写入的顺序是不同的
<div class="org-src-container">

<pre class="src src-c"><span style="color: #007575;">#include</span> <span style="color: #5A7644;">&lt;stdio.h&gt;</span>

<span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #C6B032;">main</span>(<span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #46657B;">argc</span>, <span style="color: #C6B032; font-style: italic;">char</span> *<span style="color: #46657B;">argv</span>[])
{
    <span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #46657B;">ii</span> = 0x01020304;
    <span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #46657B;">i</span> = 0;
    <span style="color: #C6B032; font-style: italic;">char</span>* <span style="color: #46657B;">ptr</span> = &amp;ii;
    <span style="color: #AE5825;">for</span> (i = 0; i &lt; 4; i++) {
        printf(<span style="color: #5A7644;">"%x\n"</span>, *ptr);
        ptr++;
    }

    <span style="color: #AE5825;">return</span> 0;
}

<span style="color: #4C565D;">/***********************************/</span>
<span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">===Result==                     </span><span style="color: #4C565D;">*/</span>
<span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">lvtest@auto-inst:~/tmp$ ./a.out </span><span style="color: #4C565D;">*/</span>
<span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">4                               </span><span style="color: #4C565D;">*/</span>
<span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">3                               </span><span style="color: #4C565D;">*/</span>
<span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">2                               </span><span style="color: #4C565D;">*/</span>
<span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">1                               </span><span style="color: #4C565D;">*/</span>
<span style="color: #4C565D;">/***********************************/</span>
</pre>
</div>
</li>
</ol>
</li>
</ul>
</li>

<li>下面是一个简单的测试endian的代码:小的"地址"取出来的,是"数据"的较小部分的就
是little endian, 这样我们每次取"数据"最"小"的部门,也就是地址为的部门,
肯定可以是casting的结果.
<div class="org-src-container">

<pre class="src src-c"><span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #C6B032;">main</span>(<span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #46657B;">argc</span>, <span style="color: #C6B032; font-style: italic;">char</span> *<span style="color: #46657B;">argv</span>[])
{
    <span style="color: #AE5825;">union</span> {
        <span style="color: #C6B032; font-style: italic;">short</span>    <span style="color: #46657B;">s</span>;
        <span style="color: #C6B032; font-style: italic;">char</span>     <span style="color: #46657B;">c</span>[<span style="color: #AE5825;">sizeof</span>(<span style="color: #C6B032; font-style: italic;">short</span>)];
    } <span style="color: #46657B;">un</span>;

    un.s = 0x0102;
    printf(<span style="color: #5A7644;">"%s: "</span>, CPU_VENDOR_OS);
    <span style="color: #AE5825;">if</span> (<span style="color: #AE5825;">sizeof</span>(<span style="color: #C6B032; font-style: italic;">short</span>) == 2) {
        <span style="color: #AE5825;">if</span> (un.c[0] == 1 &amp;&amp; un.c[1] == 2) {
            printf(<span style="color: #5A7644;">"big-endian\n"</span>);
        } <span style="color: #AE5825;">else</span> <span style="color: #AE5825;">if</span> (un.c[0] ==2 &amp;&amp; un.c[1] == 1) {
            printf(<span style="color: #5A7644;">"little-endian\n"</span>);
        } <span style="color: #AE5825;">else</span> {
            printf(<span style="color: #5A7644;">"unknown\n"</span>);
        }
    } <span style="color: #AE5825;">else</span> {
        printf(<span style="color: #5A7644;">"sizeof(short) = %d\n"</span>, <span style="color: #AE5825;">sizeof</span>(<span style="color: #C6B032; font-style: italic;">short</span>));
    }
    <span style="color: #AE5825;">return</span> 0;
}
</pre>
</div>
</li>
<li>之所以讲到endian,是因为在网络上传输的数据必须是network byte order的. 比如TCP
里面的16-bit端口号和32-bit IP地址都得是network byte order的才能认识.
</li>
<li>按说,可以把endian的实现封装起来,由api内部在传输前从内部order转换成network order
然后收到数据的时候,再反向转换回来. 但是由于历史的原因,包括POSIX规范都要求socket address
structure的某些部分,一定要以network order存储.所以我们就不多考虑这个问题了,转而研究
转换order的函数
<div class="org-src-container">

<pre class="src src-c"><span style="color: #007575;">#includ</span> &lt;netinet/in.h&gt;

<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">Both return: value in network byte order</span>
<span style="color: #C6B032; font-style: italic;">uint16_t</span> <span style="color: #C6B032;">htons</span>(<span style="color: #C6B032; font-style: italic;">uint16_t</span> <span style="color: #46657B;">host16bitvalue</span>);
<span style="color: #C6B032; font-style: italic;">uint32_t</span> <span style="color: #C6B032;">htonl</span>(<span style="color: #C6B032; font-style: italic;">uint32_t</span> <span style="color: #46657B;">host32bitvalue</span>);

<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">Both return: value in host byte order</span>
<span style="color: #C6B032; font-style: italic;">uint16_t</span> <span style="color: #C6B032;">ntohs</span>(<span style="color: #C6B032; font-style: italic;">uint16_t</span> <span style="color: #46657B;">net16bitvalue</span>);
<span style="color: #C6B032; font-style: italic;">uint32_t</span> <span style="color: #C6B032;">ntohl</span>(<span style="color: #C6B032; font-style: italic;">uint32_t</span> <span style="color: #46657B;">net32bitvalue</span>);
</pre>
</div>
</li>
<li>名字也都好理解h代表host, s代表short, l代表long
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">Byte Manipulation Functions</h3>
<div class="outline-text-3" id="text-1-5">
<ul class="org-ul">
<li>和c语言里面的字符串不一样, socket里面的数据通常有很多0, 所以也无法做到"\0"
结尾.于是我们还要有很多的其他函数来处理字符串:
<ul class="org-ul">
<li>一类来自4.2bsd,以b开头
<div class="org-src-container">

<pre class="src src-c"><span style="color: #007575;">#include</span> <span style="color: #5A7644;">&lt;strings.h&gt;</span>

<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">sets the specified number of bytess to 0 in the detination</span>
<span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">bzero</span>(<span style="color: #C6B032; font-style: italic;">void</span> *<span style="color: #46657B;">dist</span>, <span style="color: #C6B032; font-style: italic;">size_t</span> <span style="color: #46657B;">nbytes</span>);

<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">const means the memory point by the "void *" can not (and will not)</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">be changed.</span>
<span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">bcopy</span>(<span style="color: #AE5825;">const</span> <span style="color: #C6B032; font-style: italic;">void</span> *<span style="color: #46657B;">src</span>, <span style="color: #C6B032; font-style: italic;">void</span> *<span style="color: #46657B;">dest</span>, <span style="color: #C6B032; font-style: italic;">size_t</span> <span style="color: #46657B;">nbytes</span>);

<span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #C6B032;">bcmp</span>(<span style="color: #AE5825;">const</span> <span style="color: #C6B032; font-style: italic;">void</span> *<span style="color: #46657B;">ptr1</span>, <span style="color: #AE5825;">const</span> <span style="color: #C6B032; font-style: italic;">voi</span> *<span style="color: #46657B;">ptr2</span>, <span style="color: #C6B032; font-style: italic;">size_t</span> <span style="color: #46657B;">nbytes</span>);
</pre>
</div>
</li>
<li>另外一类来子ANSI C standard, 以mem开头
<div class="org-src-container">

<pre class="src src-c"><span style="color: #007575;">#include</span> <span style="color: #5A7644;">&lt;string.h&gt;</span>

<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">specified number f bytest to the value c in the destination</span>
<span style="color: #C6B032; font-style: italic;">void</span> *<span style="color: #C6B032;">memset</span>(<span style="color: #C6B032; font-style: italic;">void</span> *<span style="color: #46657B;">dest</span>, <span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #46657B;">c</span>, <span style="color: #C6B032; font-style: italic;">size_t</span> <span style="color: #46657B;">len</span>);

<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">copy nbytes from src to dest</span>
<span style="color: #C6B032; font-style: italic;">void</span> *<span style="color: #C6B032;">memcpy</span>(<span style="color: #C6B032; font-style: italic;">void</span> *<span style="color: #46657B;">dest</span>, <span style="color: #AE5825;">const</span> <span style="color: #C6B032; font-style: italic;">void</span> *<span style="color: #46657B;">src</span>, <span style="color: #C6B032; font-style: italic;">size_t</span> <span style="color: #46657B;">nbytes</span>);

<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">return 0 if equal, otherwise unequal</span>
<span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #C6B032;">memcmp</span>(<span style="color: #AE5825;">const</span> <span style="color: #C6B032; font-style: italic;">void</span> *<span style="color: #46657B;">ptr1</span>, <span style="color: #AE5825;">const</span> <span style="color: #C6B032; font-style: italic;">void</span> *<span style="color: #46657B;">ptr2</span>, <span style="color: #C6B032; font-style: italic;">size_t</span> <span style="color: #46657B;">nbytes</span>);
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6">inet_aton, inet_addr, and inet_ntoa Funtions</h3>
<div class="outline-text-3" id="text-1-6">
<ul class="org-ul">
<li>IP地址的host-network转换,在IPv4时代主要依靠下面两个函数
<div class="org-src-container">

<pre class="src src-c"><span style="color: #007575;">#include</span> <span style="color: #5A7644;">&lt;arpa/inet.h&gt;</span>

<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">1] converts c character pointed to by strptr into it2 32-bit</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">binary network byte order value stored in addrptr</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">2] if string was valid return 1, otherwise return 0</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">3] if addrpter is NULL, the function still performs the validation</span>
<span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #C6B032;">inet_aton</span>(<span style="color: #AE5825;">const</span> <span style="color: #C6B032; font-style: italic;">char</span>* <span style="color: #46657B;">strptr</span>, <span style="color: #AE5825;">struct</span> <span style="color: #C6B032; font-style: italic;">in_addr</span>* <span style="color: #46657B;">addrptr</span>);

<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">return pointers to dotted-decimal string</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">use static memory in inet_ntoa implementation and thus NOT reentrant</span>
<span style="color: #C6B032; font-style: italic;">char</span> *<span style="color: #C6B032;">inet_ntoa</span>(<span style="color: #AE5825;">struct</span> <span style="color: #C6B032; font-style: italic;">in_addr</span> <span style="color: #46657B;">inaddr</span>);
</pre>
</div>
</li>
<li>值得一说的是inet_ntoa这个函数返回的是一个char*, 返回一个char *,那么肯定函数
里面使用了static变量,否则函数返回了,auto 变量都回收了,如何返回值.既然inet_ntoa
使用了static变量,那么就肯定不是reentrant函数了.更无法实现threadsafe, 所以这个
函数已经被放弃了,取而代之的是一个reentrant版本
<div class="org-src-container">

<pre class="src src-c"><span style="color: #C6B032; font-style: italic;">char</span> * <span style="color: #C6B032;">inet_ntoa_r</span>(<span style="color: #AE5825;">struct</span> <span style="color: #C6B032; font-style: italic;">in_addr</span> <span style="color: #46657B;">in</span>, <span style="color: #C6B032; font-style: italic;">char</span> *<span style="color: #46657B;">buf</span>, <span style="color: #C6B032; font-style: italic;">socklen_t</span> <span style="color: #46657B;">size</span>) {
        (<span style="color: #C6B032; font-style: italic;">void</span>) inet_ntop(AF_INET, &amp;in, buf, size);
        <span style="color: #AE5825;">return</span> (buf);
}
</pre>
</div>
</li>
<li>还有一个问题更多被放弃的函数inet_addr,它的问题主要是返回值如果是255.255.255.255
的话,其实是-1.一遍函数用-1代表出问题. 加之可以用inet_aton代替,所以早已被废弃
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7">inet_pton and inet_ntop Functions</h3>
<div class="outline-text-3" id="text-1-7">
<ul class="org-ul">
<li>上一节介绍的函数都可以用下面两个函数代替,而且这两个函数还支持IPv6
<div class="org-src-container">

<pre class="src src-c"><span style="color: #007575;">#include</span> <span style="color: #5A7644;">&lt;arpa/inet.h&gt;</span>

<span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #C6B032;">inet_pton</span>(<span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #46657B;">family</span>, <span style="color: #AE5825;">const</span> <span style="color: #C6B032; font-style: italic;">char</span> *<span style="color: #46657B;">strptr</span>, <span style="color: #C6B032; font-style: italic;">void</span> *<span style="color: #46657B;">addrptr</span>);

<span style="color: #AE5825;">const</span> <span style="color: #C6B032; font-style: italic;">char</span>* <span style="color: #C6B032;">inet_ntop</span>(<span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #46657B;">family</span>, <span style="color: #AE5825;">const</span> <span style="color: #C6B032; font-style: italic;">void</span> *<span style="color: #46657B;">addrptr</span>, <span style="color: #C6B032; font-style: italic;">char</span> *<span style="color: #46657B;">strptr</span>, <span style="color: #C6B032; font-style: italic;">size_t</span> <span style="color: #46657B;">len</span>);
</pre>
</div>
</li>
<li>family可以是AF_INET或者AF_INET6, 如果family不支持,会返回错误同时set errno
为EAFNOSUPPORT
</li>
<li>注意inet_ntop的返回值是char *但是并不是和上一节的inet_ntoa一样是返回内部的
     static 内存.而是重复返回strptr而已(上面的inet_ntoa_r也一样)
</li>
<li>inet_ntop还有一个len参数来保证strptr的buffer不溢出.如果len过小的话, errno
会被设为ENOSPC
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8">sock_ntop and Related Function</h3>
<div class="outline-text-3" id="text-1-8">
<ul class="org-ul">
<li>inet_ntop的一个缺点是要求传入一个pointer(指向某个binary address), 而且我们
要实现知道这个地址的类型, 为了适应ipv4和ipv6的两种情况,我们设计了下面这个函数
sock_ntop,他会探测好pointer指向的地址类型,然后调用对应的inet_ntop, 下面只
列举了AF_INET的情况
<div class="org-src-container">

<pre class="src src-c"><span style="color: #C6B032; font-style: italic;">char</span> * <span style="color: #C6B032;">sock_ntop</span>(<span style="color: #AE5825;">const</span> <span style="color: #AE5825;">struct</span> <span style="color: #C6B032; font-style: italic;">sockaddr</span>* <span style="color: #46657B;">sa</span>, <span style="color: #C6B032; font-style: italic;">socklen_t</span> <span style="color: #46657B;">salen</span>) {
    <span style="color: #C6B032; font-style: italic;">char</span>          <span style="color: #46657B;">portstr</span>[8];
    <span style="color: #AE5825;">static</span> <span style="color: #C6B032; font-style: italic;">char</span>   <span style="color: #46657B;">str</span>[128];   <span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">unix domain is largest </span><span style="color: #4C565D;">*/</span>

    <span style="color: #AE5825;">switch</span> (sa-&gt;sa_family) {
    <span style="color: #AE5825;">case</span> AF_INET: {
        <span style="color: #AE5825;">struct</span> <span style="color: #C6B032; font-style: italic;">sockaddr_in</span> *<span style="color: #46657B;">sin</span> = (<span style="color: #AE5825;">struct</span> <span style="color: #C6B032; font-style: italic;">sockaddr_in</span> *)sa;

        <span style="color: #AE5825;">if</span> (inet_ntop(AF_INET, &amp;sin-&gt;sin_addr, str, <span style="color: #AE5825;">sizeof</span>(str)) == <span style="color: #86453A;">NULL</span>) {
            <span style="color: #AE5825;">return</span> (<span style="color: #86453A;">NULL</span>);
        }
        <span style="color: #AE5825;">if</span> (ntohs(sin-&gt;sin_port) != 0) {
            snprintf(portstr, <span style="color: #AE5825;">sizeof</span>(portstr) <span style="color: #5A7644;">":%d"</span>,
                     ntohs(sin-&gt;sin_port));
            strcat(str, portstr);
        }
        <span style="color: #AE5825;">return</span> (str);
    }
        <span style="color: #4C565D;">//</span><span style="color: #333B40; font-style: italic;">.....</span>
    }
}
</pre>
</div>
</li>
<li>我们还写了以下一系列的函数来一次性处理ipv4和ipv6
<div class="org-src-container">

<pre class="src src-c"><span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #C6B032;">sock_bin_wild</span>(<span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #46657B;">sockfd</span>, <span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #46657B;">family</span>);

<span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #C6B032;">sock_cmp_addr</span>(<span style="color: #AE5825;">const</span> <span style="color: #AE5825;">struct</span> <span style="color: #C6B032; font-style: italic;">sockaddr</span> *<span style="color: #46657B;">sockaddr1</span>,
                  <span style="color: #AE5825;">const</span> <span style="color: #AE5825;">struct</span> <span style="color: #C6B032; font-style: italic;">sockaddr</span> *<span style="color: #46657B;">sockaddr2</span>,
                  <span style="color: #C6B032; font-style: italic;">socklen_t</span> <span style="color: #46657B;">addrlen</span>);
<span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #C6B032;">sock_cmp_port</span>(<span style="color: #AE5825;">const</span> <span style="color: #AE5825;">struct</span> <span style="color: #C6B032; font-style: italic;">sockaddr</span> *<span style="color: #46657B;">sockaddr1</span>,
                  <span style="color: #AE5825;">const</span> <span style="color: #AE5825;">struct</span> <span style="color: #C6B032; font-style: italic;">sockaddr</span> *<span style="color: #46657B;">sockaddr2</span>,
                  <span style="color: #C6B032; font-style: italic;">socklen_t</span> <span style="color: #46657B;">addrlen</span>);
<span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #C6B032;">sock_get_port</span>(<span style="color: #AE5825;">const</span> <span style="color: #AE5825;">struct</span> <span style="color: #C6B032; font-style: italic;">sockaddr</span>* <span style="color: #46657B;">sockaddr</span>, <span style="color: #C6B032; font-style: italic;">socklen_t</span> <span style="color: #46657B;">addrlen</span>);
<span style="color: #C6B032; font-style: italic;">char</span> *<span style="color: #C6B032;">sock_ntop_host</span>(<span style="color: #AE5825;">const</span> <span style="color: #AE5825;">struct</span> <span style="color: #C6B032; font-style: italic;">sockaddr</span>* <span style="color: #46657B;">sockaddr</span>, <span style="color: #C6B032; font-style: italic;">socklen_t</span> <span style="color: #46657B;">addrlen</span>);
<span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">sock_set_addr</span>(<span style="color: #AE5825;">const</span> <span style="color: #AE5825;">struct</span> <span style="color: #C6B032; font-style: italic;">sockaddr</span> *<span style="color: #46657B;">sockaddr</span>, <span style="color: #C6B032; font-style: italic;">socklen_t</span> <span style="color: #46657B;">addrlen</span>, <span style="color: #C6B032; font-style: italic;">void</span> *<span style="color: #46657B;">ptr</span>);
<span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">sock_set_port</span>(<span style="color: #AE5825;">const</span> <span style="color: #AE5825;">struct</span> <span style="color: #C6B032; font-style: italic;">sockaddr</span> *<span style="color: #46657B;">sockaddr</span>, <span style="color: #C6B032; font-style: italic;">socklen_t</span> <span style="color: #46657B;">addrlen</span>, <span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #46657B;">port</span>);
<span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">sock_set_wild</span>(<span style="color: #AE5825;">struct</span> <span style="color: #C6B032; font-style: italic;">sockaddr</span> *<span style="color: #46657B;">sockaddr</span>, <span style="color: #C6B032; font-style: italic;">socklen_t</span> <span style="color: #46657B;">addrlen</span>);
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-9" class="outline-3">
<h3 id="sec-1-9">readn, writen, and readline Functions</h3>
<div class="outline-text-3" id="text-1-9">
<ul class="org-ul">
<li>通常情况下在socket编程中read和write的结果通常比我们要求的要少, 这是因为读取
写入已经超过了buffer limit,需要再次读取或写入(特殊情况下read可以超过这个limit,
但是write只有在nonblocking的情况下才能超过这个lilmit)
</li>
<li>我们自己设计了一系列函数,在一次不成功读取写入要求的byte的情况下,多次去读取和写入
<ul class="org-ul">
<li>readn: Read "b" bytes from a descriptor
<div class="org-src-container">

<pre class="src src-c"><span style="color: #C6B032; font-style: italic;">ssize_t</span>
<span style="color: #C6B032;">readn</span>(<span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #46657B;">fd</span>, <span style="color: #C6B032; font-style: italic;">void</span> *<span style="color: #46657B;">vptr</span>, <span style="color: #C6B032; font-style: italic;">size_t</span> <span style="color: #46657B;">n</span>) {
    <span style="color: #C6B032; font-style: italic;">size_t</span>  <span style="color: #46657B;">nleft</span>;
    <span style="color: #C6B032; font-style: italic;">ssize_t</span> <span style="color: #46657B;">nread</span>;
    <span style="color: #C6B032; font-style: italic;">char</span>    *<span style="color: #46657B;">ptr</span>;

    ptr = vptr;
    nleft = n;
    <span style="color: #AE5825;">while</span> (nleft &gt; 0) {
        <span style="color: #AE5825;">if</span>( (nread = read(fd, ptr, nleft)) &lt; 0) {
            <span style="color: #AE5825;">if</span> (errno == EINTR) {
                nread = 0;            <span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">and call read() again </span><span style="color: #4C565D;">*/</span>
            } <span style="color: #AE5825;">else</span> {
                <span style="color: #AE5825;">return</span> (-1);
            } <span style="color: #AE5825;">else</span> <span style="color: #AE5825;">if</span> (nread == 0) {
                <span style="color: #AE5825;">break</span>;                <span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">EOF </span><span style="color: #4C565D;">*/</span>
            }
        }

        nleft -= nread;
        ptr += nread;
    }
    <span style="color: #AE5825;">return</span> (n - nleft);       <span style="color: #4C565D;">/* </span><span style="color: #333B40; font-style: italic;">return &gt;= 0</span><span style="color: #4C565D;">*/</span>
}
</pre>
</div>
</li>
<li>writen: Wirte n bytes to a descriptor
<div class="org-src-container">

<pre class="src src-c"><span style="color: #C6B032; font-style: italic;">ssize_t</span>
<span style="color: #C6B032;">writen</span>(<span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #46657B;">fd</span>, <span style="color: #AE5825;">const</span> <span style="color: #C6B032; font-style: italic;">void</span> *<span style="color: #46657B;">vptr</span>, <span style="color: #C6B032; font-style: italic;">size_t</span> <span style="color: #46657B;">n</span>) {
    <span style="color: #C6B032; font-style: italic;">size_t</span>   <span style="color: #46657B;">nleft</span>;
    <span style="color: #C6B032; font-style: italic;">ssize_t</span>  <span style="color: #46657B;">nwritten</span>;
    <span style="color: #AE5825;">const</span> <span style="color: #C6B032; font-style: italic;">char</span> *<span style="color: #46657B;">ptr</span>;

    ptr = vptr;
    nleft = n;
    <span style="color: #AE5825;">while</span>(nleft &gt; 0) {
        <span style="color: #AE5825;">if</span> ((nwritten = write(fd, ptr, nleft) &lt;= 0)) {

            <span style="color: #AE5825;">if</span> (nwritten &lt; 0 &amp;&amp; errno == EINTR) {
                nwritten = 0;
            } <span style="color: #AE5825;">else</span> {
                <span style="color: #AE5825;">return</span> (-1);
            }
        }
        nleft == nwritten;
        ptr += nwritten;
    }
    <span style="color: #AE5825;">return</span> (n);
}
</pre>
</div>
</li>
<li>readline : PAINFULLY SLOW VERSION
<div class="org-src-container">

<pre class="src src-c"><span style="color: #C6B032; font-style: italic;">ssize_t</span>
<span style="color: #C6B032;">readline</span>(<span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #46657B;">fd</span>, <span style="color: #C6B032; font-style: italic;">void</span> *<span style="color: #46657B;">vptr</span>, <span style="color: #C6B032; font-style: italic;">size_t</span> <span style="color: #46657B;">maxlen</span>) {
    <span style="color: #C6B032; font-style: italic;">ssize_t</span> <span style="color: #46657B;">n</span>, <span style="color: #46657B;">rc</span>;
    <span style="color: #C6B032; font-style: italic;">char</span>    <span style="color: #46657B;">c</span>, *<span style="color: #46657B;">ptr</span>;

    ptr = vptr;
    <span style="color: #AE5825;">for</span> (n = 1; n &lt; maxlen; n++) {
    <span style="color: #86453A;">again</span>:
        <span style="color: #AE5825;">if</span> ((rc == read(fd, &amp;c, 1)) == 1) {
            *ptr++ = c;
            <span style="color: #AE5825;">if</span> (c == <span style="color: #5A7644;">'\n'</span>) {
                <span style="color: #AE5825;">break</span>;
            }
        } <span style="color: #AE5825;">else</span> <span style="color: #AE5825;">if</span> (rc == 0) {
            *ptr = 0;
            <span style="color: #AE5825;">return</span> (n-1);
        } <span style="color: #AE5825;">else</span> {
            <span style="color: #AE5825;">if</span> (errno == EINTR) {
                <span style="color: #AE5825;">goto</span> <span style="color: #86453A;">again</span>;
            }
            <span style="color: #AE5825;">return</span> (-1);
        }
    }
    *ptr = 0;
    <span style="color: #AE5825;">return</span> (n);
}
</pre>
</div>
</li>
</ul>
</li>
<li>上面的readline在每个byte上面调用read,非常的没有效率,下面是我们实现的一个较
为高效的readline版本
<div class="org-src-container">

<pre class="src src-c"><span style="color: #AE5825;">static</span> <span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #46657B;">read_cnt</span>;
<span style="color: #AE5825;">static</span> <span style="color: #C6B032; font-style: italic;">char</span> *<span style="color: #46657B;">read_ptr</span>;
<span style="color: #AE5825;">static</span> <span style="color: #C6B032; font-style: italic;">char</span> <span style="color: #46657B;">read_buf</span>[MAXLINE];

<span style="color: #AE5825;">static</span> <span style="color: #C6B032; font-style: italic;">ssize_t</span>
<span style="color: #C6B032;">my_read</span>(<span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #46657B;">fd</span>, <span style="color: #C6B032; font-style: italic;">char</span> *<span style="color: #46657B;">ptr</span>) {
    <span style="color: #AE5825;">if</span> (read_cnt &lt;= 0) {
    <span style="color: #86453A;">again</span>:
        <span style="color: #AE5825;">if</span> ((read_cnt == read(fd, read_buf, <span style="color: #AE5825;">sizeof</span>(read_buf))) &lt; 0) {
            <span style="color: #AE5825;">if</span> (errno == EINTR) {
                <span style="color: #AE5825;">goto</span> <span style="color: #86453A;">again</span>;
            }
            <span style="color: #AE5825;">return</span> (-1);
        } <span style="color: #AE5825;">else</span> <span style="color: #AE5825;">if</span> (read_cnt == 0) {
            <span style="color: #AE5825;">return</span> (0);
        }
        read_ptr = read_buf;
    }

    read_cnt--;
    *ptr = *read_ptr++;
    <span style="color: #AE5825;">return</span> (1);
}

<span style="color: #C6B032; font-style: italic;">ssize_t</span>
<span style="color: #C6B032;">readline</span>(<span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #46657B;">fd</span>, <span style="color: #C6B032; font-style: italic;">void</span> *<span style="color: #46657B;">vptr</span>, <span style="color: #C6B032; font-style: italic;">size_t</span> <span style="color: #46657B;">maxlen</span>) {
    <span style="color: #C6B032; font-style: italic;">ssize_t</span> <span style="color: #46657B;">n</span>, <span style="color: #46657B;">rc</span>;
    <span style="color: #C6B032; font-style: italic;">char</span>    <span style="color: #46657B;">c</span>, *<span style="color: #46657B;">ptr</span>;

    ptr = vptr;
    <span style="color: #AE5825;">for</span> (n = 1; n &lt; maxlen; n++) {
        <span style="color: #AE5825;">if</span> ((rc = my_read(fd, &amp;c)) == 1) {
            *ptr++ = c;
            <span style="color: #AE5825;">if</span> (c == <span style="color: #5A7644;">'\n'</span>) {
                <span style="color: #AE5825;">break</span>;
            }
        } <span style="color: #AE5825;">else</span> <span style="color: #AE5825;">if</span> (rc == 0) {
            *ptr = 0;
            <span style="color: #AE5825;">return</span> (n-1);
        } <span style="color: #AE5825;">else</span> {
            <span style="color: #AE5825;">return</span> (-1);
        }
    }

    *ptr = 0;
    <span style="color: #AE5825;">return</span> (n);
}


<span style="color: #C6B032; font-style: italic;">ssize_t</span>
<span style="color: #C6B032;">readlinebuf</span>(<span style="color: #C6B032; font-style: italic;">void</span> **<span style="color: #46657B;">vptrptr</span>) {
    <span style="color: #AE5825;">if</span> (read_cn) {
        *vptrptr = read_ptr;
    }
    <span style="color: #AE5825;">return</span> (read_cn);
}
</pre>
</div>
</li>
<li>my_read是读取MAXLINE的char才退出
</li>
<li>readline函数这次没有调用read,而调用了my_read,就搞笑了很多
</li>
<li>一个新的函数redlinebuf暴露了内部buffer的state,所以调用者可以check这个state,
然后确定是否有新数据.
</li>
<li>鉴于使用了static变量,所以reentrant是做不到了,threadsafe更不可能.
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

         <!-- Disqus Comment BEGIN -->
          <div id="disqus_thread"></div>
          <script type="text/javascript">
              var disqus_shortname = 'harrifeng';

              (function() {
                  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
              })();
          </script>
          <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

         <!-- Disqus Comment END -->
</div>
</body>
</html>
