<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Chapter 7: Socket Options</title>
<!-- 2014-07-18 Fri 16:04 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="your name" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>

         <link href="http://fonts.googleapis.com/css?family=Droid+Sans+Mono|Galdeano|Open+Sans:600italic,400,600|Roboto+Condensed:400,700" rel="stylesheet" type="text/css">
         <link rel="stylesheet" type="text/css" href="/static/css/main.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="http://harrifeng.github.io/sitemap.html"> UP </a>
 |
 <a accesskey="H" href="http://harrifeng.github.io/index.html"> HOME </a>
</div><div id="preamble" class="status">

         <div id="header">
            <div id="header-top">
                <div id="blog-title">Harrifeng's Path</div>
                <div id="blog-sub-title">纸上得来终觉浅,绝知此事要Coding</div>
            </div>
            <div id="nav">
                <ul>
                    <li><a href="/">首页</a></li>
                    <li><a href="/notes.html">读书笔记</a></li>
                    <li><a href="/algo.html">算法</a></li>
                    <li><a href="/about.html">About Me</a></li>
                    <li>
                    </li>
                </ul>
            </div>
         </div>
</div>
<div id="content">
<h1 class="title">Chapter 7: Socket Options</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Socket Options</a>
<ul>
<li><a href="#sec-1-1">Introduction</a></li>
<li><a href="#sec-1-2">getsockopt and setsockopt Function</a></li>
<li><a href="#sec-1-3">Checking if an Option Is Supported and Obtaining the Default</a></li>
<li><a href="#sec-1-4">Socket States</a></li>
<li><a href="#sec-1-5">Generic Socket Options</a>
<ul>
<li><a href="#sec-1-5-1">SO_BROADCAST Socket Option</a></li>
<li><a href="#sec-1-5-2">SO_DEBUG Socket Option</a></li>
<li><a href="#sec-1-5-3">SO_DONTROUTE Socket Option</a></li>
<li><a href="#sec-1-5-4">SO_ERROR Socket Option</a></li>
<li><a href="#sec-1-5-5">SO_KEEPALIVE Socket Option</a></li>
<li><a href="#sec-1-5-6">SO_LINGER Socket Option</a></li>
<li><a href="#sec-1-5-7">SO_OOBINLINE Socket Option</a></li>
<li><a href="#sec-1-5-8">SO_RECVBUF and SO_SNDBUF Socket Option</a></li>
<li><a href="#sec-1-5-9">SO_RECVLOWAT and SO_SENDLOWAT Socket Option</a></li>
<li><a href="#sec-1-5-10">SO_RCVTIMEO and SO_SNDTIMEO Socket Options</a></li>
<li><a href="#sec-1-5-11">SO_REUSEDADDR and SO_REUSEPORT Socket Options</a></li>
<li><a href="#sec-1-5-12">SO_TYPE Socket Option</a></li>
<li><a href="#sec-1-5-13">SO_USELOOPBACK Socket Option</a></li>
</ul>
</li>
<li><a href="#sec-1-6">IPv4 Socket Options</a>
<ul>
<li><a href="#sec-1-6-1">IP_HDRINCL Socket Option</a></li>
<li><a href="#sec-1-6-2">IP_OPTIONS Socket Option</a></li>
<li><a href="#sec-1-6-3">IP_RECVDSTADDR Socket Option</a></li>
<li><a href="#sec-1-6-4">IP_RECVIF Socket Option</a></li>
<li><a href="#sec-1-6-5">IP_TOS Socket Option</a></li>
<li><a href="#sec-1-6-6">IP_TTL Socket Option</a></li>
</ul>
</li>
<li><a href="#sec-1-7">ICMPv6 Socket Option</a>
<ul>
<li><a href="#sec-1-7-1">ICMP6_FILTER Socket Option</a></li>
</ul>
</li>
<li><a href="#sec-1-8">IPv6 Socket Options</a></li>
<li><a href="#sec-1-9">TCP Socket Options</a>
<ul>
<li><a href="#sec-1-9-1">TCP_MAXSEG Socket Option</a></li>
<li><a href="#sec-1-9-2">TCP_NODELAY Socket Option</a></li>
</ul>
</li>
<li><a href="#sec-1-10">SCTP Socket Options</a></li>
<li><a href="#sec-1-11">fcntl Function</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Socket Options</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Introduction</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>有如下几种方法来设置socket的参数:
<ul class="org-ul">
<li>getsockopt()和setsockopt()
</li>
<li>fcntl()
</li>
<li>ioctl()
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">getsockopt and setsockopt Function</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>两个函数的声明如下:
<div class="org-src-container">

<pre class="src src-c"><span style="color: #4856F7; font-weight: bold;">#include</span> <span style="color: #A2925E;">&lt;syt/socket.h&gt;</span>

<span style="color: #DADADA;">int</span> <span style="color: #A1A1FF;">getsockopt</span>(<span style="color: #DADADA;">int</span> <span style="color: #C1C144;">sockfd</span>, <span style="color: #DADADA;">int</span> <span style="color: #C1C144;">level</span>, <span style="color: #DADADA;">int</span> <span style="color: #C1C144;">optname</span>, <span style="color: #DADADA;">void</span> *<span style="color: #C1C144;">optval</span>, <span style="color: #DADADA;">socklen_t</span>* <span style="color: #C1C144;">optlen</span>);

<span style="color: #DADADA;">int</span> <span style="color: #A1A1FF;">setsockopt</span>(<span style="color: #DADADA;">int</span> <span style="color: #C1C144;">sockfd</span>, <span style="color: #DADADA;">int</span> <span style="color: #C1C144;">level</span>, <span style="color: #DADADA;">int</span> <span style="color: #C1C144;">optname</span>, <span style="color: #4856F7; font-weight: bold;">const</span> <span style="color: #DADADA;">void</span>* <span style="color: #C1C144;">optval</span>, <span style="color: #DADADA;">socklen_t</span> <span style="color: #C1C144;">optlen</span>);
</pre>
</div>
</li>
<li>sockfd参数必须是一个已经open的socket descriptor.
</li>
<li>level参数指定了协议层(比如,IPv4, IPv6还是TCP, SCTP)
</li>
<li>optname是需要访问的选择的名字(比如, level层的sender buffer size大小)
</li>
<li>optval指向一个变量的指针,这个变量的值是由setsockopt设置的,可由getsockopt来
读取.
</li>
<li>optlen对于getsockopt()返回optval的最大长度, 对于setsockopt, 设置optval的最
大长度
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Checking if an Option Is Supported and Obtaining the Default</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>我们下面来写一个函数来测试哪些socket option被当前系统所支持,如果支持,就读取
其默认值.
<div class="org-src-container">

<pre class="src src-c"><span class="linenr"> 1: </span><span style="color: #4856F7; font-weight: bold;">#include</span>   <span style="color: #A2925E;">"unp.h"</span>
<span class="linenr"> 2: </span><span style="color: #4856F7; font-weight: bold;">#include</span>   <span style="color: #A2925E;">&lt;netinet/tcp.h&gt;</span>     <span style="color: #ed5b15;">/* </span><span style="color: #ed5b15;">for TCP_xxx defines </span><span style="color: #ed5b15;">*/</span>
<span class="linenr"> 3: </span>
<span class="linenr"> 4: </span><span style="color: #4856F7; font-weight: bold;">union</span> <span style="color: #DADADA;">val</span> {
<span class="linenr"> 5: </span>    <span style="color: #DADADA;">int</span>                  <span style="color: #C1C144;">i_val</span>;
<span class="linenr"> 6: </span>    <span style="color: #DADADA;">long</span>                 <span style="color: #C1C144;">l_val</span>;
<span class="linenr"> 7: </span>    <span style="color: #4856F7; font-weight: bold;">struct</span> <span style="color: #DADADA;">linger</span>        <span style="color: #C1C144;">linger_val</span>;
<span class="linenr"> 8: </span>    <span style="color: #4856F7; font-weight: bold;">struct</span> <span style="color: #DADADA;">timeval</span>       <span style="color: #C1C144;">timeval_val</span>;
<span class="linenr"> 9: </span>}<span style="color: #C1C144;">val</span>;
<span class="linenr">10: </span>
<span class="linenr">11: </span><span style="color: #4856F7; font-weight: bold;">static</span> <span style="color: #DADADA;">char</span> *<span style="color: #A1A1FF;">sock_str_flag</span>(<span style="color: #4856F7; font-weight: bold;">union</span> <span style="color: #DADADA;">val</span>*, <span style="color: #DADADA;">int</span>);
<span class="linenr">12: </span><span style="color: #4856F7; font-weight: bold;">static</span> <span style="color: #DADADA;">char</span> *<span style="color: #A1A1FF;">sock_str_int</span>(<span style="color: #4856F7; font-weight: bold;">union</span> <span style="color: #DADADA;">val</span>*, <span style="color: #DADADA;">int</span>);
<span class="linenr">13: </span><span style="color: #4856F7; font-weight: bold;">static</span> <span style="color: #DADADA;">char</span> *<span style="color: #A1A1FF;">sock_str_linger</span>(<span style="color: #4856F7; font-weight: bold;">union</span> <span style="color: #DADADA;">val</span>*, <span style="color: #DADADA;">int</span>);
<span class="linenr">14: </span><span style="color: #4856F7; font-weight: bold;">static</span> <span style="color: #DADADA;">char</span> *<span style="color: #A1A1FF;">sock_str_timeval</span>(<span style="color: #4856F7; font-weight: bold;">union</span> <span style="color: #DADADA;">val</span>*, <span style="color: #DADADA;">int</span>);
<span class="linenr">15: </span>
<span class="linenr">16: </span><span style="color: #4856F7; font-weight: bold;">struct</span> <span style="color: #DADADA;">sock_opts</span>{
<span class="linenr">17: </span>    <span style="color: #4856F7; font-weight: bold;">const</span>  <span style="color: #DADADA;">char</span>*   <span style="color: #C1C144;">opt_str</span>;
<span class="linenr">18: </span>    <span style="color: #DADADA;">int</span>            <span style="color: #C1C144;">opt_level</span>;
<span class="linenr">19: </span>    <span style="color: #DADADA;">int</span>            <span style="color: #C1C144;">opt_name</span>;
<span class="linenr">20: </span>    <span style="color: #DADADA;">char</span>           *(*<span style="color: #A1A1FF;">opt_val_str</span>) (<span style="color: #4856F7; font-weight: bold;">union</span> <span style="color: #DADADA;">val</span> *, <span style="color: #DADADA;">int</span>);
<span class="linenr">21: </span>} <span style="color: #C1C144;">sock_opts</span>[] = {
<span class="linenr">22: </span>    { <span style="color: #A2925E;">"SO_BROADCAST"</span>,        SOL_SOCKET, SO_BROADCAST,   sock_str_flag },
<span class="linenr">23: </span>    { <span style="color: #A2925E;">"SO_DEBUG"</span>,            SOL_SOCKET, SO_DEBUG,       sock_str_flag },
<span class="linenr">24: </span>    { <span style="color: #A2925E;">"SO_DONTROUTE"</span>,        SOL_SOCKET, SO_DONTROUTE,   sock_str_flag },
<span class="linenr">25: </span>    { <span style="color: #A2925E;">"SO_ERROR"</span>,            SOL_SOCKET, SO_ERROR,       sock_str_int },
<span class="linenr">26: </span>    { <span style="color: #A2925E;">"SO_KEEPALIVE"</span>,        SOL_SOCKET, SO_KEEPALIVE,   sock_str_flag },
<span class="linenr">27: </span>    { <span style="color: #A2925E;">"SO_LINGER"</span>,           SOL_SOCKET, SO_LINGER,      sock_str_linger },
<span class="linenr">28: </span>    { <span style="color: #A2925E;">"SO_OOBINLINE"</span>,        SOL_SOCKET, SO_OOBINLINE,   sock_str_flag },
<span class="linenr">29: </span>    { <span style="color: #A2925E;">"SO_RCVBUF"</span>,           SOL_SOCKET, SO_RCVBUF,      sock_str_int },
<span class="linenr">30: </span>    { <span style="color: #A2925E;">"SO_SNDBUF"</span>,           SOL_SOCKET, SO_SNDBUF,      sock_str_int },
<span class="linenr">31: </span>    { <span style="color: #A2925E;">"SO_RCVLOWAT"</span>,         SOL_SOCKET, SO_RCVLOWAT,    sock_str_int },
<span class="linenr">32: </span>    { <span style="color: #A2925E;">"SO_SNDLOWAT"</span>,         SOL_SOCKET, SO_SNDLOWAT,    sock_str_int },
<span class="linenr">33: </span>    { <span style="color: #A2925E;">"SO_RCVTIMEO"</span>,         SOL_SOCKET, SO_RCVTIMEO,    sock_str_timeval },
<span class="linenr">34: </span>    { <span style="color: #A2925E;">"SO_SNDTIMEO"</span>,         SOL_SOCKET, SO_SNDTIMEO,    sock_str_timeval },
<span class="linenr">35: </span>    { <span style="color: #A2925E;">"SO_REUSEADDR"</span>,        SOL_SOCKET, SO_REUSEADDR,   sock_str_flag },
<span class="linenr">36: </span><span style="color: #4856F7; font-weight: bold;">#ifdef</span> SO_REUSEPORT
<span class="linenr">37: </span>    { <span style="color: #A2925E;">"SO_REUSEPORT"</span>,        SOL_SOCKET, SO_REUSEPORT,   sock_str_flag },
<span class="linenr">38: </span><span style="color: #4856F7; font-weight: bold;">#else</span>
<span class="linenr">39: </span>    { <span style="color: #A2925E;">"SO_REUSEPORT"</span>,        0,          0,              <span style="color: #DF7921; font-weight: bold;">NULL</span> },
<span class="linenr">40: </span><span style="color: #4856F7; font-weight: bold;">#endif</span>
<span class="linenr">41: </span>    { <span style="color: #A2925E;">"SO_TYPE"</span>,             SOL_SOCKET, SO_TYPE,        sock_str_int },
<span class="linenr">42: </span>    { <span style="color: #A2925E;">"SO_USELOOPBACK"</span>,      SOL_SOCKET, SO_USELOOPBACK, sock_str_flag },
<span class="linenr">43: </span>    { <span style="color: #A2925E;">"IP_TOS"</span>,              IPPROTO_IP, IP_TOS,         sock_str_int },
<span class="linenr">44: </span>    { <span style="color: #A2925E;">"IP_TTL"</span>,              IPPROTO_IP, IP_TTL,         sock_str_int },
<span class="linenr">45: </span>    { <span style="color: #A2925E;">"IPV6_DONTFRAG"</span>,       IPPROTO_IPV6,IPV6_DONTFRAG, sock_str_flag },
<span class="linenr">46: </span>    { <span style="color: #A2925E;">"IPV6_UNICAST_HOPS"</span>,   IPPROTO_IPV6,IPV6_UNICAST_HOPS,sock_str_int },
<span class="linenr">47: </span>    { <span style="color: #A2925E;">"IPV6_V6ONLY"</span>,         IPPROTO_IPV6,IPV6_V6ONLY,   sock_str_flag },
<span class="linenr">48: </span>    { <span style="color: #A2925E;">"TCP_MAXSEG"</span>,          IPPROTO_TCP,TCP_MAXSEG,     sock_str_int },
<span class="linenr">49: </span>    { <span style="color: #A2925E;">"TCP_NODELAY"</span>,         IPPROTO_TCP,TCP_NODELAY,    sock_str_flag },
<span class="linenr">50: </span>    { <span style="color: #A2925E;">"SCTP_AUTOCLOSE"</span>,      IPPROTO_SCTP,SCTP_AUTOCLOSE,sock_str_int },
<span class="linenr">51: </span>    { <span style="color: #A2925E;">"SCTP_MAXBURST"</span>,       IPPROTO_SCTP,SCTP_MAXBURST, sock_str_int },
<span class="linenr">52: </span>    { <span style="color: #A2925E;">"SCTP_MAXSEG"</span>,         IPPROTO_SCTP,SCTP_MAXSEG,   sock_str_int },
<span class="linenr">53: </span>    { <span style="color: #A2925E;">"SCTP_NODELAY"</span>,        IPPROTO_SCTP,SCTP_NODELAY,  sock_str_flag },
<span class="linenr">54: </span>    { <span style="color: #DF7921; font-weight: bold;">NULL</span>,                  0,          0,              <span style="color: #DF7921; font-weight: bold;">NULL</span> }
<span class="linenr">55: </span>};
</pre>
</div>
</li>
<li>line 4-9: 我们的getsockopt函数可能会返回四种基本类型:int, long, timeval{},
linger{},所以我们的union也设置成这四种类型,一旦指针指向对应位置,就可以方便获取
实际值.
</li>
<li>line 11-14: 函数声明,这四个函数用来把相应flag(或者int,或者linger,或者timeval)
转换成易读的字符串, 下面是其中sock_str_flag的实现
<div class="org-src-container">

<pre class="src src-c"><span style="color: #4856F7; font-weight: bold;">static</span> <span style="color: #DADADA;">char</span> <span style="color: #C1C144;">strres</span>[128];

<span style="color: #4856F7; font-weight: bold;">static</span> <span style="color: #DADADA;">char</span>* <span style="color: #A1A1FF;">sock_str_flag</span>(<span style="color: #4856F7; font-weight: bold;">union</span> <span style="color: #DADADA;">val</span>* <span style="color: #C1C144;">ptr</span>, <span style="color: #DADADA;">int</span> <span style="color: #C1C144;">len</span>) {
    <span style="color: #4856F7; font-weight: bold;">if</span> (len != <span style="color: #4856F7; font-weight: bold;">sizeof</span>(<span style="color: #DADADA;">int</span>)) {
        snprintf(strres, <span style="color: #4856F7; font-weight: bold;">sizeof</span>(strres), <span style="color: #A2925E;">"size (%d) ont sizeof(int)"</span>, len);
    } <span style="color: #4856F7; font-weight: bold;">else</span> {
        snprintf(strres, <span style="color: #4856F7; font-weight: bold;">sizeof</span>(strres),
                 <span style="color: #A2925E;">"%s"</span>, (ptr-&gt;i_val == 0) ? <span style="color: #A2925E;">"off"</span> : <span style="color: #A2925E;">"on"</span>);
    }
}
</pre>
</div>
</li>
<li>line 16-55:我们创建了结构体sock_opts, 然后把getsockopt()的所有四个参数(除了
fd)都写到这个结构体里面,注意,最后一行我们设置了全NULL,为了就是能够在使用的时候
知道"结构体到头了"
<div class="org-src-container">

<pre class="src src-c">{ <span style="color: #DF7921; font-weight: bold;">NULL</span>,                  0,          0,              <span style="color: #DF7921; font-weight: bold;">NULL</span> }
</pre>
</div>
</li>
<li>我们使用这个上面结构体的main代码如下:
<div class="org-src-container">

<pre class="src src-c"><span class="linenr"> 1: </span><span style="color: #DADADA;">int</span> <span style="color: #A1A1FF;">main</span>(<span style="color: #DADADA;">int</span> <span style="color: #C1C144;">argc</span>, <span style="color: #DADADA;">char</span> *<span style="color: #C1C144;">argv</span>[])
<span class="linenr"> 2: </span>{
<span class="linenr"> 3: </span>    <span style="color: #DADADA;">int</span>       <span style="color: #C1C144;">fd</span>;
<span class="linenr"> 4: </span>    <span style="color: #DADADA;">socklen_t</span> <span style="color: #C1C144;">len</span>;
<span class="linenr"> 5: </span>    <span style="color: #4856F7; font-weight: bold;">struct</span> <span style="color: #DADADA;">sock_opts</span>* <span style="color: #C1C144;">ptr</span>;
<span class="linenr"> 6: </span>
<span class="linenr"> 7: </span>    <span style="color: #4856F7; font-weight: bold;">for</span> (ptr = sock_opts; ptr-&gt;opt_str != <span style="color: #DF7921; font-weight: bold;">NULL</span>; ptr++) {
<span class="linenr"> 8: </span>        printf(<span style="color: #A2925E;">"%s: "</span>, ptr-&gt;opt_str);
<span class="linenr"> 9: </span>        <span style="color: #4856F7; font-weight: bold;">if</span> (ptr-&gt;opt_val_str == <span style="color: #DF7921; font-weight: bold;">NULL</span>) {
<span class="linenr">10: </span>            printf(<span style="color: #A2925E;">"(undefined) \n"</span>);
<span class="linenr">11: </span>        } <span style="color: #4856F7; font-weight: bold;">else</span> {
<span class="linenr">12: </span>            <span style="color: #4856F7; font-weight: bold;">switch</span>(ptr-&gt;opt_level) {
<span class="linenr">13: </span>            <span style="color: #4856F7; font-weight: bold;">case</span> SOL_SOCKET:
<span class="linenr">14: </span>            <span style="color: #4856F7; font-weight: bold;">case</span> IPPROTO_IP:
<span class="linenr">15: </span>            <span style="color: #4856F7; font-weight: bold;">case</span> IPPROTO_TCP:
<span class="linenr">16: </span>                fd = Socket(AF_INET, SOCK_STREAM, 0);
<span class="linenr">17: </span>                <span style="color: #4856F7; font-weight: bold;">break</span>;
<span class="linenr">18: </span><span style="color: #4856F7; font-weight: bold;">#ifdef</span> IPV6
<span class="linenr">19: </span>            <span style="color: #4856F7; font-weight: bold;">case</span> IPPROTO_IPV6:
<span class="linenr">20: </span>                fd = Socket(AF_INET6, SOCK_STREAM, 0);
<span class="linenr">21: </span>                <span style="color: #4856F7; font-weight: bold;">break</span>;
<span class="linenr">22: </span><span style="color: #4856F7; font-weight: bold;">#endif</span>
<span class="linenr">23: </span><span style="color: #4856F7; font-weight: bold;">#ifdef</span> IPPROTO_SCTP
<span class="linenr">24: </span>            <span style="color: #4856F7; font-weight: bold;">case</span> IPPROTO_SCTP:
<span class="linenr">25: </span>                fd = Socket(AF_INET, SOCK_SEQPACKET, IPPROTO_SCTP);
<span class="linenr">26: </span>                <span style="color: #4856F7; font-weight: bold;">break</span>;
<span class="linenr">27: </span><span style="color: #4856F7; font-weight: bold;">#endif</span>
<span class="linenr">28: </span>            <span style="color: #4856F7; font-weight: bold;">default</span>:
<span class="linenr">29: </span>                err_quit(<span style="color: #A2925E;">"Can't create fd for level %d\n"</span>, ptr-&gt;opt_level);
<span class="linenr">30: </span>            }
<span class="linenr">31: </span>            len = <span style="color: #4856F7; font-weight: bold;">sizeof</span>(val);
<span class="linenr">32: </span>            <span style="color: #4856F7; font-weight: bold;">if</span> (getsockopt(fd, ptr-&gt;opt_level, ptr-&gt;opt_name,
<span class="linenr">33: </span>                           &amp;val, &amp;len) == -1) {
<span class="linenr">34: </span>                err_ret(<span style="color: #A2925E;">"getsockopt error"</span>);
<span class="linenr">35: </span>            } <span style="color: #4856F7; font-weight: bold;">else</span> {
<span class="linenr">36: </span>                printf(<span style="color: #A2925E;">"default = %s\n"</span>, (*ptr-&gt;opt_val_str) (&amp;val, len));
<span class="linenr">37: </span>            }
<span class="linenr">38: </span>            close(fd);
<span class="linenr">39: </span>        }
<span class="linenr">40: </span>    }
<span class="linenr">41: </span>    <span style="color: #4856F7; font-weight: bold;">return</span> 0;
<span class="linenr">42: </span>}
</pre>
</div>
</li>
<li>opt_val_str是一个函数指针,会返回字符串然, main函数会通过line 36把默认值写入
到standard output
</li>
<li>在Ubuntu上面测到的结果如下(某些const不支持,删掉了)
<div class="org-src-container">

<pre class="src src-sh">hfeng@ubuntu-server64:~/tmp/unpbook/sockopt$ ./checkopts
SO_BROADCAST: default = off
SO_DEBUG: default = off
SO_DONTROUTE: default = off
SO_ERROR: default = 0
SO_KEEPALIVE: default = off
SO_LINGER: default = l_onoff = 0, l_linger = 0
SO_OOBINLINE: default = off
SO_RCVBUF: default = 87380
SO_SNDBUF: default = 16384
SO_RCVLOWAT: default = 1
SO_SNDLOWAT: default = 1
SO_RCVTIMEO: default = 0 sec, 0 usec
SO_SNDTIMEO: default = 0 sec, 0 usec
SO_REUSEADDR: default = off
SO_REUSEPORT: (undefined)
SO_TYPE: default = 1
IP_TOS: default = 0
IP_TTL: default = 64
IPV6_DONTFRAG: (undefined)
IPV6_UNICAST_HOPS: default = 64
IPV6_V6ONLY: default = off
TCP_MAXSEG: default = 536
TCP_NODELAY: default = off
SCTP_AUTOCLOSE: (undefined)
SCTP_MAXBURST: (undefined)
SCTP_MAXSEG: (undefined)
SCTP_NODELAY: (undefined)
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">Socket States</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>connected TCP socket必须从listening socket下面继承下面这些option
<ul class="org-ul">
<li>SO_DBUG
</li>
<li>SO_DONTROUTE
</li>
<li>SO_KEEPALIVE
</li>
<li>SO_LINGER
</li>
<li>SO_OOBINLINE
</li>
<li>SO_RECVBUF
</li>
<li>SO_RCVLOWAT
</li>
<li>SO_SNDBUF
</li>
<li>SO_SNDLOWAT
</li>
<li>TCP_MAXSEG
</li>
<li>TCP_NODELAY
</li>
</ul>
</li>
<li>为了保证上面的参数能在connected socket里面出现,我们必须在listening socket的
时候就设置这些参数
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">Generic Socket Options</h3>
<div class="outline-text-3" id="text-1-5">
<ul class="org-ul">
<li>虽然我们前面说到了generic socket option,但是其实这些socket并不是那么的"generic",
它们顶多只能对"几种"协议有效,有些甚至只对一红协议有效
</li>
</ul>
</div>
<div id="outline-container-sec-1-5-1" class="outline-4">
<h4 id="sec-1-5-1">SO_BROADCAST Socket Option</h4>
<div class="outline-text-4" id="text-1-5-1">
<ul class="org-ul">
<li>打开或者关闭进程发送broadcast message的功能.一般只能在datagram socket种实现,并且
要求底层的网络支持广播(SCTP和TCP这种point-to-point的协议就不行)
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-5-2" class="outline-4">
<h4 id="sec-1-5-2">SO_DEBUG Socket Option</h4>
<div class="outline-text-4" id="text-1-5-2">
<ul class="org-ul">
<li>设置了这个选项之后,kernel会跟踪TCP所有的packet,然后保存在kernel的buffer里面,我们
可以通过trpt来读取
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-5-3" class="outline-4">
<h4 id="sec-1-5-3">SO_DONTROUTE Socket Option</h4>
<div class="outline-text-4" id="text-1-5-3">
<ul class="org-ul">
<li>通常用来强制从某个interface传出数据,而不经过路由器的路由表
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-5-4" class="outline-4">
<h4 id="sec-1-5-4">SO_ERROR Socket Option</h4>
<div class="outline-text-4" id="text-1-5-4">
<ul class="org-ul">
<li>当socket上面发生错误的时候, Berkeley系列的kernel会设置so_error为一个Unix
      Exxx value.这叫做socket's pending error.进程会马上以如下两种方式得知错误:
<ol class="org-ol">
<li>如果进程被block在select里面,那么select会马上返回,errno肯定就设置了
</li>
<li>如果在使用signal-driven I/O的话,那么系统会对进程发送SIGIO信号
</li>
</ol>
</li>
<li>得知错误后,进程就可以从"出现SO_ERROR错误的socket"里面读取so_error的值
</li>
<li>这个参数是我们遇到的第一个"可以读取"但是"不可以设置"的参数
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-5-5" class="outline-4">
<h4 id="sec-1-5-5">SO_KEEPALIVE Socket Option</h4>
<div class="outline-text-4" id="text-1-5-5">
<ul class="org-ul">
<li>如果设置了这个参数,那么当TCP连接建立,但是很久都没有通信的情况下,一方会发送
一keep-alive probe给对方. keep-alive probe是一种对方必须回复的TCP segment.
一般对方会有如下反应:
<ol class="org-ol">
<li>返回一个ACK,说明一切正常.那么这次成功的probe是不会通知给上层应用的
</li>
<li>返回一个RST,说明对方重启或者死机.socket's pending error会设置成ECONNRESET
</li>
<li>如果长期不返回,那么就会不停的发送probe(不同实现不一样,Berkeley会最终在11分
15秒的情况下下结论,对方无法连通,放弃尝试):
<ul class="org-ul">
<li>如果所有的尝试都失败,那么就设置错误为ETIMEOUT(超时)
</li>
<li>如果socket收到来自ICMP的错误,一般来说是"host unreachable",那么我们也就
设置错误为EHOSTUNREACH
</li>
</ul>
</li>
</ol>
</li>
<li>这个参数一般是server在应用(虽然client也可以用),因为server在大部分的时间都是在
等待client要求什么服务
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-5-6" class="outline-4">
<h4 id="sec-1-5-6">SO_LINGER Socket Option</h4>
<div class="outline-text-4" id="text-1-5-6">
<ul class="org-ul">
<li>这个参数指导了close如何对待connection-oriented 协议(比如TCP, SCTP但是没有UDP)
</li>
<li>默认情况下close会马上返回(甚至不等四次挥手完成).但是如果在socket send buffer
里面依然有数据的情况下,会尽量完成给对方的传递, SO_LINGER就是改变这种默认设置的
</li>
<li>调用setsockopt的时候会设置linger结构体的两个部分:
<div class="org-src-container">

<pre class="src src-c"><span style="color: #4856F7; font-weight: bold;">struct</span> <span style="color: #DADADA;">linger</span> {
    <span style="color: #DADADA;">int</span>  <span style="color: #C1C144;">l_onof</span>;         <span style="color: #ed5b15;">/* </span><span style="color: #ed5b15;">0=off, nonzero=on </span><span style="color: #ed5b15;">*/</span>
    <span style="color: #DADADA;">int</span>  <span style="color: #C1C144;">l_linger</span>;       <span style="color: #ed5b15;">/* </span><span style="color: #ed5b15;">linger time, POSIX specifies units as seconds </span><span style="color: #ed5b15;">*/</span>
};
</pre>
</div>
<ol class="org-ol">
<li>如果l_onoff是0,那么这个option是关闭的.l_linger不会被使用,close还是默认
的马上关闭
</li>
<li>如果l_onoff非0, 而且l_linger是0的话,那么close的同时,所有send buffer里面
的数据都丢弃掉:这样的话,常规的四次握手就全部不能实施了!这会避免TIME_WAIT,
我马上知道TIME_WAIT有两个作用1防止最后的FIN丢失2防止同一个线路上面在2MSL
内新建了其他的connection.第2点就无法避免了
</li>
<li>如果lonff非0, 而且l_linger非0的话.就是依然会执行四次挥手,只不过现在会加上
一个时间限制:如果在l_linger秒内依然完成不了的话,那么会强制返回.
</li>
</ol>
</li>
<li>下面我们来总结一下close的几种返回情况:
<ol class="org-ol">
<li>默认情况下:
<ul class="org-ul">
<li>client的close是直接返回(发送完FIN就完了,不等ACK回来),server端也是一样的.
</li>
<li>存在这么一种可能:client的FIN发送给了server,但是server很忙,所以FIN就等待
在server的receive buffer了,在server读取到这个FIN之前,很可能server就crash
了.这个时候client永远无法得知server的情况
</li>
<li>值得注意的是ACK是系统返回的,不是server进程.所以即便ACK返回了,数据可能还是
在server的receive buffer里面.
</li>
</ul>
</li>
<li>使用SO_LINGER,并且设置linger time为足够大正数的情况:
<ul class="org-ul">
<li>close是等到ACK回来以后才返回的.
</li>
<li>但是ACK只是证明了server host接收到这个FIN,但是并不意味这server进程读取到了
这个FIN
</li>
</ul>
</li>
<li>使用SO_LINGER,linger time设置的不够大:
<ul class="org-ul">
<li>close等了很短的linger time时间就返回了:因为没等到ACK, close返回了-1,而且
errno设置为了EWOULDBLOCK
</li>
</ul>
</li>
</ol>
</li>
<li>总结起来就是SO_LINGER只能让我们知道server host收到了FIN,但不代表server读取成功了
</li>
<li>client可以使用shutdonw来先half close,然后read的办法来确认对方的server进程读取
到了你的FIN
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-5-7" class="outline-4">
<h4 id="sec-1-5-7">SO_OOBINLINE Socket Option</h4>
<div class="outline-text-4" id="text-1-5-7">
<ul class="org-ul">
<li>设置这个参数后, out-of-band 数据会放到normal input queue
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-5-8" class="outline-4">
<h4 id="sec-1-5-8">SO_RECVBUF and SO_SNDBUF Socket Option</h4>
<div class="outline-text-4" id="text-1-5-8">
<ul class="org-ul">
<li>我们前面提起过TCP,UDP都有自己的send buffer和receive buffer:
<ul class="org-ul">
<li>对于TCP来说,由于通知窗口(advertised window)的存在,receive buffer不会接受到过多
的信息的,如果发送方执意ignore通知窗口,发送过多的信息,那么会被接收方丢弃
</li>
<li>UDP没有flow control的概念,其会随意发送,超过receive buffer的内容会被丢弃,UDP
发送过快,甚至会溢出send buffer,溢出部分也是被丢弃.
</li>
</ul>
</li>
<li>SO_RECVBUF和SO_SNDBUF就是用来设置receive buffer和send buffer的默认值的.需要注意
的是:
<ul class="org-ul">
<li>send buffer要在client调用connect开始三次握手之前设置(因为windows scale参数会
在三次握手之前设置)
</li>
<li>receive buffer也要在server调用listen之前设置(也是因为windows scale 参数.我们
还记得第二章讲过windows scale参数是个新参数,比如client和server都确认对方支持才
可以使用)
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-5-9" class="outline-4">
<h4 id="sec-1-5-9">SO_RECVLOWAT and SO_SENDLOWAT Socket Option</h4>
<div class="outline-text-4" id="text-1-5-9">
<ul class="org-ul">
<li>前面我们讲过每个send, receive buffer都有一个low water mark.(select会使用,select
判断一个socket是否可读,就看其receive buffer的值是不是大与这个low-water mark要大)
</li>
<li>receive low-water mark的默认是值一般是1 (对TCP,UDP都是)
</li>
<li>send low-water mark的默认值对TCP来说是2048
</li>
<li>send low-water mark对于UDP来说意义不大,因为它不会保留一份数据在sender buffer里面
(防止发送失败而重发).所以我们的的send low-water mark只要小于 send buffer size,
那么我们就一直可写(超过一定数据量就可以发送,太少了不值当). 其实UDP只有send bufer
size和send low-warter mark的概念,其并没有send buffer&#x2026;(囧)
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-5-10" class="outline-4">
<h4 id="sec-1-5-10">SO_RCVTIMEO and SO_SNDTIMEO Socket Options</h4>
<div class="outline-text-4" id="text-1-5-10">
<ul class="org-ul">
<li>这两个参数为我们的socket设置了发送和接受的timeout时间. 其数据类型为timeval(和select
使用的一样,精度为ms)
</li>
<li>SO_RCVTIMEO为如下五个函数设置了timeout:
<ul class="org-ul">
<li>read()
</li>
<li>readv()
</li>
<li>recdv()
</li>
<li>recvfrom()
</li>
<li>recvmsg()
</li>
</ul>
</li>
<li>SO_SNDTIMEO为如下五个参数设置了timeout:
<ul class="org-ul">
<li>write()
</li>
<li>writev()
</li>
<li>send()
</li>
<li>sendto()
</li>
<li>sendmsg()
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-5-11" class="outline-4">
<h4 id="sec-1-5-11">SO_REUSEDADDR and SO_REUSEPORT Socket Options</h4>
<div class="outline-text-4" id="text-1-5-11">
<ul class="org-ul">
<li>SO_REUSEDADDR 参数有如下四种用途:
<ol class="org-ol">
<li>允许一个listening server在已经有其他socket占用某个端口比如22,的情况下再
次在这个端口上建立一个socket.下面是模拟这个使用场景:
<ul class="org-ul">
<li>建立一个listening serveer
</li>
<li>一个connection request来了, fork一个child来处理这个client
</li>
<li>listening server经过一定时间运行关闭了.但是child依然在处理着来自client
的请求.
</li>
<li>listening server重新启动: 通常重启会失败的.因为在这个well-known(22)的
端口上面有其他应用了.但是我们在socket()和bind()之间加上设置这个SO_REUSEDADDR
的参数的话,我们就可以.
</li>
</ul>
</li>
<li>允许在某个server以wildcard IP运行在某个port的情况下, 以其他specific的IP
来增加新的server.注意我们这里第一次使用的是wildcard IP,第二次使用的是其
specific IP. 如果两次IP和端口都是一样的.那在TCP里面是绝对不可以的.下面
是使用场景模拟:
<ul class="org-ul">
<li>假设一个local host的IP地址为198.69.10.2, 但是其有两个IP aliase:
192.168.10.128和192.168.10.129
</li>
<li>第一个HTTP server会bind wildcard IP, 和端口20
</li>
<li>第二个HTTP server会bind 192.168.10.128 和端口20: 通常会bind失败,但是
加上参数SO_REUSEADDR在bind前面就不会失败了
</li>
<li>第三个HTTP server会bind 192.168.10.129 和端口20: 通常会bind失败,但是
加上参数SO_REUSEADDR在bind前面就不会失败了
</li>
</ul>
</li>
<li>允许一个进程bind的时候使用同样的port,只要IP不一样就可以.
</li>
<li>允许一个进程bind的时候使用同样的port,同样的IP.这个只有UDP支持.
</li>
</ol>
</li>
<li>还有一个很常见的情况就是前一个connection已经进入TIME_WAIT状态, 如果你不设置为
SO_REUSEADDR的话,即便前面一个connection已经马上确定要死了,但是你还是不能bind
到它的ip+port上面,要一直等到TIME_WAIT退出.
</li>
<li>BSD后期引入了SO_REUSEPORT,其功能在普通IP上面是SO_REUSEADDR的超集,除了
SO_REUSEADDR的全部功能外,还允许完全相同的souce地址和ip地址:但是也是有代价的,
那就是两个程序(已经运行在192.168.10.128:80的第一个进程和下一个也想要在
192.168.10.128:80运行的进程)都必须设置SO_REUSEPORT
</li>
<li>如果IP绑定的是multicase 地址,那么SO_REUSEADDR和SO_REUSEPORT是一模一样的
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-5-12" class="outline-4">
<h4 id="sec-1-5-12">SO_TYPE Socket Option</h4>
<div class="outline-text-4" id="text-1-5-12">
<ul class="org-ul">
<li>返回socket type.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-5-13" class="outline-4">
<h4 id="sec-1-5-13">SO_USELOOPBACK Socket Option</h4>
<div class="outline-text-4" id="text-1-5-13">
<ul class="org-ul">
<li>这个参数只对AF_ROUTE的routign domain起作用.
</li>
<li>如果这个参数为enable的化, socket会收到一份接受数据的拷贝(比如给127.0.0.1)
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6">IPv4 Socket Options</h3>
<div class="outline-text-3" id="text-1-6">
<ul class="org-ul">
<li>前面说过setsockopt的参数里面的level是用来指示所属协议的,这一节所说的洗衣额
都是IPv4的,其level值为IPPROTO_IP
</li>
</ul>
</div>
<div id="outline-container-sec-1-6-1" class="outline-4">
<h4 id="sec-1-6-1">IP_HDRINCL Socket Option</h4>
<div class="outline-text-4" id="text-1-6-1">
<ul class="org-ul">
<li>当需要编写自己的IP数据包首部时，可以在原始套接字上设置套接字选项IP_HDRINCL.
在不设置这个选项的情况下，IP协议自动填充IP数据包的首部
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-6-2" class="outline-4">
<h4 id="sec-1-6-2">IP_OPTIONS Socket Option</h4>
<div class="outline-text-4" id="text-1-6-2">
<ul class="org-ul">
<li>设置这个允许我们自己设置IPv4 Header
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-6-3" class="outline-4">
<h4 id="sec-1-6-3">IP_RECVDSTADDR Socket Option</h4>
<div class="outline-text-4" id="text-1-6-3">
<ul class="org-ul">
<li>设置该选项导致所接受到的UDP数据报的目的IP地址返回(在函数recvmsg的帮助下)
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-6-4" class="outline-4">
<h4 id="sec-1-6-4">IP_RECVIF Socket Option</h4>
<div class="outline-text-4" id="text-1-6-4">
<ul class="org-ul">
<li>设置该选项导致所接受到的UDP数据报的接口索引(index of the interface)返回(在
函数recvmsg的帮助下)
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-6-5" class="outline-4">
<h4 id="sec-1-6-5">IP_TOS Socket Option</h4>
<div class="outline-text-4" id="text-1-6-5">
<ul class="org-ul">
<li>该设置让我们用来设置IP的TOS域
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-6-6" class="outline-4">
<h4 id="sec-1-6-6">IP_TTL Socket Option</h4>
<div class="outline-text-4" id="text-1-6-6">
<ul class="org-ul">
<li>这个用来设置(还可以读取)TTL(Time To Live)的值
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7">ICMPv6 Socket Option</h3>
<div class="outline-text-3" id="text-1-7">
</div><div id="outline-container-sec-1-7-1" class="outline-4">
<h4 id="sec-1-7-1">ICMP6_FILTER Socket Option</h4>
<div class="outline-text-4" id="text-1-7-1">
<ul class="org-ul">
<li>我们用这个来设置icmp6_filter structure(这个结构体描述了哪些ICMPv6 message会
传递给process)
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8">IPv6 Socket Options</h3>
<div class="outline-text-3" id="text-1-8">
<ul class="org-ul">
<li>to be continue
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-9" class="outline-3">
<h3 id="sec-1-9">TCP Socket Options</h3>
<div class="outline-text-3" id="text-1-9">
<ul class="org-ul">
<li>TCP 协议的level设置为IPPROTO_TCP
</li>
</ul>
</div>
<div id="outline-container-sec-1-9-1" class="outline-4">
<h4 id="sec-1-9-1">TCP_MAXSEG Socket Option</h4>
<div class="outline-text-4" id="text-1-9-1">
<ul class="org-ul">
<li>这个设置让我们读取(或者设置,但很多实现不支持设置,因为他们把MSS设置成了
read-only)MSS.也就是TCP传递给对方的maximum amount data
</li>
<li>一般来说MSS都是对方在SYN的时候一块传递给我们的,当然我们也可以选择一个比
对方传来的MSS更小的值
</li>
<li>如果在链接建立之前就读取这个值,那么返回的就是"如果对方不发送MSS,我们默认
使用多大的MSS"
</li>
<li>如果timestamp option开启的话. 我们的"真正MSS使用值"会比"返回的MSS"要小,
因为timestamp option会占用12bytes
</li>
<li>我们还要知道的是MSS在connection的整个生命过程中,可能会改变的(如果TCP支持
path MTU discovery)
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-9-2" class="outline-4">
<h4 id="sec-1-9-2">TCP_NODELAY Socket Option</h4>
<div class="outline-text-4" id="text-1-9-2">
<ul class="org-ul">
<li>这个选项会开启TCP的Nagle算法.默认情况下,这个选项是开启的.
</li>
<li>Nagle算法主要是为了减少WAN上面的小的packet:
<ul class="org-ul">
<li>如果当前connection有outstanding data(数据发出,但是没有被对方ACK),那么
"small packet"就不能再发送了
</li>
<li>所谓"small packet",就是packet比MSS还小的数据
</li>
<li>这样的话,促使TCP尽可能的只发送full-size packet.从而提高传输效率
</li>
</ul>
</li>
<li>small packet的主要产生者是Rlogin和Telnet. 在LAN上面,small packet导致的
延迟并不是特别的明显,但是在WAN上面.这个延迟就会很明显,并且会因为Nagle算法
而放大:因为只有数据确认了才发送下一个.数据确认的过程在WAN上面长达几秒
</li>
<li>Nagle算法经常和其他的TCP算法合作.比如, delayed ACK算法.这个算法会让TCP
延迟发送ACK一段时间(通常是50-200ms):因为希望这个ACK和搭后面的数据的"顺风车",
能减少网络上一个packet.
</li>
<li>但是如果server不产生返回的data,那么ACK的返回就会明显的变慢了.这种情况下就要
设置TCP_NODELAY为disable啦.
</li>
<li>在使用Rlogin和Telnet的时候,delayed算法就和Nagle搭上界了: 本来ACK要马上返回的,
但是等了一等,就等到了server返回的字符.一起返回了.
</li>
<li>还有写设计不好的请求,比如一个请求一共400bytes,却分成了两份
<ol class="org-ol">
<li>4byte的request type
</li>
<li>396 byte的request date.
</li>
</ol>
</li>
<li>这种设计会极大的浪费带宽.因为:
<ol class="org-ol">
<li>由于第一个4byte没有ACK, 第二个396bytes无法发送
</li>
<li>而第一个ACK还要等50-200ms才发送,如果没有"顺风车"的情况.
</li>
</ol>
</li>
<li>解决上面这种不良设计的方法有如下:
<ol class="org-ol">
<li>使用writev()替代write.writev将多个数据存储在一起，将驻留在两个或更多的
不连接的缓冲区中的数据一次写出去, 这就会只产生一个TCP segment. 这个是
最好的解法
</li>
<li>把4bytes和396bytes数据都拷贝到一个buffer里面然后write一次
</li>
<li>设置TCP_NODELAY为disable,然后调用两次write. 这个是最差的解法,由于对网络
有危害,我们甚至都不要去考虑去这么做.
</li>
</ol>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-10" class="outline-3">
<h3 id="sec-1-10">SCTP Socket Options</h3>
<div class="outline-text-3" id="text-1-10">
<ul class="org-ul">
<li>to be continue
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-11" class="outline-3">
<h3 id="sec-1-11">fcntl Function</h3>
<div class="outline-text-3" id="text-1-11">
<ul class="org-ul">
<li>fcntl意为"file control", 主要是来对file descriptor进行一些操作.socket也是一种
file descriptor,所以fcntl也可以对它
</li>
<li>下图是fcntl,ioctl和routing sockets能够进行的操作列表
<table border="2" cellspacing="0" cellpadding="6" rules="all" frame="border">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<tbody>
<tr>
<td class="left">Option</td>
<td class="left">fcntl</td>
<td class="left">ioctl</td>
<td class="left">Routing socket</td>
<td class="left">POSIX</td>
</tr>

<tr>
<td class="left">Set socket for nonblocking I/O</td>
<td class="left">F_SETFL, O_NONBLOCK</td>
<td class="left">FIONBIO</td>
<td class="left">&#xa0;</td>
<td class="left">fcntl</td>
</tr>

<tr>
<td class="left">Set socket for signaldriven I/O</td>
<td class="left">F_SETFL, O_ASYNC</td>
<td class="left">FIOASYNC</td>
<td class="left">&#xa0;</td>
<td class="left">fcntl</td>
</tr>

<tr>
<td class="left">Set socket owner</td>
<td class="left">F_SETOWN</td>
<td class="left">SIOCSPGRP</td>
<td class="left">&#xa0;</td>
<td class="left">fcntl</td>
</tr>

<tr>
<td class="left">Get socket owner</td>
<td class="left">F_GETOWN</td>
<td class="left">SIOCGPGRP</td>
<td class="left">&#xa0;</td>
<td class="left">fcntl</td>
</tr>

<tr>
<td class="left">Get #bytes in socket receive buffer</td>
<td class="left">&#xa0;</td>
<td class="left">FIONREAD</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">Test for socket at out-of-band mark</td>
<td class="left">&#xa0;</td>
<td class="left">SIOCATMARK</td>
<td class="left">&#xa0;</td>
<td class="left">sockatmark</td>
</tr>

<tr>
<td class="left">Obtain interface list</td>
<td class="left">&#xa0;</td>
<td class="left">SIOCGIFCONF</td>
<td class="left">sysctl</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">Interface operations</td>
<td class="left">&#xa0;</td>
<td class="left">SIOCIFxxx</td>
<td class="left">&#xa0;</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">ARP cache operations</td>
<td class="left">&#xa0;</td>
<td class="left">SIOCxARP</td>
<td class="left">RTM_xxx</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">Routing table operations</td>
<td class="left">&#xa0;</td>
<td class="left">SIOCxxxRT</td>
<td class="left">RTM_xxx</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>
</li>
<li>fcntl在网络编程方面的贡献如下:
<ul class="org-ul">
<li>Nonblocing I/O : 我们可以设置文件flag:O_NONBLOCK(通过F_SETFL)
</li>
<li>Signal-driven I/O: 我们可以设置文件flag:O_ASYNC(通过F_SETFL)
</li>
<li>F_SETOWN可以设置SIGIO, SIGURG信号的socket owner(process ID 或者 process group ID)
</li>
</ul>
</li>
<li>下面来看看fcntl的定义
<div class="org-src-container">

<pre class="src src-c"><span style="color: #4856F7; font-weight: bold;">#include</span> <span style="color: #A2925E;">&lt;fcntl.h&gt;</span>

<span style="color: #ed5b15;">/**********************************************/</span>
<span style="color: #ed5b15;">/* </span><span style="color: #ed5b15;">Returns: depends on cmd if OK, -1 on error </span><span style="color: #ed5b15;">*/</span>
<span style="color: #ed5b15;">/**********************************************/</span>
<span style="color: #DADADA;">int</span> <span style="color: #A1A1FF;">fcntl</span>(<span style="color: #DADADA;">int</span> <span style="color: #C1C144;">fd</span>, <span style="color: #DADADA;">int</span> <span style="color: #C1C144;">cmd</span>, ...<span style="color: #ed5b15;">/*</span><span style="color: #ed5b15;">int arg</span><span style="color: #ed5b15;">*/</span>);
</pre>
</div>
</li>
<li>fd参数通常有一系列的flags(比如O_NONBLOCK, O_ASYNC), 通过cmd参数来进行设置(
F_SETFL)或者读取(F_GETFL)
</li>
<li>下面是设置O_NONBLOCK的例子
<div class="org-src-container">

<pre class="src src-c"><span style="color: #DADADA;">int</span>   <span style="color: #C1C144;">flags</span>;

<span style="color: #4856F7; font-weight: bold;">if</span> ((flags = fcntl(fd, F_GETFL,0)) &lt; 0) {
    err_sys(<span style="color: #A2925E;">"F_GETFL error"</span>);
}

flags |= O_NONBLOCK;
<span style="color: #4856F7; font-weight: bold;">if</span> (fcntl(fd, F_SETFL, flags) &lt; 0) {
    err_sys(<span style="color: #A2925E;">"F_SETFL error"</span>);
}
</pre>
</div>
</li>
<li>注意一定要先通过F_GETFL,把原来的参数读取过来,否则,像下面一样,虽然设置
nonblocking成功,但同时也就把原来的参数都清零了
<div class="org-src-container">

<pre class="src src-c"><span style="color: #ed5b15;">/* </span><span style="color: #ed5b15;">!! Wrong way to set a socket as non blocking !! </span><span style="color: #ed5b15;">*/</span>
<span style="color: #4856F7; font-weight: bold;">if</span> (fcntl(fd, F_SETFL, O_NONBLOCK) &lt; 0) {
    err_sys(<span style="color: #A2925E;">"F_SETFL error"</span>);
}
</pre>
</div>
</li>
<li>关闭nonblocking的设置也很简单,只在位操作上有稍许不同(当然还是要读取原来
的设置)
<div class="org-src-container">

<pre class="src src-c"><span style="color: #DADADA;">int</span>   <span style="color: #C1C144;">flags</span>;

<span style="color: #4856F7; font-weight: bold;">if</span> ((flags = fcntl(fd, F_GETFL,0)) &lt; 0) {
    err_sys(<span style="color: #A2925E;">"F_GETFL error"</span>);
}

flags &amp;= ~O_NONBLOCK;
<span style="color: #4856F7; font-weight: bold;">if</span> (fcntl(fd, F_SETFL, flags) &lt; 0) {
    err_sys(<span style="color: #A2925E;">"F_SETFL error"</span>);
}
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

         <!-- Disqus Comment BEGIN -->
          <div id="disqus_thread"></div>
          <script type="text/javascript">
              var disqus_shortname = 'harrifeng';

              (function() {
                  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
              })();
          </script>
          <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

         <!-- Disqus Comment END -->
</div>
</body>
</html>
