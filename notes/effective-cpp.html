<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Effective C++</title>
<!-- 2014-01-17 Fri 21:41 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="your name" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>

         <link href="http://fonts.googleapis.com/css?family=Droid+Sans+Mono|Galdeano|Open+Sans:600italic,400,600|Roboto+Condensed:400,700" rel="stylesheet" type="text/css">
         <link rel="stylesheet" type="text/css" href="/static/css/main.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="http://harrifeng.github.io/sitemap.html"> UP </a>
 |
 <a accesskey="H" href="http://harrifeng.github.io/index.html"> HOME </a>
</div><div id="preamble" class="status">

         <div id="header">
            <div id="header-top">
                <div id="blog-title">Harrifeng's Path</div>
                <div id="blog-sub-title">纸上得来终觉浅,绝知此事要Coding</div>
            </div>
            <div id="nav">
                <ul>
                    <li><a href="/">首页</a></li>
                    <li><a href="/notes.html">读书笔记</a></li>
                    <li><a href="/about.html">About</a></li>
                    <li><a href="/atom.xml">RSS</a></li>
                    <li>
                    </li>
                </ul>
            </div>
         </div>
</div>
<div id="content">
<h1 class="title">Effective C++</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Chapter 1: Accustoming Yourself to C++</a>
<ul>
<li><a href="#sec-1-1">Item 1: View C++ as a federation of languages</a></li>
<li><a href="#sec-1-2">Item 2: Prefer const, enums and inlines to #defines</a></li>
<li><a href="#sec-1-3">Item 3: Use const whenever possible</a></li>
<li><a href="#sec-1-4">Item 4: Make sure that objects are initialized before they're used</a></li>
</ul>
</li>
<li><a href="#sec-2">Chapter 2: 构造析构赋值运算</a>
<ul>
<li><a href="#sec-2-1">Item 05: 了解C++默默编写并调用哪些函数</a></li>
<li><a href="#sec-2-2">Item 06: 若不想使用编译器生成的函数,就该明确拒绝</a></li>
<li><a href="#sec-2-3">Item 07: 为多肽基类声明virtual析构函数</a></li>
<li><a href="#sec-2-4">Item 08: 别让异常逃离析构函数</a></li>
<li><a href="#sec-2-5">Item 09: 绝对不在构造和析构过程中调用virtual函数</a></li>
<li><a href="#sec-2-6">Item 10: 令operator=返回一个reference to *this</a></li>
<li><a href="#sec-2-7">Item 11: 在operator=中处理"自我赋值"</a></li>
<li><a href="#sec-2-8">Item 12: 复制对象时勿忘其每一个成分</a></li>
</ul>
</li>
<li><a href="#sec-3">Chapter 3: 资源管理</a>
<ul>
<li><a href="#sec-3-1">Item 13: 以对象管理资源:</a></li>
<li><a href="#sec-3-2">Item 14: 在资源管理类中小心coping行为</a></li>
<li><a href="#sec-3-3">Item 15: 在资源管理类中提供对原始资源的访问</a></li>
<li><a href="#sec-3-4">Item 16: 成对的使用new和delete时,要采用相同的形式</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Chapter 1: Accustoming Yourself to C++</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Item 1: View C++ as a federation of languages</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>C++ 发展多年以后其实更像如下的几个部分的结合体:
<ol class="org-ol">
<li>C语言
</li>
<li>面向对象的C语言: 构造析构,继承,封装,多肽
</li>
<li>Template: 就是generic programming
</li>
<li>STL: generic programming库
</li>
</ol>
</li>
<li>我们要根据自己当前出的区域,来决定用什么技术更高效, 比如:
<ol class="org-ol">
<li>对于inline类型来说(c语言), build-in类型pass-by-value通常比pass-by-reference
高效, 但是在OOC里面, 由于有构造和析构的存在, 我们就更倾向于使用
pass-by-reference-const.
</li>
<li>在Template领域里面, 也是要传pass-by-reference-const
</li>
<li>但是在STL领域里面pass-by-value再次适用, 因为迭代器和函数对象都是在指针上面塑造
出来的, 那就必须传递指针(指针就是value, 引用才是reference)
</li>
</ol>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Item 2: Prefer const, enums and inlines to #defines</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>#define的缺点:
<ol class="org-ol">
<li>用define定义以后,由于有预编译的存在, ASPECT_RATIO根本就没进入符号表,那么
出了错误,你也就不知道在哪里去改
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #F38630;">#define</span> <span style="color: #FD971F;">ASPECT_RATIO</span> 1.653
<span style="color: #505C63;">// </span><span style="color: #505C63;">Better Option</span>
<span style="color: #A7DBD8;">const</span> <span style="color: #999999;">double</span> <span style="color: #FD971F;">AspectRation</span> = 1.653
</pre>
</div>
</li>
<li>下面这个例子由于预编译的存在, STRING的内存被分配多次,如果用const替代的话,
只需要分配一次
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #F38630;">#define</span> <span style="color: #FD971F;">STRING</span> <span style="color: #F8F8F0;">"abcdefg\n"</span>

<span style="color: #A7DBD8;">const</span> <span style="color: #999999;">char</span> <span style="color: #FD971F;">string</span>[] = <span style="color: #F8F8F0;">"abcdefg"</span>;

printf(STRING); <span style="color: #505C63;">// </span><span style="color: #505C63;">Allocate memory for STRING</span>

printf(string); <span style="color: #505C63;">// </span><span style="color: #505C63;">Allocate memory for string, for the first and last time.</span>

<span style="color: #505C63;">//</span><span style="color: #505C63;">....</span>
printf(STRING); <span style="color: #505C63;">// </span><span style="color: #505C63;">Allocate memory for STRING again</span>
printf(string); <span style="color: #505C63;">// </span><span style="color: #505C63;">No allocate memory here</span>
</pre>
</div>
</li>
<li>#define并不重视作用域, 除非#undef, 否则她一直有效, 这对于封装来说是个灾
难(不存在private define这一说), const可以解决这个问题
</li>
<li>#define实现宏函数, 问题非常多, 有时候加再多的括号也没办法解决:
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #F38630;">#define</span> <span style="color: #AEE239;">CALL_WITH_MAX</span>(<span style="color: #FD971F;">a</span>, <span style="color: #FD971F;">b</span>) f((a) &gt; (b)) ? (a) : (b)
<span style="color: #999999;">int</span> <span style="color: #FD971F;">a</span> = 5, <span style="color: #FD971F;">b</span> = 0;

CALL_WITH_MAX(++a, b);  <span style="color: #505C63;">// </span><span style="color: #505C63;">a is incremented twice</span>
CALL_WITH_MAX(++a, b);  <span style="color: #505C63;">// </span><span style="color: #505C63;">a is incremented once</span>
</pre>
</div>
</li>
</ol>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Item 3: Use const whenever possible</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>const 指针是非常容易错的部分, 总结起来就是
<ul class="org-ul">
<li>const在*号左边,就是指针指向的东西const
</li>
<li>const在*号右边,就是指针本身const(不能指向其他地址)
</li>
</ul>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #999999;">char</span> <span style="color: #FD971F;">greeting</span>[] = <span style="color: #F8F8F0;">"Hello"</span>;      
<span style="color: #999999;">char</span> *<span style="color: #FD971F;">p</span> = greeting;              <span style="color: #505C63;">//</span><span style="color: #505C63;">non-const pointer, non-const data</span>

<span style="color: #A7DBD8;">const</span> <span style="color: #999999;">char</span> *<span style="color: #FD971F;">p</span> = greeting;        <span style="color: #505C63;">//</span><span style="color: #505C63;">non-const pointer, const data</span>
<span style="color: #999999;">char</span> <span style="color: #A7DBD8;">const</span> *<span style="color: #FD971F;">p</span> = greeting;        <span style="color: #505C63;">//</span><span style="color: #505C63;">same as above</span>

<span style="color: #999999;">char</span> * <span style="color: #A7DBD8;">const</span> <span style="color: #FD971F;">p</span> = greeting;       <span style="color: #505C63;">//</span><span style="color: #505C63;">const pointer, non-const data</span>

<span style="color: #A7DBD8;">const</span> <span style="color: #999999;">char</span> * <span style="color: #A7DBD8;">const</span> <span style="color: #FD971F;">p</span> = greeting; <span style="color: #505C63;">//</span><span style="color: #505C63;">const pointer, const data</span>
</pre>
</div>
</li>
<li>const在STL里面的应用如下:
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #AEE239;">std</span>::<span style="color: #999999;">vector</span>&lt;<span style="color: #999999;">int</span>&gt; <span style="color: #FD971F;">vec</span>;
<span style="color: #A7DBD8;">const</span> <span style="color: #AEE239;">std</span>::<span style="color: #AEE239;">vector</span>&lt;<span style="color: #999999;">int</span>&gt;::<span style="color: #999999;">iterator</span> <span style="color: #FD971F;">iter</span> = vec.begin(); <span style="color: #505C63;">// </span><span style="color: #505C63;">iter acts like a T* const</span>

<span style="color: #AEE239;">std</span>:<span style="color: #AEE239;">vector</span>&lt;<span style="color: #999999;">int</span>&gt;::<span style="color: #999999;">const_iterator</span> <span style="color: #FD971F;">cIter</span> = vec.begin(); <span style="color: #505C63;">// </span><span style="color: #505C63;">cIter acts like a const T*</span>
</pre>
</div>
</li>
<li>如果一个成员变量被声明为const, 那么她就不能改变过其他成员变量, 下面例子中,
函数operator[]的返回值为const, 那么x[const成员变量]的结果就无法被赋值.
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #A7DBD8;">class</span> <span style="color: #999999;">TextBlock</span>
{
<span style="color: #A7DBD8;">public</span>:
    <span style="color: #A7DBD8;">const</span> <span style="color: #999999;">char</span>&amp; <span style="color: #A7DBD8;">operator</span><span style="color: #AEE239;">[]</span>(<span style="color: #AEE239;">std</span>::<span style="color: #999999;">size_t</span> <span style="color: #FD971F;">position</span>) <span style="color: #A7DBD8;">const</span> {  <span style="color: #505C63;">//</span><span style="color: #505C63;">operator[] for </span>
        <span style="color: #A7DBD8;">return</span> text[position];                            <span style="color: #505C63;">//</span><span style="color: #505C63;">const object</span>
    }

    <span style="color: #999999;">char</span>&amp; <span style="color: #A7DBD8;">operator</span><span style="color: #AEE239;">[]</span>(<span style="color: #AEE239;">std</span>::<span style="color: #999999;">size_t</span> <span style="color: #FD971F;">position</span>) {              <span style="color: #505C63;">//</span><span style="color: #505C63;">operator[] for</span>
        <span style="color: #A7DBD8;">return</span> text[position];                            <span style="color: #505C63;">// </span><span style="color: #505C63;">non-const object</span>
    }
<span style="color: #A7DBD8;">private</span>:
    <span style="color: #AEE239;">std</span>::<span style="color: #999999;">string</span> <span style="color: #FD971F;">text</span>;                                                      
};
</pre>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">Item 4: Make sure that objects are initialized before they're used</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>如果是build-in类型的变量, 在定义的时候给一个初始化值, 因为不然的话, 其内容
是随机的
</li>
<li>对于其他非build-in类型来说, 要调用ctor来初始化, 当然也有注意事项:
<ul class="org-ul">
<li>每个构造函数将所有成员初始化
</li>
<li>初始化顺序和定义顺序相同
</li>
<li>用member initialization list来进行初始化, 原因有:
<ol class="org-ol">
<li>有些时候有些值是只能初始化,而无法赋值的
</li>
<li>调用成员初始化列表其实只是调用了一次copy ctor, 而default ctor在赋值的
话,等于除了default ctor又调用了一次operator=
</li>
</ol>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Chapter 2: 构造析构赋值运算</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Item 05: 了解C++默默编写并调用哪些函数</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>一个类,如果你没声明的话,编译器会默认给你创建三个函数:
<ul class="org-ul">
<li>default ctor
</li>
<li>copy ctor
</li>
<li>copy assignment
</li>
<li>dtor
</li>
</ul>
</li>
<li>所有这些函数都是public, inline的
</li>
<li>编译器产生的dtor是non-virtual的
</li>
<li>如果某个base的类把copy assignment声明为private,那么derived类是不会生成
一个copy assignment的
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Item 06: 若不想使用编译器生成的函数,就该明确拒绝</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>为了不让编译器暗自提供某些功能,可以将相应的成员函数声明为private,并且不予
实现
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Item 07: 为多肽基类声明virtual析构函数</h3>
<div class="outline-text-3" id="text-2-3">
<ul class="org-ul">
<li>当derived 对象经由base 指针删除, 而base 带着一个non-virtual dtor, 那么其
结果未定义&#x2013;通常情况下是derived成分没有被销毁
</li>
<li>如果一个class里面哪怕只有一个virtual函数,那么它一定要有一个virtual的dtor,
如果一个virtual函数都没有,那么它没有想过继承这件事情,设置一个virtual dtor会
增大对象的大小
</li>
<li>说到多肽, 我们可以有这么一种继承方法:动物类-&gt;鸟类-&gt;鸵鸟类, 其中鸟类和鸵鸟类
都可以实例化,因为有这种动物, 而动物类就不应该实例化. 为了防止这种类被实例化
c++中给他们了一个类型叫做"抽象基类(abstract base class)", 想让一个类成为
抽象基类很简单, 只需要在这个类里面定义一个纯虚函数即可
</li>
<li>所谓纯虚函数,就是derived类里面必须要实现,而base类里面不需要实现的函数,其定义
语法比较不常见
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #A7DBD8;">class</span> <span style="color: #999999;">Base</span> {
    <span style="color: #A7DBD8;">virtual</span>  <span style="color: #999999;">void</span> <span style="color: #AEE239;">pure_virtual_example</span>() = 0;
};
</pre>
</div>
</li>
<li>既然有一个纯虚函数就可以成为抽象基类可以了,而且既然是抽象基类肯定是要继承的
那么dtor肯定要是虚函数, 那么我们不妨"合二为一"把dtor设计成纯虚函数, 如下,
需要注意的是,纯虚dtor需要一个定义
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #F38630;">#include</span> <span style="color: #F8F8F0;">&lt;iostream&gt;</span>
<span style="color: #A7DBD8;">using</span> <span style="color: #A7DBD8;">namespace</span> <span style="color: #AEE239;">std</span>;

<span style="color: #A7DBD8;">class</span> <span style="color: #999999;">Base</span>
{
<span style="color: #A7DBD8;">public</span>:
    <span style="color: #AEE239;">Base</span>() {
        cout &lt;&lt; <span style="color: #F8F8F0;">"Base Ctor"</span> &lt;&lt; endl;
    }
    <span style="color: #A7DBD8;">virtual</span> ~<span style="color: #AEE239;">Base</span>() = 0;
    <span style="color: #A7DBD8;">virtual</span> <span style="color: #999999;">void</span> <span style="color: #AEE239;">speak</span>() = 0;
};
<span style="color: #AEE239;">Base</span>::~<span style="color: #AEE239;">Base</span>() {
    cout &lt;&lt; <span style="color: #F8F8F0;">"Pure Virtual Dtor Need One Difinition!"</span> &lt;&lt; endl;
}

<span style="color: #A7DBD8;">class</span> <span style="color: #999999;">De</span> : <span style="color: #A7DBD8;">public</span> <span style="color: #999999;">Base</span> {
<span style="color: #A7DBD8;">public</span>:
    <span style="color: #AEE239;">De</span>() {
        cout &lt;&lt; <span style="color: #F8F8F0;">"De Ctor"</span> &lt;&lt; endl;
    }
    <span style="color: #A7DBD8;">virtual</span> ~<span style="color: #AEE239;">De</span>() {
        cout &lt;&lt; <span style="color: #F8F8F0;">"De Dtor"</span> &lt;&lt; endl;
    }
    <span style="color: #999999;">void</span> <span style="color: #AEE239;">speak</span>() {}
};

<span style="color: #999999;">int</span> <span style="color: #AEE239;">main</span>(<span style="color: #999999;">int</span> <span style="color: #FD971F;">argc</span>, <span style="color: #999999;">char</span> *<span style="color: #FD971F;">argv</span>[])
{
    <span style="color: #999999;">De</span> *<span style="color: #FD971F;">dd</span> = <span style="color: #A7DBD8;">new</span> <span style="color: #999999;">De</span>();
    <span style="color: #A7DBD8;">delete</span> dd;
    <span style="color: #A7DBD8;">return</span> 0;
}
</pre>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">Item 08: 别让异常逃离析构函数</h3>
<div class="outline-text-3" id="text-2-4">
<ul class="org-ul">
<li>c++并不禁止析构函数突出异常,但是它并不鼓励你这么做
</li>
<li>如果客户需要堆某个操作函数运行期间抛出的异常做出反应,那么class应该提供一个
普通函数(而非在析构函数中)执行该操作
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">Item 09: 绝对不在构造和析构过程中调用virtual函数</h3>
<div class="outline-text-3" id="text-2-5">
<ul class="org-ul">
<li>Base class构造期间, virtual函数不是virtual函数,只是base的一个函数, 其
绝对不可能到derived class阶层
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">Item 10: 令operator=返回一个reference to *this</h3>
<div class="outline-text-3" id="text-2-6">
<ul class="org-ul">
<li>赋值是可以写成连锁形式的, 其赋值顺序是才用右结合:
<div class="org-src-container">

<pre class="src src-c++">x = y = z = 15;
<span style="color: #505C63;">// </span><span style="color: #505C63;">Following is the real order by default</span>
x = (y = (z=15));
</pre>
</div>
</li>
<li>为了实现赋值连锁, 赋值操作符函数必须返回一个reference指向操作符的左侧实参
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #A7DBD8;">class</span> <span style="color: #999999;">Widget</span> {
<span style="color: #A7DBD8;">public</span>:
    <span style="color: #999999;">Widget</span>&amp; <span style="color: #A7DBD8;">operator</span><span style="color: #AEE239;">=</span>(<span style="color: #A7DBD8;">const</span> <span style="color: #999999;">Widget</span>&amp; <span style="color: #FD971F;">rhs</span>) {
        <span style="color: #505C63;">// </span><span style="color: #505C63;">...</span>
        <span style="color: #A7DBD8;">return</span> *<span style="color: #A7DBD8;">this</span>;
    }
};
</pre>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">Item 11: 在operator=中处理"自我赋值"</h3>
<div class="outline-text-3" id="text-2-7">
<ul class="org-ul">
<li>"自我赋值"发生在对象给自己赋值的时候,如果在这个期间有指针的话,那么事情就有可
能出现问题:
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #A7DBD8;">class</span> <span style="color: #999999;">Bitmap</span> {
<span style="color: #505C63;">//</span><span style="color: #505C63;">..</span>
};

<span style="color: #A7DBD8;">class</span> <span style="color: #999999;">Widget</span> {
<span style="color: #A7DBD8;">private</span>:
    <span style="color: #999999;">Bitmap</span>* <span style="color: #FD971F;">pb</span>;
};

<span style="color: #505C63;">// </span><span style="color: #505C63;">Wrong Version!! what about if rhs is this </span>
<span style="color: #999999;">Widget</span>&amp; <span style="color: #AEE239;">Widget</span>::<span style="color: #A7DBD8;">operator</span><span style="color: #AEE239;">=</span>(<span style="color: #A7DBD8;">const</span> <span style="color: #999999;">Widget</span>&amp; <span style="color: #FD971F;">rhs</span>) {
    <span style="color: #A7DBD8;">delete</span> pb;
    pb = <span style="color: #A7DBD8;">new</span> <span style="color: #999999;">Bitmap</span>(*rhs.pb);
    <span style="color: #A7DBD8;">return</span> *<span style="color: #A7DBD8;">this</span>;
}
</pre>
</div>
</li>
<li>破解"自我赋值"难题的方法是"证同测试(identity test)"
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #999999;">Widget</span>&amp; <span style="color: #AEE239;">Widget</span>::<span style="color: #A7DBD8;">operator</span><span style="color: #AEE239;">=</span>(<span style="color: #A7DBD8;">const</span> <span style="color: #999999;">Widget</span>&amp; <span style="color: #FD971F;">rhs</span>) {
    <span style="color: #A7DBD8;">if</span> (<span style="color: #A7DBD8;">this</span> == &amp;rhs) <span style="color: #A7DBD8;">return</span> *<span style="color: #A7DBD8;">this</span>; <span style="color: #505C63;">// </span><span style="color: #505C63;">identity test</span>
    <span style="color: #A7DBD8;">delete</span> pb;
    pb = <span style="color: #A7DBD8;">new</span> <span style="color: #999999;">Bitmap</span>(*rhs.pb);
    <span style="color: #A7DBD8;">return</span> *<span style="color: #A7DBD8;">this</span>;
}
</pre>
</div>
</li>
<li>上面这个版本依然有异常方面的麻烦, 如果new Bitmap出现了异常, 那么pb已经被
删除,现在是一个空指针.所以我们要调整前面的语句顺序: 先记录pb的地址,在new 
Bitmap之后再删除这个指针
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #A7DBD8;">class</span> <span style="color: #999999;">Widget</span> {
    <span style="color: #999999;">Bitmap</span>* <span style="color: #FD971F;">pOrig</span> = pb; <span style="color: #505C63;">// </span><span style="color: #505C63;">remember previous pb</span>
    <span style="color: #505C63;">// </span><span style="color: #505C63;">if exception here, the next line delete pOrig will not execute     </span>
    pb = <span style="color: #A7DBD8;">new</span> <span style="color: #999999;">Bitmap</span>(*rhs.pb); 
    <span style="color: #A7DBD8;">delete</span> pOrig; 
    <span style="color: #A7DBD8;">return</span> *<span style="color: #A7DBD8;">this</span>;
}
</pre>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-8" class="outline-3">
<h3 id="sec-2-8">Item 12: 复制对象时勿忘其每一个成分</h3>
<div class="outline-text-3" id="text-2-8">
<ul class="org-ul">
<li>OO编程会把内部都封装起来,而外界留下两个函数进行复制拷贝: copy ctor 和 
copy assignment, 我们称之为copying函数
</li>
<li>copying函数应该确保赋值"对象内部所有的成员变量", 和 "所有base class成员"
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #A7DBD8;">class</span> <span style="color: #999999;">Customer</span> {
    <span style="color: #505C63;">//</span><span style="color: #505C63;">...</span>
};

<span style="color: #A7DBD8;">class</span> <span style="color: #999999;">PriorityCustomer</span> : <span style="color: #A7DBD8;">public</span> <span style="color: #999999;">Customer</span> {
<span style="color: #A7DBD8;">public</span>:
    <span style="color: #AEE239;">PriorityCustomer</span>(<span style="color: #A7DBD8;">const</span> <span style="color: #999999;">PriorityCustomer</span>&amp; <span style="color: #FD971F;">rhs</span>);
    <span style="color: #999999;">PriorityCustomer</span>&amp; <span style="color: #A7DBD8;">operator</span><span style="color: #AEE239;">=</span>(<span style="color: #A7DBD8;">const</span> <span style="color: #999999;">PriorityCustomer</span>&amp; <span style="color: #FD971F;">rhs</span>);
<span style="color: #A7DBD8;">private</span>:
    <span style="color: #999999;">int</span> <span style="color: #FD971F;">priority</span>;
};

<span style="color: #AEE239;">PriorityCustomer</span>::<span style="color: #AEE239;">PriorityCustomer</span>(<span style="color: #A7DBD8;">const</span> <span style="color: #999999;">PriorityCustomer</span>&amp; <span style="color: #FD971F;">rhs</span>)
    : Customer(rhs), priority(rhs.priority) {}
<span style="color: #999999;">PriorityCustomer</span>&amp; <span style="color: #AEE239;">PriorityCustomer</span>::<span style="color: #A7DBD8;">operator</span><span style="color: #AEE239;">=</span>(<span style="color: #A7DBD8;">const</span> <span style="color: #999999;">PriorityCustomer</span>&amp; <span style="color: #FD971F;">rhs</span>) {
    <span style="color: #AEE239;">Customer</span>::<span style="color: #A7DBD8;">operator</span>=(rhs);
    priority = rhs.priority;
    <span style="color: #A7DBD8;">return</span> *<span style="color: #A7DBD8;">this</span>;
}
</pre>
</div>
</li>
<li>不要尝试某个copying函数取实现另一个copying函数, 应该将共同机能部分放进第
三个函数中(通常叫做init),由两个copying函数共同调用
</li>
</ul>
</div>
</div>
</div>






<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Chapter 3: 资源管理</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Item 13: 以对象管理资源:</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>对c++来说,所谓资源就是申请了就要释放的资源,不仅仅是内存,包括文件描述符,互斥
锁(mutex lock)都要申请了还给系统
</li>
<li>假设我们有一个投资的类如下:
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #A7DBD8;">class</span> <span style="color: #999999;">Investment</span> {
    <span style="color: #505C63;">//</span><span style="color: #505C63;">...</span>
};
</pre>
</div>
</li>
<li>我们通过工厂模式来返回某个Investment对象
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #505C63;">// </span><span style="color: #505C63;">&#36820;&#22238;&#25351;&#38024;,&#25351;&#21521;&#21160;&#24577;&#20998;&#37197;&#30340;&#20869;&#23384;(&#23384;&#20648;Investment&#23545;&#35937;),</span>
<span style="color: #505C63;">// </span><span style="color: #505C63;">&#35843;&#29992;&#32773;&#26377;&#36131;&#20219;&#37322;&#25918;&#20182;&#20204;</span>
Investment* createInvestment();
</pre>
</div>
</li>
<li>使用使用工厂模式返回的对象,我们可以用一下代码来释放它.
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #999999;">void</span> <span style="color: #AEE239;">f</span>() {
    <span style="color: #999999;">Investment</span>* <span style="color: #FD971F;">pInv</span> = createInvestment();
    <span style="color: #505C63;">//</span><span style="color: #505C63;">...</span>
    <span style="color: #A7DBD8;">delete</span> pInv;
}
</pre>
</div>
</li>
<li>这看起来妥当的方法却很有可能无法正确删除createInvestment返回的对象,因为//&#x2026;
里面可能出现不正常的情况(无论如何,就是无法到达delete), 比如:
<ul class="org-ul">
<li>过早的return
</li>
<li>抛出了异常
</li>
</ul>
</li>
<li>为了应对这种情况,c++设计了auto_ptr来管理资源
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #999999;">void</span> <span style="color: #AEE239;">f</span>() {
    <span style="color: #505C63;">//</span><span style="color: #505C63;">&#20250;&#22312;&#23545;&#35937;&#31163;&#24320;&#20316;&#29992;&#22495;&#30340;&#26102;&#20505;, &#33258;&#21160;&#35843;&#29992;&#26512;&#26500;&#20989;&#25968;&#20445;&#35777;&#36164;&#28304;&#37322;&#25918;</span>
    <span style="color: #AEE239;">std</span>::<span style="color: #999999;">auto_ptr</span>&lt;Investment&gt; <span style="color: #FD971F;">pInv</span>(<span style="color: #999999;">createInvestment</span>());
    <span style="color: #505C63;">//</span><span style="color: #505C63;">...</span>
}
</pre>
</div>
</li>
<li>这个简单的例子, 精确的演绎了"以对象管理资源"的两个关键想法:
<ul class="org-ul">
<li>获得资源后立刻放入"管理对象(managing object)"里面
</li>
<li>"管理对象(managing object)"来确保资源被释放
</li>
</ul>
</li>
<li>auto_ptr虽然实现了上面的两个关键想法,但是其为了防止"拷贝的时候,出现多个对象,
然后析构多次", 毅然而然的设计了一种特殊的"复制":一旦copy(或者copy assinment)
就把资源唯一的代理权给新的指针,自己变成null
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #505C63;">// </span><span style="color: #505C63;">pInv1&#25351;&#21521;createInvestment&#30340;&#36820;&#22238;&#20540;</span>
<span style="color: #AEE239;">std</span>::<span style="color: #999999;">auto_ptr</span>&lt;Investment&gt; <span style="color: #AEE239;">pInv1</span>(<span style="color: #999999;">createInvestment</span>());
<span style="color: #505C63;">//</span><span style="color: #505C63;">&#29616;&#22312;pInv2&#25351;&#21521;&#23545;&#35937;, pInv1&#20026;null</span>
<span style="color: #AEE239;">std</span>::<span style="color: #999999;">auto_ptr</span>&lt;Investment&gt; <span style="color: #AEE239;">pInv2</span>(pInv1);
<span style="color: #505C63;">//</span><span style="color: #505C63;">&#29616;&#22312;pInv1&#25351;&#21521;&#23545;&#35937;, pInv2&#20026;null</span>
pInv1 = pInv2
</pre>
</div>
</li>
<li>由于起诡异的复制行为,而STL容器要求其元素发挥"正常的"复制行为,因此,这些容器里面
不能包含auto_ptr成员
</li>
<li>一个复制行为正常的智能指针是tr1::shared_ptr, 它使用引用计数来持续追踪乖哦能用
多少对象指向某个资源.
</li>
<li>不过可惜的是,shared_ptr也有很多缺点:无法判别循环引用(两个其实已经没有使用的对
象相互指向, 因而好像感觉都还在"被使用")
</li>
<li>智能指针(包括auto_ptr和shared_ptr)还有一个特别大的缺点,他们的实现中,析构的时候
总是suppose用户使用的是单个成员,所以只用delete,而不是delete[],所以下面两个例子
都是错误的
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #505C63;">// </span><span style="color: #505C63;">&#39306;&#20027;&#24847;,&#20250;&#29992;&#38169;&#35823;&#30340;delete&#24418;&#24335;</span>
<span style="color: #AEE239;">std</span>::<span style="color: #999999;">auto_ptr</span>&lt;<span style="color: #AEE239;">std</span>::string&gt; <span style="color: #AEE239;">aps</span>(<span style="color: #A7DBD8;">new</span> <span style="color: #AEE239;">std</span>::<span style="color: #999999;">string</span>[10]);
<span style="color: #AEE239;">std</span>::<span style="color: #AEE239;">tr1</span>::<span style="color: #999999;">shared_ptr</span>&lt;<span style="color: #999999;">int</span>&gt; <span style="color: #AEE239;">spi</span>(<span style="color: #A7DBD8;">new</span> <span style="color: #999999;">int</span>[1024]);
</pre>
</div>
</li>
<li>最后的最后,请大家注意的是createInvestment返回"未加工指针(raw pointer)", 简直
就是对资源泄漏的死亡邀请,因为调用者极易忘记释放资源.所以我们会在item18里面修改
createInvestment的借口
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Item 14: 在资源管理类中小心coping行为</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>复制RAII(Resource Acquisition Is Initialization) 对象必须一并复制它所管理的
资源,所以资源的copying行为决定RAII对象的copying行为
</li>
<li>普遍而常见的RAII copying行为是:抑制copying,使用引用计数法
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">Item 15: 在资源管理类中提供对原始资源的访问</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>条款13的例子中使用了智能指针来管理Investment, 但是由于改变了指针的类型(变成了智能
指针型), 所以需要一些转换,有两种方式:
<ul class="org-ul">
<li>显示转换, 智能指针提供的get函数
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #AEE239;">std</span>::<span style="color: #AEE239;">tr1</span>::<span style="color: #999999;">shared_ptr</span>&lt;Investment&gt; <span style="color: #AEE239;">pInv</span>(<span style="color: #999999;">createInvestment</span>());

<span style="color: #505C63;">//</span><span style="color: #505C63;">declare</span>
<span style="color: #999999;">int</span> <span style="color: #AEE239;">dayHeld</span>(<span style="color: #A7DBD8;">const</span> <span style="color: #999999;">Investment</span>* <span style="color: #FD971F;">pi</span>);
<span style="color: #505C63;">//</span><span style="color: #505C63;">usage</span>
<span style="color: #999999;">int</span> <span style="color: #FD971F;">days</span> = dayHeld(pInv.get());
</pre>
</div>
</li>
<li>隐式转换
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">Item 16: 成对的使用new和delete时,要采用相同的形式</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>游戏规则很简单,如果调用new的时候使用了[],那么在对应的delete的时候,也要加上[]
</li>
<li>如果typedef使用了的话, 那么delete的时候,要注意,不要被typedef的类型蒙蔽
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #A7DBD8;">typedef</span> <span style="color: #AEE239;">std</span>::<span style="color: #999999;">string</span> <span style="color: #999999;">AddressLine</span>[4];
<span style="color: #505C63;">// </span><span style="color: #505C63;">new Addressline&#36820;&#22238;&#19968;&#20010;new string[4]</span>
<span style="color: #AEE239;">std</span>::<span style="color: #999999;">string</span>* <span style="color: #FD971F;">pal</span> = <span style="color: #A7DBD8;">new</span> <span style="color: #999999;">AddressLine</span>;

<span style="color: #505C63;">//</span><span style="color: #505C63;">...</span>
<span style="color: #A7DBD8;">delete</span> pal; <span style="color: #505C63;">//</span><span style="color: #505C63;">Not defined</span>
<span style="color: #A7DBD8;">delete</span> []pal; <span style="color: #505C63;">//</span><span style="color: #505C63;">Good</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

         <!-- Duoshuo Comment BEGIN -->
         <div class="ds-thread"></div>
         <script type="text/javascript">
             var duoshuoQuery = {short_name:"harrifeng"};
             (function() {
             var ds = document.createElement('script');
             ds.type = 'text/javascript';ds.async = true;
             ds.src = 'http://static.duoshuo.com/embed.js';
             ds.charset = 'UTF-8';
             (document.getElementsByTagName('head')[0]
             || document.getElementsByTagName('body')[0]).appendChild(ds);
             })();
         </script>
         <!-- Duoshuo Comment END -->
</div>
</body>
</html>
