<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Effective C++</title>
<!-- 2014-02-09 Sun 20:43 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="your name" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>

         <link href="http://fonts.googleapis.com/css?family=Droid+Sans+Mono|Galdeano|Open+Sans:600italic,400,600|Roboto+Condensed:400,700" rel="stylesheet" type="text/css">
         <link rel="stylesheet" type="text/css" href="/static/css/main.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="http://harrifeng.github.io/sitemap.html"> UP </a>
 |
 <a accesskey="H" href="http://harrifeng.github.io/index.html"> HOME </a>
</div><div id="preamble" class="status">

         <div id="header">
            <div id="header-top">
                <div id="blog-title">Harrifeng's Path</div>
                <div id="blog-sub-title">纸上得来终觉浅,绝知此事要Coding</div>
            </div>
            <div id="nav">
                <ul>
                    <li><a href="/">首页</a></li>
                    <li><a href="/notes.html">读书笔记</a></li>
                    <li><a href="/about.html">About</a></li>
                    <li><a href="/atom.xml">RSS</a></li>
                    <li>
                    </li>
                </ul>
            </div>
         </div>
</div>
<div id="content">
<h1 class="title">Effective C++</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Chapter 1: Accustoming Yourself to C++</a>
<ul>
<li><a href="#sec-1-1">Item 1: View C++ as a federation of languages</a></li>
<li><a href="#sec-1-2">Item 2: Prefer const, enums and inlines to #defines</a></li>
<li><a href="#sec-1-3">Item 3: Use const whenever possible</a></li>
<li><a href="#sec-1-4">Item 4: Make sure that objects are initialized before they're used</a></li>
</ul>
</li>
<li><a href="#sec-2">Chapter 2: 构造析构赋值运算</a>
<ul>
<li><a href="#sec-2-1">Item 05: 了解C++默默编写并调用哪些函数</a></li>
<li><a href="#sec-2-2">Item 06: 若不想使用编译器生成的函数,就该明确拒绝</a></li>
<li><a href="#sec-2-3">Item 07: 为多肽基类声明virtual析构函数</a></li>
<li><a href="#sec-2-4">Item 08: 别让异常逃离析构函数</a></li>
<li><a href="#sec-2-5">Item 09: 绝对不在构造和析构过程中调用virtual函数</a></li>
<li><a href="#sec-2-6">Item 10: 令operator=返回一个reference to *this</a></li>
<li><a href="#sec-2-7">Item 11: 在operator=中处理"自我赋值"</a></li>
<li><a href="#sec-2-8">Item 12: 复制对象时勿忘其每一个成分</a></li>
</ul>
</li>
<li><a href="#sec-3">Chapter 3: 资源管理</a>
<ul>
<li><a href="#sec-3-1">Item 13: 以对象管理资源:</a></li>
<li><a href="#sec-3-2">Item 14: 在资源管理类中小心coping行为</a></li>
<li><a href="#sec-3-3">Item 15: 在资源管理类中提供对原始资源的访问</a></li>
<li><a href="#sec-3-4">Item 16: 成对的使用new和delete时,要采用相同的形式</a></li>
<li><a href="#sec-3-5">Item 17: 以独立语句将newd对象置入智能指针</a></li>
</ul>
</li>
<li><a href="#sec-4">Chapter 4: 设计与声明</a>
<ul>
<li><a href="#sec-4-1">Item 18: 让接口容易被正确使用,不易被误用</a></li>
<li><a href="#sec-4-2">Item 19: 设计class犹如设计type</a></li>
<li><a href="#sec-4-3">Item 20: 宁以pass-by-reference-to-const替换pass-by-value</a></li>
<li><a href="#sec-4-4">Item 21: 必须返回对象时, 别妄想返回其reference</a></li>
<li><a href="#sec-4-5">Item 22: 讲成员变量声明为private</a></li>
<li><a href="#sec-4-6">Item 23: 宁以non-memeber, non-friend替换member函数</a></li>
<li><a href="#sec-4-7">Item 24: 若所有参数皆需类型转换,请为此采用non-member函数</a></li>
<li><a href="#sec-4-8">Item 25: 考虑写出一个不抛出异常的swap函数</a></li>
</ul>
</li>
<li><a href="#sec-5">Chapter 5: 实现</a>
<ul>
<li><a href="#sec-5-1">Item 26: 尽可能延后变量定义式出现时间</a></li>
<li><a href="#sec-5-2">Item 27: 尽量少做转型动作</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Chapter 1: Accustoming Yourself to C++</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Item 1: View C++ as a federation of languages</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>C++ 发展多年以后其实更像如下的几个部分的结合体:
<ol class="org-ol">
<li>C语言
</li>
<li>面向对象的C语言: 构造析构,继承,封装,多肽
</li>
<li>Template: 就是generic programming
</li>
<li>STL: generic programming库
</li>
</ol>
</li>
<li>我们要根据自己当前出的区域,来决定用什么技术更高效, 比如:
<ol class="org-ol">
<li>对于inline类型来说(c语言), build-in类型pass-by-value通常比pass-by-reference
高效, 但是在OOC里面, 由于有构造和析构的存在, 我们就更倾向于使用
pass-by-reference-const.
</li>
<li>在Template领域里面, 也是要传pass-by-reference-const
</li>
<li>但是在STL领域里面pass-by-value再次适用, 因为迭代器和函数对象都是在指针上面塑造
出来的, 那就必须传递指针(指针就是value, 引用才是reference)
</li>
</ol>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Item 2: Prefer const, enums and inlines to #defines</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>#define的缺点:
<ol class="org-ol">
<li>用define定义以后,由于有预编译的存在, ASPECT_RATIO根本就没进入符号表,那么
出了错误,你也就不知道在哪里去改
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #F38630;">#define</span> <span style="color: #FD971F;">ASPECT_RATIO</span> 1.653
<span style="color: #505C63;">// </span><span style="color: #505C63;">Better Option</span>
<span style="color: #A7DBD8;">const</span> <span style="color: #999999;">double</span> <span style="color: #FD971F;">AspectRation</span> = 1.653
</pre>
</div>
</li>
<li>下面这个例子由于预编译的存在, STRING的内存被分配多次,如果用const替代的话,
只需要分配一次
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #F38630;">#define</span> <span style="color: #FD971F;">STRING</span> <span style="color: #F8F8F0;">"abcdefg\n"</span>

<span style="color: #A7DBD8;">const</span> <span style="color: #999999;">char</span> <span style="color: #FD971F;">string</span>[] = <span style="color: #F8F8F0;">"abcdefg"</span>;

printf(STRING); <span style="color: #505C63;">// </span><span style="color: #505C63;">Allocate memory for STRING</span>

printf(string); <span style="color: #505C63;">// </span><span style="color: #505C63;">Allocate memory for string, for the first and last time.</span>

<span style="color: #505C63;">//</span><span style="color: #505C63;">....</span>
printf(STRING); <span style="color: #505C63;">// </span><span style="color: #505C63;">Allocate memory for STRING again</span>
printf(string); <span style="color: #505C63;">// </span><span style="color: #505C63;">No allocate memory here</span>
</pre>
</div>
</li>
<li>#define并不重视作用域, 除非#undef, 否则她一直有效, 这对于封装来说是个灾
难(不存在private define这一说), const可以解决这个问题
</li>
<li>#define实现宏函数, 问题非常多, 有时候加再多的括号也没办法解决:
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #F38630;">#define</span> <span style="color: #AEE239;">CALL_WITH_MAX</span>(<span style="color: #FD971F;">a</span>, <span style="color: #FD971F;">b</span>) f((a) &gt; (b)) ? (a) : (b)
<span style="color: #999999;">int</span> <span style="color: #FD971F;">a</span> = 5, <span style="color: #FD971F;">b</span> = 0;

CALL_WITH_MAX(++a, b);  <span style="color: #505C63;">// </span><span style="color: #505C63;">a is incremented twice</span>
CALL_WITH_MAX(++a, b);  <span style="color: #505C63;">// </span><span style="color: #505C63;">a is incremented once</span>
</pre>
</div>
</li>
</ol>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Item 3: Use const whenever possible</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>const 指针是非常容易错的部分, 总结起来就是
<ul class="org-ul">
<li>const在*号左边,就是指针指向的东西const
</li>
<li>const在*号右边,就是指针本身const(不能指向其他地址)
</li>
</ul>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #999999;">char</span> <span style="color: #FD971F;">greeting</span>[] = <span style="color: #F8F8F0;">"Hello"</span>;
<span style="color: #999999;">char</span> *<span style="color: #FD971F;">p</span> = greeting;              <span style="color: #505C63;">//</span><span style="color: #505C63;">non-const pointer, non-const data</span>

<span style="color: #A7DBD8;">const</span> <span style="color: #999999;">char</span> *<span style="color: #FD971F;">p</span> = greeting;        <span style="color: #505C63;">//</span><span style="color: #505C63;">non-const pointer, const data</span>
<span style="color: #999999;">char</span> <span style="color: #A7DBD8;">const</span> *<span style="color: #FD971F;">p</span> = greeting;        <span style="color: #505C63;">//</span><span style="color: #505C63;">same as above</span>

<span style="color: #999999;">char</span> * <span style="color: #A7DBD8;">const</span> <span style="color: #FD971F;">p</span> = greeting;       <span style="color: #505C63;">//</span><span style="color: #505C63;">const pointer, non-const data</span>

<span style="color: #A7DBD8;">const</span> <span style="color: #999999;">char</span> * <span style="color: #A7DBD8;">const</span> <span style="color: #FD971F;">p</span> = greeting; <span style="color: #505C63;">//</span><span style="color: #505C63;">const pointer, const data</span>
</pre>
</div>
</li>
<li>const在STL里面的应用如下:
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #AEE239;">std</span>::<span style="color: #999999;">vector</span>&lt;<span style="color: #999999;">int</span>&gt; <span style="color: #FD971F;">vec</span>;
<span style="color: #A7DBD8;">const</span> <span style="color: #AEE239;">std</span>::<span style="color: #AEE239;">vector</span>&lt;<span style="color: #999999;">int</span>&gt;::<span style="color: #999999;">iterator</span> <span style="color: #FD971F;">iter</span> = vec.begin(); <span style="color: #505C63;">// </span><span style="color: #505C63;">iter acts like a T* const</span>

<span style="color: #AEE239;">std</span>:<span style="color: #AEE239;">vector</span>&lt;<span style="color: #999999;">int</span>&gt;::<span style="color: #999999;">const_iterator</span> <span style="color: #FD971F;">cIter</span> = vec.begin(); <span style="color: #505C63;">// </span><span style="color: #505C63;">cIter acts like a const T*</span>
</pre>
</div>
</li>
<li>如果一个成员变量被声明为const, 那么她就不能改变过其他成员变量, 下面例子中,
函数operator[]的返回值为const, 那么x[const成员变量]的结果就无法被赋值.
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #A7DBD8;">class</span> <span style="color: #999999;">TextBlock</span>
{
<span style="color: #A7DBD8;">public</span>:
    <span style="color: #A7DBD8;">const</span> <span style="color: #999999;">char</span>&amp; <span style="color: #A7DBD8;">operator</span><span style="color: #AEE239;">[]</span>(<span style="color: #AEE239;">std</span>::<span style="color: #999999;">size_t</span> <span style="color: #FD971F;">position</span>) <span style="color: #A7DBD8;">const</span> {  <span style="color: #505C63;">//</span><span style="color: #505C63;">operator[] for</span>
        <span style="color: #A7DBD8;">return</span> text[position];                            <span style="color: #505C63;">//</span><span style="color: #505C63;">const object</span>
    }

    <span style="color: #999999;">char</span>&amp; <span style="color: #A7DBD8;">operator</span><span style="color: #AEE239;">[]</span>(<span style="color: #AEE239;">std</span>::<span style="color: #999999;">size_t</span> <span style="color: #FD971F;">position</span>) {              <span style="color: #505C63;">//</span><span style="color: #505C63;">operator[] for</span>
        <span style="color: #A7DBD8;">return</span> text[position];                            <span style="color: #505C63;">// </span><span style="color: #505C63;">non-const object</span>
    }
<span style="color: #A7DBD8;">private</span>:
    <span style="color: #AEE239;">std</span>::<span style="color: #999999;">string</span> <span style="color: #FD971F;">text</span>;
};
</pre>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">Item 4: Make sure that objects are initialized before they're used</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>如果是build-in类型的变量, 在定义的时候给一个初始化值, 因为不然的话, 其内容
是随机的
</li>
<li>对于其他非build-in类型来说, 要调用ctor来初始化, 当然也有注意事项:
<ul class="org-ul">
<li>每个构造函数将所有成员初始化
</li>
<li>初始化顺序和定义顺序相同
</li>
<li>用member initialization list来进行初始化, 原因有:
<ol class="org-ol">
<li>有些时候有些值是只能初始化,而无法赋值的
</li>
<li>调用成员初始化列表其实只是调用了一次copy ctor, 而default ctor在赋值的
话,等于除了default ctor又调用了一次operator=
</li>
</ol>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">Chapter 2: 构造析构赋值运算</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">Item 05: 了解C++默默编写并调用哪些函数</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>一个类,如果你没声明的话,编译器会默认给你创建三个函数:
<ul class="org-ul">
<li>default ctor
</li>
<li>copy ctor
</li>
<li>copy assignment
</li>
<li>dtor
</li>
</ul>
</li>
<li>所有这些函数都是public, inline的
</li>
<li>编译器产生的dtor是non-virtual的
</li>
<li>如果某个base的类把copy assignment声明为private,那么derived类是不会生成
一个copy assignment的
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">Item 06: 若不想使用编译器生成的函数,就该明确拒绝</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>为了不让编译器暗自提供某些功能,可以将相应的成员函数声明为private,并且不予
实现
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">Item 07: 为多肽基类声明virtual析构函数</h3>
<div class="outline-text-3" id="text-2-3">
<ul class="org-ul">
<li>当derived 对象经由base 指针删除, 而base 带着一个non-virtual dtor, 那么其
结果未定义&#x2013;通常情况下是derived成分没有被销毁
</li>
<li>如果一个class里面哪怕只有一个virtual函数,那么它一定要有一个virtual的dtor,
如果一个virtual函数都没有,那么它没有想过继承这件事情,设置一个virtual dtor会
增大对象的大小
</li>
<li>说到多肽, 我们可以有这么一种继承方法:动物类-&gt;鸟类-&gt;鸵鸟类, 其中鸟类和鸵鸟类
都可以实例化,因为有这种动物, 而动物类就不应该实例化. 为了防止这种类被实例化
c++中给他们了一个类型叫做"抽象基类(abstract base class)", 想让一个类成为
抽象基类很简单, 只需要在这个类里面定义一个纯虚函数即可
</li>
<li>所谓纯虚函数,就是derived类里面必须要实现,而base类里面不需要实现的函数,其定义
语法比较不常见
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #A7DBD8;">class</span> <span style="color: #999999;">Base</span> {
    <span style="color: #A7DBD8;">virtual</span>  <span style="color: #999999;">void</span> <span style="color: #AEE239;">pure_virtual_example</span>() = 0;
};
</pre>
</div>
</li>
<li>既然有一个纯虚函数就可以成为抽象基类可以了,而且既然是抽象基类肯定是要继承的
那么dtor肯定要是虚函数, 那么我们不妨"合二为一"把dtor设计成纯虚函数, 如下,
需要注意的是,纯虚dtor需要一个定义
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #F38630;">#include</span> <span style="color: #F8F8F0;">&lt;iostream&gt;</span>
<span style="color: #A7DBD8;">using</span> <span style="color: #A7DBD8;">namespace</span> <span style="color: #AEE239;">std</span>;

<span style="color: #A7DBD8;">class</span> <span style="color: #999999;">Base</span>
{
<span style="color: #A7DBD8;">public</span>:
    <span style="color: #AEE239;">Base</span>() {
        cout &lt;&lt; <span style="color: #F8F8F0;">"Base Ctor"</span> &lt;&lt; endl;
    }
    <span style="color: #A7DBD8;">virtual</span> ~<span style="color: #AEE239;">Base</span>() = 0;
    <span style="color: #A7DBD8;">virtual</span> <span style="color: #999999;">void</span> <span style="color: #AEE239;">speak</span>() = 0;
};
<span style="color: #AEE239;">Base</span>::~<span style="color: #AEE239;">Base</span>() {
    cout &lt;&lt; <span style="color: #F8F8F0;">"Pure Virtual Dtor Need One Difinition!"</span> &lt;&lt; endl;
}

<span style="color: #A7DBD8;">class</span> <span style="color: #999999;">De</span> : <span style="color: #A7DBD8;">public</span> <span style="color: #999999;">Base</span> {
<span style="color: #A7DBD8;">public</span>:
    <span style="color: #AEE239;">De</span>() {
        cout &lt;&lt; <span style="color: #F8F8F0;">"De Ctor"</span> &lt;&lt; endl;
    }
    <span style="color: #A7DBD8;">virtual</span> ~<span style="color: #AEE239;">De</span>() {
        cout &lt;&lt; <span style="color: #F8F8F0;">"De Dtor"</span> &lt;&lt; endl;
    }
    <span style="color: #999999;">void</span> <span style="color: #AEE239;">speak</span>() {}
};

<span style="color: #999999;">int</span> <span style="color: #AEE239;">main</span>(<span style="color: #999999;">int</span> <span style="color: #FD971F;">argc</span>, <span style="color: #999999;">char</span> *<span style="color: #FD971F;">argv</span>[])
{
    <span style="color: #999999;">De</span> *<span style="color: #FD971F;">dd</span> = <span style="color: #A7DBD8;">new</span> <span style="color: #999999;">De</span>();
    <span style="color: #A7DBD8;">delete</span> dd;
    <span style="color: #A7DBD8;">return</span> 0;
}
</pre>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">Item 08: 别让异常逃离析构函数</h3>
<div class="outline-text-3" id="text-2-4">
<ul class="org-ul">
<li>c++并不禁止析构函数突出异常,但是它并不鼓励你这么做
</li>
<li>如果客户需要堆某个操作函数运行期间抛出的异常做出反应,那么class应该提供一个
普通函数(而非在析构函数中)执行该操作
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-5" class="outline-3">
<h3 id="sec-2-5">Item 09: 绝对不在构造和析构过程中调用virtual函数</h3>
<div class="outline-text-3" id="text-2-5">
<ul class="org-ul">
<li>Base class构造期间, virtual函数不是virtual函数,只是base的一个函数, 其
绝对不可能到derived class阶层
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-6" class="outline-3">
<h3 id="sec-2-6">Item 10: 令operator=返回一个reference to *this</h3>
<div class="outline-text-3" id="text-2-6">
<ul class="org-ul">
<li>赋值是可以写成连锁形式的, 其赋值顺序是才用右结合:
<div class="org-src-container">

<pre class="src src-c++">x = y = z = 15;
<span style="color: #505C63;">// </span><span style="color: #505C63;">Following is the real order by default</span>
x = (y = (z=15));
</pre>
</div>
</li>
<li>为了实现赋值连锁, 赋值操作符函数必须返回一个reference指向操作符的左侧实参
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #A7DBD8;">class</span> <span style="color: #999999;">Widget</span> {
<span style="color: #A7DBD8;">public</span>:
    <span style="color: #999999;">Widget</span>&amp; <span style="color: #A7DBD8;">operator</span><span style="color: #AEE239;">=</span>(<span style="color: #A7DBD8;">const</span> <span style="color: #999999;">Widget</span>&amp; <span style="color: #FD971F;">rhs</span>) {
        <span style="color: #505C63;">// </span><span style="color: #505C63;">...</span>
        <span style="color: #A7DBD8;">return</span> *<span style="color: #A7DBD8;">this</span>;
    }
};
</pre>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-7" class="outline-3">
<h3 id="sec-2-7">Item 11: 在operator=中处理"自我赋值"</h3>
<div class="outline-text-3" id="text-2-7">
<ul class="org-ul">
<li>"自我赋值"发生在对象给自己赋值的时候,如果在这个期间有指针的话,那么事情就有可
能出现问题:
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #A7DBD8;">class</span> <span style="color: #999999;">Bitmap</span> {
<span style="color: #505C63;">//</span><span style="color: #505C63;">..</span>
};

<span style="color: #A7DBD8;">class</span> <span style="color: #999999;">Widget</span> {
<span style="color: #A7DBD8;">private</span>:
    <span style="color: #999999;">Bitmap</span>* <span style="color: #FD971F;">pb</span>;
};

<span style="color: #505C63;">// </span><span style="color: #505C63;">Wrong Version!! what about if rhs is this</span>
<span style="color: #999999;">Widget</span>&amp; <span style="color: #AEE239;">Widget</span>::<span style="color: #A7DBD8;">operator</span><span style="color: #AEE239;">=</span>(<span style="color: #A7DBD8;">const</span> <span style="color: #999999;">Widget</span>&amp; <span style="color: #FD971F;">rhs</span>) {
    <span style="color: #A7DBD8;">delete</span> pb;
    pb = <span style="color: #A7DBD8;">new</span> <span style="color: #999999;">Bitmap</span>(*rhs.pb);
    <span style="color: #A7DBD8;">return</span> *<span style="color: #A7DBD8;">this</span>;
}
</pre>
</div>
</li>
<li>破解"自我赋值"难题的方法是"证同测试(identity test)"
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #999999;">Widget</span>&amp; <span style="color: #AEE239;">Widget</span>::<span style="color: #A7DBD8;">operator</span><span style="color: #AEE239;">=</span>(<span style="color: #A7DBD8;">const</span> <span style="color: #999999;">Widget</span>&amp; <span style="color: #FD971F;">rhs</span>) {
    <span style="color: #A7DBD8;">if</span> (<span style="color: #A7DBD8;">this</span> == &amp;rhs) <span style="color: #A7DBD8;">return</span> *<span style="color: #A7DBD8;">this</span>; <span style="color: #505C63;">// </span><span style="color: #505C63;">identity test</span>
    <span style="color: #A7DBD8;">delete</span> pb;
    pb = <span style="color: #A7DBD8;">new</span> <span style="color: #999999;">Bitmap</span>(*rhs.pb);
    <span style="color: #A7DBD8;">return</span> *<span style="color: #A7DBD8;">this</span>;
}
</pre>
</div>
</li>
<li>上面这个版本依然有异常方面的麻烦, 如果new Bitmap出现了异常, 那么pb已经被
删除,现在是一个空指针.所以我们要调整前面的语句顺序: 先记录pb的地址,在new
Bitmap之后再删除这个指针
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #A7DBD8;">class</span> <span style="color: #999999;">Widget</span> {
    <span style="color: #999999;">Bitmap</span>* <span style="color: #FD971F;">pOrig</span> = pb; <span style="color: #505C63;">// </span><span style="color: #505C63;">remember previous pb</span>
    <span style="color: #505C63;">// </span><span style="color: #505C63;">if exception here, the next line delete pOrig will not execute</span>
    pb = <span style="color: #A7DBD8;">new</span> <span style="color: #999999;">Bitmap</span>(*rhs.pb);
    <span style="color: #A7DBD8;">delete</span> pOrig;
    <span style="color: #A7DBD8;">return</span> *<span style="color: #A7DBD8;">this</span>;
}
</pre>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-2-8" class="outline-3">
<h3 id="sec-2-8">Item 12: 复制对象时勿忘其每一个成分</h3>
<div class="outline-text-3" id="text-2-8">
<ul class="org-ul">
<li>OO编程会把内部都封装起来,而外界留下两个函数进行复制拷贝: copy ctor 和
copy assignment, 我们称之为copying函数
</li>
<li>copying函数应该确保赋值"对象内部所有的成员变量", 和 "所有base class成员"
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #A7DBD8;">class</span> <span style="color: #999999;">Customer</span> {
    <span style="color: #505C63;">//</span><span style="color: #505C63;">...</span>
};

<span style="color: #A7DBD8;">class</span> <span style="color: #999999;">PriorityCustomer</span> : <span style="color: #A7DBD8;">public</span> <span style="color: #999999;">Customer</span> {
<span style="color: #A7DBD8;">public</span>:
    <span style="color: #AEE239;">PriorityCustomer</span>(<span style="color: #A7DBD8;">const</span> <span style="color: #999999;">PriorityCustomer</span>&amp; <span style="color: #FD971F;">rhs</span>);
    <span style="color: #999999;">PriorityCustomer</span>&amp; <span style="color: #A7DBD8;">operator</span><span style="color: #AEE239;">=</span>(<span style="color: #A7DBD8;">const</span> <span style="color: #999999;">PriorityCustomer</span>&amp; <span style="color: #FD971F;">rhs</span>);
<span style="color: #A7DBD8;">private</span>:
    <span style="color: #999999;">int</span> <span style="color: #FD971F;">priority</span>;
};

<span style="color: #AEE239;">PriorityCustomer</span>::<span style="color: #AEE239;">PriorityCustomer</span>(<span style="color: #A7DBD8;">const</span> <span style="color: #999999;">PriorityCustomer</span>&amp; <span style="color: #FD971F;">rhs</span>)
    : Customer(rhs), priority(rhs.priority) {}
<span style="color: #999999;">PriorityCustomer</span>&amp; <span style="color: #AEE239;">PriorityCustomer</span>::<span style="color: #A7DBD8;">operator</span><span style="color: #AEE239;">=</span>(<span style="color: #A7DBD8;">const</span> <span style="color: #999999;">PriorityCustomer</span>&amp; <span style="color: #FD971F;">rhs</span>) {
    <span style="color: #AEE239;">Customer</span>::<span style="color: #A7DBD8;">operator</span>=(rhs);
    priority = rhs.priority;
    <span style="color: #A7DBD8;">return</span> *<span style="color: #A7DBD8;">this</span>;
}
</pre>
</div>
</li>
<li>不要尝试某个copying函数取实现另一个copying函数, 应该将共同机能部分放进第
三个函数中(通常叫做init),由两个copying函数共同调用
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">Chapter 3: 资源管理</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">Item 13: 以对象管理资源:</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>对c++来说,所谓资源就是申请了就要释放的资源,不仅仅是内存,包括文件描述符,互斥
锁(mutex lock)都要申请了还给系统
</li>
<li>假设我们有一个投资的类如下:
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #A7DBD8;">class</span> <span style="color: #999999;">Investment</span> {
    <span style="color: #505C63;">//</span><span style="color: #505C63;">...</span>
};
</pre>
</div>
</li>
<li>我们通过工厂模式来返回某个Investment对象
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #505C63;">// </span><span style="color: #505C63;">&#36820;&#22238;&#25351;&#38024;,&#25351;&#21521;&#21160;&#24577;&#20998;&#37197;&#30340;&#20869;&#23384;(&#23384;&#20648;Investment&#23545;&#35937;),</span>
<span style="color: #505C63;">// </span><span style="color: #505C63;">&#35843;&#29992;&#32773;&#26377;&#36131;&#20219;&#37322;&#25918;&#20182;&#20204;</span>
Investment* createInvestment();
</pre>
</div>
</li>
<li>使用使用工厂模式返回的对象,我们可以用一下代码来释放它.
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #999999;">void</span> <span style="color: #AEE239;">f</span>() {
    <span style="color: #999999;">Investment</span>* <span style="color: #FD971F;">pInv</span> = createInvestment();
    <span style="color: #505C63;">//</span><span style="color: #505C63;">...</span>
    <span style="color: #A7DBD8;">delete</span> pInv;
}
</pre>
</div>
</li>
<li>这看起来妥当的方法却很有可能无法正确删除createInvestment返回的对象,因为//&#x2026;
里面可能出现不正常的情况(无论如何,就是无法到达delete), 比如:
<ul class="org-ul">
<li>过早的return
</li>
<li>抛出了异常
</li>
</ul>
</li>
<li>为了应对这种情况,c++设计了auto_ptr来管理资源
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #999999;">void</span> <span style="color: #AEE239;">f</span>() {
    <span style="color: #505C63;">//</span><span style="color: #505C63;">&#20250;&#22312;&#23545;&#35937;&#31163;&#24320;&#20316;&#29992;&#22495;&#30340;&#26102;&#20505;, &#33258;&#21160;&#35843;&#29992;&#26512;&#26500;&#20989;&#25968;&#20445;&#35777;&#36164;&#28304;&#37322;&#25918;</span>
    <span style="color: #AEE239;">std</span>::<span style="color: #999999;">auto_ptr</span>&lt;Investment&gt; <span style="color: #FD971F;">pInv</span>(<span style="color: #999999;">createInvestment</span>());
    <span style="color: #505C63;">//</span><span style="color: #505C63;">...</span>
}
</pre>
</div>
</li>
<li>这个简单的例子, 精确的演绎了"以对象管理资源"的两个关键想法:
<ul class="org-ul">
<li>获得资源后立刻放入"管理对象(managing object)"里面
</li>
<li>"管理对象(managing object)"来确保资源被释放
</li>
</ul>
</li>
<li>auto_ptr虽然实现了上面的两个关键想法,但是其为了防止"拷贝的时候,出现多个对象,
然后析构多次", 毅然而然的设计了一种特殊的"复制":一旦copy(或者copy assinment)
就把资源唯一的代理权给新的指针,自己变成null
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #505C63;">// </span><span style="color: #505C63;">pInv1&#25351;&#21521;createInvestment&#30340;&#36820;&#22238;&#20540;</span>
<span style="color: #AEE239;">std</span>::<span style="color: #999999;">auto_ptr</span>&lt;Investment&gt; <span style="color: #AEE239;">pInv1</span>(<span style="color: #999999;">createInvestment</span>());
<span style="color: #505C63;">//</span><span style="color: #505C63;">&#29616;&#22312;pInv2&#25351;&#21521;&#23545;&#35937;, pInv1&#20026;null</span>
<span style="color: #AEE239;">std</span>::<span style="color: #999999;">auto_ptr</span>&lt;Investment&gt; <span style="color: #AEE239;">pInv2</span>(pInv1);
<span style="color: #505C63;">//</span><span style="color: #505C63;">&#29616;&#22312;pInv1&#25351;&#21521;&#23545;&#35937;, pInv2&#20026;null</span>
pInv1 = pInv2
</pre>
</div>
</li>
<li>由于起诡异的复制行为,而STL容器要求其元素发挥"正常的"复制行为,因此,这些容器里面
不能包含auto_ptr成员
</li>
<li>一个复制行为正常的智能指针是tr1::shared_ptr, 它使用引用计数来持续追踪乖哦能用
多少对象指向某个资源.
</li>
<li>不过可惜的是,shared_ptr也有很多缺点:无法判别循环引用(两个其实已经没有使用的对
象相互指向, 因而好像感觉都还在"被使用")
</li>
<li>智能指针(包括auto_ptr和shared_ptr)还有一个特别大的缺点,他们的实现中,析构的时候
总是suppose用户使用的是单个成员,所以只用delete,而不是delete[],所以下面两个例子
都是错误的
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #505C63;">// </span><span style="color: #505C63;">&#39306;&#20027;&#24847;,&#20250;&#29992;&#38169;&#35823;&#30340;delete&#24418;&#24335;</span>
<span style="color: #AEE239;">std</span>::<span style="color: #999999;">auto_ptr</span>&lt;<span style="color: #AEE239;">std</span>::string&gt; <span style="color: #AEE239;">aps</span>(<span style="color: #A7DBD8;">new</span> <span style="color: #AEE239;">std</span>::<span style="color: #999999;">string</span>[10]);
<span style="color: #AEE239;">std</span>::<span style="color: #AEE239;">tr1</span>::<span style="color: #999999;">shared_ptr</span>&lt;<span style="color: #999999;">int</span>&gt; <span style="color: #AEE239;">spi</span>(<span style="color: #A7DBD8;">new</span> <span style="color: #999999;">int</span>[1024]);
</pre>
</div>
</li>
<li>最后的最后,请大家注意的是createInvestment返回"未加工指针(raw pointer)", 简直
就是对资源泄漏的死亡邀请,因为调用者极易忘记释放资源.所以我们会在item18里面修改
createInvestment的借口
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">Item 14: 在资源管理类中小心coping行为</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>复制RAII(Resource Acquisition Is Initialization) 对象必须一并复制它所管理的
资源,所以资源的copying行为决定RAII对象的copying行为
</li>
<li>普遍而常见的RAII copying行为是:抑制copying,使用引用计数法
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">Item 15: 在资源管理类中提供对原始资源的访问</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>条款13的例子中使用了智能指针来管理Investment, 但是由于改变了指针的类型(变成了智能
指针型), 所以需要一些转换,有两种方式:
<ul class="org-ul">
<li>显示转换, 智能指针提供的get函数
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #AEE239;">std</span>::<span style="color: #AEE239;">tr1</span>::<span style="color: #999999;">shared_ptr</span>&lt;Investment&gt; <span style="color: #AEE239;">pInv</span>(<span style="color: #999999;">createInvestment</span>());

<span style="color: #505C63;">//</span><span style="color: #505C63;">declare</span>
<span style="color: #999999;">int</span> <span style="color: #AEE239;">dayHeld</span>(<span style="color: #A7DBD8;">const</span> <span style="color: #999999;">Investment</span>* <span style="color: #FD971F;">pi</span>);
<span style="color: #505C63;">//</span><span style="color: #505C63;">usage</span>
<span style="color: #999999;">int</span> <span style="color: #FD971F;">days</span> = dayHeld(pInv.get());
</pre>
</div>
</li>
<li>隐式转换
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">Item 16: 成对的使用new和delete时,要采用相同的形式</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>游戏规则很简单,如果调用new的时候使用了[],那么在对应的delete的时候,也要加上[]
</li>
<li>如果typedef使用了的话, 那么delete的时候,要注意,不要被typedef的类型蒙蔽
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #A7DBD8;">typedef</span> <span style="color: #AEE239;">std</span>::<span style="color: #999999;">string</span> <span style="color: #999999;">AddressLine</span>[4];
<span style="color: #505C63;">// </span><span style="color: #505C63;">new Addressline&#36820;&#22238;&#19968;&#20010;new string[4]</span>
<span style="color: #AEE239;">std</span>::<span style="color: #999999;">string</span>* <span style="color: #FD971F;">pal</span> = <span style="color: #A7DBD8;">new</span> <span style="color: #999999;">AddressLine</span>;

<span style="color: #505C63;">//</span><span style="color: #505C63;">...</span>
<span style="color: #A7DBD8;">delete</span> pal; <span style="color: #505C63;">//</span><span style="color: #505C63;">Not defined</span>
<span style="color: #A7DBD8;">delete</span> []pal; <span style="color: #505C63;">//</span><span style="color: #505C63;">Good</span>
</pre>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5">Item 17: 以独立语句将newd对象置入智能指针</h3>
<div class="outline-text-3" id="text-3-5">
<ul class="org-ul">
<li>这里看似是讨论智能指针的问题,其实是讨论c++编译器"灵活性"的一种:参数执行顺序
的灵活性:一个函数的几个参数如果需要计算值作为参数,那么谁先谁后,是无法保证的
(java, c#可以保证)
</li>
<li>比如我们有个例子,函数processWidget的两个参数pw, priority, 而我们想把函数
priority()的返回值作为priority的值. 某个new Widget的临时指针作为pw的值:
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #999999;">int</span> <span style="color: #AEE239;">priority</span>();

<span style="color: #505C63;">//</span><span style="color: #505C63;">declaration for the function</span>
<span style="color: #999999;">void</span> <span style="color: #AEE239;">processWidget</span>(<span style="color: #AEE239;">std</span>::<span style="color: #AEE239;">tr1</span>::<span style="color: #999999;">shared_ptr</span>&lt;Widget&gt;, <span style="color: #999999;">int</span> <span style="color: #FD971F;">priority</span>);

<span style="color: #505C63;">//</span><span style="color: #505C63;">usage fo the function</span>
processWidget(<span style="color: #A7DBD8;">new</span> <span style="color: #999999;">Widget</span>, priority());
</pre>
</div>
</li>
<li>上面的这种语法在编译的时候无法通过,因为tr1::shared_ptr的构造函数虽然是以
一个raw pointer为参数,但是这个构造函数被声明为explicit,所以是无法进行隐式
转换的, 显示转换然后调用的代码如下
<div class="org-src-container">

<pre class="src src-c++">processWidget(<span style="color: #AEE239;">std</span>::<span style="color: #AEE239;">tr1</span>::<span style="color: #999999;">shared_ptr</span>&lt;Widget&gt;(<span style="color: #A7DBD8;">new</span> <span style="color: #999999;">Widget</span>), priority());
</pre>
</div>
</li>
<li>上面看似挺好的代码,却隐藏着资源泄漏的危险, 原因就是我们上面说的c++编译器在
以什么顺序计算参数方面,是没有定数的. processWidget的参数要完成下面三件事:
<ul class="org-ul">
<li>调用priority()
</li>
<li>执行new Widget, 生成一个临时的指针X
</li>
<li>把临时指针X作为参数,调用tr1::shared_ptr构造函数
</li>
</ul>
</li>
<li>上面调用shared_ptr构造函数一定要在生成临时指针之后,但是调用priority(),可以
出现在第一步,第二步,或者最后一步,假设最终是以下面的这个顺序执行的:
<ol class="org-ol">
<li>执行new Widget, 生成一个临时的指针X
</li>
<li>调用priority()
</li>
<li>把临时指针X作为参数,调用tr1::shared_ptr构造函数
</li>
</ol>
</li>
<li>如果在执行priority()的时候抛出了异常, 那么临时指针X就会遗失,因为它尚未放入到
我们自动管理资源的shared_ptr内部.也就不可能被释放了.
</li>
<li>解决的方法也很简单:使用分离的语句1,创建Widget. 2,讲Widget放入智能指针内部
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #AEE239;">std</span>::<span style="color: #AEE239;">tr1</span>::<span style="color: #999999;">shared_ptr</span>&lt;Widget&gt; <span style="color: #AEE239;">pw</span>(<span style="color: #A7DBD8;">new</span> <span style="color: #999999;">Widget</span>);

processWidget(pw, priority());
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">Chapter 4: 设计与声明</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">Item 18: 让接口容易被正确使用,不易被误用</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>"促进正确使用"的办法包括接口的一致性,以及与内置类型行为的兼容
</li>
<li>"阻止误用"的办法包括建立新类型, 限制类型操作, 束缚对象值, 以及消除客户的资
源管理责任
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">Item 19: 设计class犹如设计type</h3>
<div class="outline-text-3" id="text-4-2">
<ul class="org-ul">
<li>在设计每个class的时候,回答以下问题:
<ul class="org-ul">
<li>新type对象应该如何创建和销毁
</li>
<li>对象的初始化和对象的赋值操作有什么差别
</li>
<li>新的type的对象如果被passed by value意味着什么 (copy构造函数用来定义一个
type的pass-by-value如何实现)
</li>
<li>什么是新type的"合法值"
</li>
<li>需要继承什么
</li>
<li>新type需要什么样的转换
</li>
<li>什么样的操作符和函数对次type而言是合理的
</li>
<li>什么样的标准函数应该被驳回(声明为private)
</li>
<li>函数该采用public,private还是protected
</li>
<li>什么是新type的"未声明接口"
</li>
<li>新的type有多一般化,如果一般化的够多,比如integer, string等都要一般化的化,
就要考虑generic编程了
</li>
<li>你真的需要一个新的type么
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">Item 20: 宁以pass-by-reference-to-const替换pass-by-value</h3>
<div class="outline-text-3" id="text-4-3">
<ul class="org-ul">
<li>pass-by-reference-to-const效率高的多, 因为没有任何构造或者析构函数的调用(没
有新的对象被创建)
</li>
<li>pass-by-reference-to-const不仅仅是效率高,而且可以避免对象切割(slicing)问题:
当一个derived对象以by value的方式传递到一个并被视为base对象, 那么base class的
拷贝构造函数会被调用而"造成此对象的行为像个derived class对象"的那些特质化的性质
全被切割掉了
</li>
<li>不用pass-by-reference-to-const的唯一情况是1)内置类型2)STL的迭代器和函数对象
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4">Item 21: 必须返回对象时, 别妄想返回其reference</h3>
<div class="outline-text-3" id="text-4-4">
<ul class="org-ul">
<li>说到返回值,在c++中是可以返回一个对象的.方法入下,其实这就是最正常的写法
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #A7DBD8;">inline</span> <span style="color: #A7DBD8;">const</span> <span style="color: #999999;">Rational</span> <span style="color: #A7DBD8;">operator</span><span style="color: #AEE239;">*</span>(<span style="color: #A7DBD8;">const</span> <span style="color: #999999;">Rational</span>&amp; <span style="color: #FD971F;">lhs</span>, <span style="color: #A7DBD8;">const</span> <span style="color: #999999;">Rational</span>&amp; <span style="color: #FD971F;">rhs</span>) {
    <span style="color: #A7DBD8;">return</span> Rational(lhs.n * rhs.n, lhs.d * rhs.d);
}
</pre>
</div>
</li>
<li>在Item20的影响下,可能会想到返回值"也用reference", 其实这是非常危险的, 因为reference
不是单独存在的,一个reference一定有一个"实体", 比如下面这个例子. 返回值reference其实
对应的是一个local的result对象, 一旦从函数返回,那么local的result就被销毁了.返回一个
已经销毁的,不存在的"实体"的reference是非常可怕的
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #A7DBD8;">const</span> <span style="color: #999999;">Rational</span>&amp; <span style="color: #A7DBD8;">operator</span><span style="color: #AEE239;">*</span> (<span style="color: #A7DBD8;">const</span> <span style="color: #999999;">Rational</span>&amp; <span style="color: #FD971F;">lhs</span>,
                           <span style="color: #A7DBD8;">const</span> <span style="color: #999999;">Rational</span>&amp; <span style="color: #FD971F;">rhs</span>) {
    <span style="color: #505C63;">//</span><span style="color: #505C63;">&#35686;&#21578;!&#31967;&#31957;&#30340;&#20195;&#30721;!!</span>
    <span style="color: #999999;">Rational</span> <span style="color: #FD971F;">result</span>(lhs.n * rhs.n, lhs.d * rhs.d);
    <span style="color: #A7DBD8;">return</span> result;
}
</pre>
</div>
</li>
<li>我们稍微改变一下,在heap里面创建一个对象,然后返回,例子如下.
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #A7DBD8;">const</span> <span style="color: #999999;">Rational</span>&amp; <span style="color: #A7DBD8;">operator</span><span style="color: #AEE239;">*</span> (<span style="color: #A7DBD8;">const</span> <span style="color: #999999;">Rational</span>&amp; <span style="color: #FD971F;">lhs</span>,
                           <span style="color: #A7DBD8;">const</span> <span style="color: #999999;">Rational</span>&amp; <span style="color: #FD971F;">rhs</span>) {
    <span style="color: #999999;">Rational</span>* <span style="color: #FD971F;">result</span> = <span style="color: #A7DBD8;">new</span> <span style="color: #999999;">Rational</span>(lhs.n * rhs.n, lhs.d * rhs.d*);
    <span style="color: #A7DBD8;">return</span> *result;
}
</pre>
</div>
</li>
<li>这个例子其实也是不行的,因为释放内存的责任是调用者的,那就有可能会因为无法找到heapd的句柄,
无法释放内存,而发生内存泄漏. 比如下面, 调用了两次operator*, 那么就要释放两次内存,但是
却没有办法让operator* 使用者进行delete调用, 因为没有合理的办法让他们取得operator*返
回的references背后隐藏的那个指针.
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #999999;">Rational</span> <span style="color: #FD971F;">w</span>, <span style="color: #FD971F;">x</span>, <span style="color: #FD971F;">y</span>, <span style="color: #FD971F;">z</span>;
w = x * y *z;
</pre>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4-5" class="outline-3">
<h3 id="sec-4-5">Item 22: 讲成员变量声明为private</h3>
<div class="outline-text-3" id="text-4-5">
<ul class="org-ul">
<li>切记将成员变量声明为private, 因为这样有很多好处:
<ul class="org-ul">
<li>可以实现更精确的访问控制:如果是public的话,谁都可以访问,但是private你却可以设置成:
只读,不准访问,读写访问,只写访问, 等等
</li>
<li>一个变量声明为public那就意味着永远不可改变, 声明为private给了class作者有了更大的
实现弹性
</li>
</ul>
</li>
<li>protected其实是历史一流, 和public一样,没有任何的封装性.
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4-6" class="outline-3">
<h3 id="sec-4-6">Item 23: 宁以non-memeber, non-friend替换member函数</h3>
<div class="outline-text-3" id="text-4-6">
<ul class="org-ul">
<li>class的member函数和friend函数在访问private数据方面的权利是一样的,所以具有一样的,
所以封装效果是一样的.这里比较的是non-member, non-friend函数和member函数. 我们的
原则是:如果一个member函数可以用non-member,non-friend函数来替代,那么就替代
</li>
<li>下面是一个webBroswerStuff的例子, 这个例子有三个member函数,其中clearBrowser其实
可以用一个non-member, non-friend函数代替,这样就是增加了class的封装性
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #A7DBD8;">class</span> <span style="color: #999999;">WebBrowser</span>{
    <span style="color: #999999;">void</span> <span style="color: #AEE239;">clearCache</span>();
    <span style="color: #999999;">void</span> <span style="color: #AEE239;">clearHistory</span>();
    <span style="color: #999999;">void</span> <span style="color: #AEE239;">removeCookies</span>();
    <span style="color: #999999;">void</span> <span style="color: #AEE239;">clearBrowser</span>() {
        clearCache();
        clearHistory();
        removeCookies();
    }
};
</pre>
</div>
</li>
<li>用non-member, non-friend函数代替可以代替的member函数,并且使用一个namespace,是
c++常用的方法
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #A7DBD8;">namespace</span> <span style="color: #AEE239;">WebBrowserStuff</span>{
    <span style="color: #A7DBD8;">class</span> <span style="color: #999999;">WebBrowser</span>{
        <span style="color: #999999;">void</span> <span style="color: #AEE239;">clearCache</span>();
        <span style="color: #999999;">void</span> <span style="color: #AEE239;">clearHistory</span>();
        <span style="color: #999999;">void</span> <span style="color: #AEE239;">removeCookies</span>();
    };
    <span style="color: #999999;">void</span>  <span style="color: #AEE239;">clearBrowser</span>(<span style="color: #999999;">WebBrowser</span>&amp; <span style="color: #FD971F;">wb</span>){
        wb.clearCache();
        wb.clearHistory();
        wb.removeCookies();
    }
}
</pre>
</div>
</li>
<li>话说,namespace是STL里面组织代码的主要方式,因为namespace可以跨越不同的文件
(class不行), std命名空间分布在数十个头文件(&lt;vector&gt;, &lt;algorithm&gt;, &lt;memory&gt;
里面等等), 用户想用某个就include某一个头文件. (class就不行,class无法分割)
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4-7" class="outline-3">
<h3 id="sec-4-7">Item 24: 若所有参数皆需类型转换,请为此采用non-member函数</h3>
<div class="outline-text-3" id="text-4-7">
<ul class="org-ul">
<li>这个item其实是讲如何在c++中把事情做对,而不是怎样做更好. 比如,一开始把operator*
实现成成员变量的化,碰到result = 2 * oneHalf, 必然会编译器报错,然后修改也不迟.
</li>
<li>错误的operator* 实现
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #A7DBD8;">class</span> <span style="color: #999999;">Rational</span> {
<span style="color: #AEE239;">pulic</span>:
    <span style="color: #505C63;">//</span><span style="color: #505C63;">...</span>
    <span style="color: #505C63;">// </span><span style="color: #505C63;">NOT work for result = 2 * oneHalf</span>
    <span style="color: #A7DBD8;">const</span> <span style="color: #999999;">Rational</span> <span style="color: #A7DBD8;">operator</span><span style="color: #AEE239;">*</span>(<span style="color: #A7DBD8;">const</span> <span style="color: #999999;">Rational</span>&amp; <span style="color: #FD971F;">rhs</span>) <span style="color: #A7DBD8;">const</span>;
};
</pre>
</div>
</li>
<li>正确的operator*是一个non-member, 借用numberator()和denominator()函数读取
private值,而不是设计成有元函数
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #A7DBD8;">class</span> <span style="color: #999999;">Rational</span> {
    <span style="color: #505C63;">//</span><span style="color: #505C63;">...</span>
};

<span style="color: #A7DBD8;">const</span> <span style="color: #999999;">Rational</span> <span style="color: #A7DBD8;">operator</span><span style="color: #AEE239;">*</span>(lhs.numberator() * rhs.numberator(),
                         lhs.denominator() * rhs.denominator()) {
    <span style="color: #A7DBD8;">return</span> Rational(lhs.numberator() * rhs.numberator(),
                    lhs.denominator() * rhs.denominator());
}
</pre>
</div>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-4-8" class="outline-3">
<h3 id="sec-4-8">Item 25: 考虑写出一个不抛出异常的swap函数</h3>
<div class="outline-text-3" id="text-4-8">
<ul class="org-ul">
<li>当std::swap对你的类型效率不高的时候,提供一个swap成员函数, 并确定这个函数不
抛出异常
</li>
<li>如果你提供了一个member swap,也应该提供改一改non-member swap来调用前者,对于
classes(而不是templates), 也请特化std::swap
</li>
<li>对自己特例化的swap调用方式是先using, 再调用swap,而且没有直接写std::swap,这
源于编译器对namespace的名字查找时, 遵循的一系列规则
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #A7DBD8;">class</span> <span style="color: #999999;">Widget</span> {
<span style="color: #A7DBD8;">public</span>:
    <span style="color: #505C63;">//</span><span style="color: #505C63;">...</span>
    <span style="color: #999999;">void</span> <span style="color: #AEE239;">swap</span>(<span style="color: #999999;">Widget</span>&amp; <span style="color: #FD971F;">other</span>) {
        <span style="color: #A7DBD8;">using</span> <span style="color: #AEE239;">std</span>::<span style="color: #999999;">swap</span>;
        swap(pImpl, other.pImpl);
    }
    <span style="color: #505C63;">//</span><span style="color: #505C63;">...</span>
};
<span style="color: #A7DBD8;">namespace</span> <span style="color: #AEE239;">std</span> {
    <span style="color: #A7DBD8;">template</span>&lt;&gt;
    <span style="color: #999999;">void</span> <span style="color: #999999;">swap</span>&lt;<span style="color: #999999;">Widget</span>&gt;(<span style="color: #999999;">Widget</span>&amp; <span style="color: #FD971F;">a</span>, <span style="color: #999999;">Widget</span>&amp; <span style="color: #FD971F;">b</span>) {
        a.swap(b);
    }
}
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>

<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">Chapter 5: 实现</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">Item 26: 尽可能延后变量定义式出现时间</h3>
<div class="outline-text-3" id="text-5-1">
<ul class="org-ul">
<li>在老的c语言规范里面(C89/90)里面, 变量只能定义在block开始的地方.注意!!不是
function开始的地方, 即便是C89/90, 把所有变量都定义在函数开始的地方是非常
不明智的, 因为这样会导致逻辑不清晰, 变量作用域模糊的代码
</li>
<li>对于C++来说,变量"直到需要的时候"才定义,有更多的好处:
<ul class="org-ul">
<li>变量作用域更清晰, 下面的成本如下(但是方法B更清晰,作用域更准确):
<ol class="org-ol">
<li>方法A : 1个构造函数 + 1个析构函数 + n个赋值操作
</li>
<li>方法B : n个构造函数 + n个析构函数
</li>
</ol>
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #505C63;">// </span><span style="color: #505C63;">&#26041;&#27861;A, &#23450;&#20041;&#20110;&#24490;&#29615;&#22806;</span>
<span style="color: #999999;">Widget</span> <span style="color: #FD971F;">w</span>;

<span style="color: #A7DBD8;">for</span> (<span style="color: #999999;">int</span> <span style="color: #FD971F;">i</span> = 0; i &lt; n; ++i) {
    w = &#21462;&#20915;&#20110;i&#30340;&#26576;&#20010;&#20540;;
    <span style="color: #505C63;">//</span><span style="color: #505C63;">...</span>
}

<span style="color: #505C63;">// </span><span style="color: #505C63;">&#26041;&#27861;B, &#23450;&#20041;&#20110;&#24490;&#29615;&#20869;</span>
<span style="color: #A7DBD8;">for</span> (<span style="color: #999999;">int</span> <span style="color: #FD971F;">i</span> = 0; i &lt; n; ++i) {
    <span style="color: #999999;">Widget</span> <span style="color: #FD971F;">w</span>(&#21462;&#20915;&#20110;i&#30340;&#26576;&#20010;&#20540;);
    <span style="color: #505C63;">//</span><span style="color: #505C63;">...</span>
}
</pre>
</div>
</li>
<li>防止"定义了不使用"(由于异常的存在,当然异常现在不推荐使用)
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #AEE239;">std</span>::<span style="color: #999999;">string</span> <span style="color: #AEE239;">encryptPassword</span>(<span style="color: #A7DBD8;">const</span> <span style="color: #AEE239;">std</span>::<span style="color: #999999;">string</span>&amp; <span style="color: #FD971F;">password</span>) {
    <span style="color: #A7DBD8;">using</span> <span style="color: #A7DBD8;">namespace</span> <span style="color: #AEE239;">std</span>;
    <span style="color: #999999;">string</span> <span style="color: #FD971F;">encrypted</span>;

    <span style="color: #A7DBD8;">if</span> (password.length() &lt; MinimumPasswordLength) {
        <span style="color: #A7DBD8;">throw</span> logic_error(<span style="color: #F8F8F0;">"Password is too short"</span>);
    }

    <span style="color: #505C63;">//</span><span style="color: #505C63;">...</span>
    <span style="color: #A7DBD8;">return</span> encrypted; <span style="color: #505C63;">//</span><span style="color: #505C63;">May NOT be used!</span>
}
</pre>
</div>
</li>
<li>直到真正需要的时候,就意味着大多数情况下这个变量已经有了一个靠谱的初始化
值,那么就可以用"直接在构造的时候指定初始值", 这效率比起"通过default构造
函数构造出一个对象,然后对它复制"效果好
<div class="org-src-container">

<pre class="src src-c++"><span style="color: #AEE239;">std</span>::<span style="color: #999999;">string</span> <span style="color: #AEE239;">encryptPassword</span>(<span style="color: #A7DBD8;">const</span> <span style="color: #AEE239;">std</span>::<span style="color: #999999;">string</span>&amp; <span style="color: #FD971F;">password</span>) {
    <span style="color: #505C63;">// </span><span style="color: #505C63;">&#26816;&#26597;&#38271;&#24230;</span>
    <span style="color: #AEE239;">std</span>::<span style="color: #999999;">string</span> <span style="color: #FD971F;">encrypted</span>(password);

    encrypt(encrypted);
    <span style="color: #A7DBD8;">return</span> encrypted;
}
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>

<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">Item 27: 尽量少做转型动作</h3>
<div class="outline-text-3" id="text-5-2">
<ul class="org-ul">
<li>c语言的转型
</li>
<li>c++有四种新型的转型:
<ul class="org-ul">
<li>const_cast 将对象的常量性去除(cast away the constness)
</li>
<li>dynamic_cast 执行"安全向下转型" (safe downcasting), 也就是用来决定某对象
是否归属继承体系中的某个类型
</li>
<li>reinterpret_cast意图执行低级转型, 由于取决于编译器,也即表示它不可移植
</li>
<li>static_cast用来强迫隐式转换(implicit conversions).比如将non-const对象
转换为const对象, 或者将int转换为double. 但是无法将const转换为non-const,
只有const_cast才能做到
</li>
</ul>
</li>
<li>c++的新型转型语法更受欢迎, 因为:
<ul class="org-ul">
<li>很容易在代码中被辨识出来(相比较老的类型转换就一个括号), 也就容易查找到问题
</li>
<li>新型类型转换分成了四种,每种功能都限定在一个比较小的范围内,便于让编译器找到
问题
</li>
</ul>
</li>
<li></li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

         <!-- Duoshuo Comment BEGIN -->
         <div class="ds-thread"></div>
         <script type="text/javascript">
             var duoshuoQuery = {short_name:"harrifeng"};
             (function() {
             var ds = document.createElement('script');
             ds.type = 'text/javascript';ds.async = true;
             ds.src = 'http://static.duoshuo.com/embed.js';
             ds.charset = 'UTF-8';
             (document.getElementsByTagName('head')[0]
             || document.getElementsByTagName('body')[0]).appendChild(ds);
             })();
         </script>
         <!-- Duoshuo Comment END -->
</div>
</body>
</html>
