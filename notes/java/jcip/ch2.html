<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Chapter 2</title>
<!-- 2015-03-18 Wed 14:16 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="your name" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>

         <link href="http://fonts.googleapis.com/css?family=Droid+Sans+Mono|Galdeano|Open+Sans:600italic,400,600|Roboto+Condensed:400,700" rel="stylesheet" type="text/css">
         <link rel="stylesheet" type="text/css" href="/static/css/main.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="http://harrifeng.github.io/sitemap.html"> UP </a>
 |
 <a accesskey="H" href="http://harrifeng.github.io/index.html"> HOME </a>
</div><div id="preamble" class="status">

         <div id="header">
            <div id="header-top">
                <div id="blog-title">Harrifeng's Path</div>
                <div id="blog-sub-title">纸上得来终觉浅,绝知此事要Coding</div>
            </div>
            <div id="nav">
                <ul>
                    <li><a href="/">首页</a></li>
                    <li><a href="/notes.html">读书笔记</a></li>
                    <li><a href="/algo.html">算法</a></li>
                    <li><a href="/about.html">About Me</a></li>
                    <li>
                    </li>
                </ul>
            </div>
         </div>
</div>
<div id="content">
<h1 class="title">Chapter 2</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Thread Safety</a>
<ul>
<li><a href="#sec-1-1">What is Thread Safety:</a>
<ul>
<li><a href="#sec-1-1-1">Example: A Statelses Servlet</a></li>
</ul>
</li>
<li><a href="#sec-1-2">Atomicity</a>
<ul>
<li><a href="#sec-1-2-1">Race Conditions</a></li>
<li><a href="#sec-1-2-2">Example: Race Conditions in Lazy Initialization</a></li>
<li><a href="#sec-1-2-3">Compound Actions</a></li>
</ul>
</li>
<li><a href="#sec-1-3">Locking</a>
<ul>
<li><a href="#sec-1-3-1">Intrinsic Locks</a></li>
<li><a href="#sec-1-3-2">Reentrancy</a></li>
</ul>
</li>
<li><a href="#sec-1-4">Guarding State with Locks</a></li>
<li><a href="#sec-1-5">Liveness and Performance</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Thread Safety</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>有点令人出乎意料的是, 并发编程并不是和'线程或者锁'有很大关系.就像工程学也并不是
和'铆钉,工字梁'有很大关系(not &#x2026; any more than表示前后都否定: Concurrent
programming isn't so much about thread or locks, any more than civil engineering
is about rivets and I-beams)
</li>
<li>建造大桥,肯定要用很多的'铆钉,工字梁', 写多线程代码,也要用很多的'线程或者锁', 但这
只是表象和机制.
</li>
<li>写出线程安全代码更重的是管理"状态的准入"(accesss to state), 特别是对共享的(Shared state)
和可变的(Mutable state)状态的访问
</li>
<li>一般来说,一个对象的状态就是它的数据(存储在instance或者static field).
</li>
<li>某些情况下,一个对象的状态有时候也会和其他对象有关,这要看是哪种数据结构:比如
HashMap的状态一部分存在hashmap objec里面,另一部分存在成员Map.Entry里面
</li>
<li>比如下面的例子, hm里面肯定存有一部分状态,但是同时foo1,foo2里面也有,因
为java的hashmap其实存储的不过是一个reference, 下面例子中,通过1, hashmap
只能找到foo1这个object, foo的val值是多少,hashmap不会存储的
<div class="org-src-container">

<pre class="src src-java"><span style="color: #AE5825;">public</span> <span style="color: #AE5825;">class</span> <span style="color: #C6B032; font-style: italic;">TestCode</span> {
    <span style="color: #AE5825;">public</span> <span style="color: #AE5825;">static</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">main</span>(<span style="color: #C6B032; font-style: italic;">String</span>[] <span style="color: #46657B;">args</span>) {
        <span style="color: #C6B032; font-style: italic;">HashMap</span>&lt;<span style="color: #C6B032; font-style: italic;">Integer</span>, <span style="color: #C6B032; font-style: italic;">Foo</span>&gt; <span style="color: #46657B;">hm</span> = <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">HashMap</span>&lt;<span style="color: #C6B032; font-style: italic;">Integer</span>, <span style="color: #C6B032; font-style: italic;">Foo</span>&gt;();
        <span style="color: #C6B032; font-style: italic;">Foo</span> <span style="color: #46657B;">foo</span> = <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">Foo</span>(15);
        <span style="color: #C6B032; font-style: italic;">Foo</span> <span style="color: #46657B;">foo2</span> = <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">Foo</span>(35);
        hm.put(1, foo);
        hm.put(2, foo2);

        <span style="color: #AE5825;">for</span> (<span style="color: #86453A;">Map</span>.<span style="color: #C6B032; font-style: italic;">Entry</span>&lt;<span style="color: #C6B032; font-style: italic;">Integer</span>, <span style="color: #C6B032; font-style: italic;">Foo</span>&gt; e : hm.entrySet()) {
            System.out.println(e.getKey() + <span style="color: #5A7644;">" "</span> + e.getValue());
        }
        foo.setVal(115);
        System.out.println(hm.entrySet());
    }
}

<span style="color: #AE5825;">class</span> <span style="color: #C6B032; font-style: italic;">Foo</span>{
    <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">setVal</span>(<span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #46657B;">val</span>) {
        <span style="color: #AE5825;">this</span>.val = val;
    }

    <span style="color: #AE5825;">private</span> <span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #46657B;">val</span>;
    <span style="color: #AE5825;">public</span> <span style="color: #C6B032;">Foo</span>(<span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #46657B;">v</span>) {
        val = v;
    }

    <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">String</span> <span style="color: #C6B032;">toString</span>() {
        <span style="color: #AE5825;">return</span> <span style="color: #5A7644;">""</span> + val;
    }
}

<span style="color: #4C565D;">////////////////////////////////////////////////////</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">1 15                                           //</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">2 35                                           //</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">[1=115, 2=35]                                  //</span>
<span style="color: #4C565D;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>所谓"共享",是说一个变量可以被多个线程访问到,所谓"可变性"是说一个变量的值是可
以改变的.所谓线程安全,就是要防止"可变"的数据被"多个线程无法控制的并发访问"
</li>
<li>一个对象是否需要线程安全,不是看这个对象是"做什么的", 而是看他"怎么被使用"(是
否是被多个线程访问到)
</li>
<li>把一个对象做成thread-safe的话,就要求使用synchronization手段来使得"多个thread"
的访问"相互协调"
</li>
<li>我们这里说的"synchronization手段"包括如下形式:
<ul class="org-ul">
<li>synchronized关键字:其实就是'互斥锁'
</li>
<li>volatile关键字
</li>
<li>explicit lock
</li>
<li>atomic variable
</li>
</ul>
</li>
<li>如果多个线程访问同一个数据导致错误, 那么可以有如下几个方法来改正:
<ul class="org-ul">
<li>不要在线程直接分享state
</li>
<li>把state标记成immutable
</li>
<li>在所有能够访问到state的地方,使用synchronization
</li>
</ul>
</li>
<li>上面的建议看起来简单,但是如果你一开始设计的时候没有考虑到线程安全,那么改起来
确实是不那么容易,所以最好的方法,就是在你设计一个class的时候,就把他设计成线程
安全的
</li>
<li>把一个class设计成thread-safe,比你后来改写代码来控制对这个class的兵法访问,要
容易的多.
</li>
<li>在一个大型的系统上面,确认一个变量是否被多个线程访问,是非常困难的.幸运的是,面向
对象的很多设计方法能够帮助我们设计出更好,更容易维护的class. 比如封装和数据掩盖
可以帮助你更容易的设计线程安全:越少的代码能够接触到某些代码, 越容易保证使用的
同步性.
</li>
</ul>
</div>
<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">What is Thread Safety:</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>google下来thread-safe的定义一般是"一个类可以被多个thread访问,并且不需要在调
用类的代码里面做任何特殊的处理"
</li>
<li>这种定义非常模糊,因为"可以安全被多个thread"访问就是thread-safe,那么"thread-不
safe"是什么样子? safe是怎么个safe呢?都没有说清楚
</li>
<li>我们先定义correctness:"某个class如果是single-thread的话能够按照specification"
的要求,正确的运行.那么就是correct single-thread process
</li>
<li>如果一个类能在多个线程同时调用,且不管运行时如何调度其他线程, 都可以在调用代
码不用附加任何同步机制的情况下, 行为正常的运行, 那么就是thread-safe
<pre class="example">
A class is thread-safe if it behaves correctly when accessed
from multiple threads, regardless of the scheduling or interlevaing
of the execution of thosed threads by the runtime environment, and
with no additional synchronization other coordination on the part
of the calling code
</pre>
</li>
</ul>
</div>
<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">Example: A Statelses Servlet</h4>
<div class="outline-text-4" id="text-1-1-1">
<ul class="org-ul">
<li>第一章我们说过, 有些框架会创建线程然后从这些线程里面,调用你的代码, 从而要
求你自己的代码也是线程安全的. 其实很多时候,线程安全的要求,并非是你想要使用
线程,而是你想要使用某些功能,比如Servlet framework
</li>
<li>下面这个例子,从request接受请求,factor这个请求,然后放到response传回去
<div class="org-src-container">

<pre class="src src-java"><span style="color: #86453A;">@ThreadSafe</span>
<span style="color: #AE5825;">public</span> <span style="color: #AE5825;">class</span> <span style="color: #C6B032; font-style: italic;">StatelessFactorizer</span> <span style="color: #AE5825;">implements</span> <span style="color: #C6B032; font-style: italic;">Servlet</span> {
    <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">service</span>(<span style="color: #C6B032; font-style: italic;">ServletRequest</span> <span style="color: #46657B;">req</span>, <span style="color: #C6B032; font-style: italic;">ServletResponse</span> <span style="color: #46657B;">resp</span>) {
        <span style="color: #C6B032; font-style: italic;">BigInteger</span> <span style="color: #46657B;">i</span> = extractFromRequest(req);
        <span style="color: #C6B032; font-style: italic;">BigInteger</span>[] <span style="color: #46657B;">factors</span> = factor(i);
        encodeIntoResponse(resp, factors);
    }
}
</pre>
</div>
</li>
<li>StatelessFactorizer, 和大多数的servlet一样是没有状态的(stateless):
<ul class="org-ul">
<li>自己没有任何的数据
</li>
<li>也不引用任何其他类的数据
</li>
</ul>
</li>
<li>StatelessFactorizer拥有短暂的state, 局部变量, 但是这些局部变量是在线程
自己的stack上面的,只对当前运行的线程可见.线程A访问StatelessFactorizer不
会影响线程B访问StatelessFactorizer,因为他们之间不会共享state.
</li>
<li>因为一个线程访问stateless的对象不会影响其他线程的正确运行,所以,
<pre class="example">
stateless的对象总是线程安全的
</pre>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Atomicity</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>如果我们想加入一个变量来计算当前的处理的请求要求.那么一个常见的错误
加变量的方法:
<div class="org-src-container">

<pre class="src src-java"><span style="color: #86453A;">@NotThreadSafe</span>
<span style="color: #AE5825;">public</span> <span style="color: #AE5825;">class</span> <span style="color: #C6B032; font-style: italic;">UnsafeCountingFactorizer</span> <span style="color: #AE5825;">implements</span> <span style="color: #C6B032; font-style: italic;">Servlet</span> {
    <span style="color: #AE5825;">private</span> <span style="color: #C6B032; font-style: italic;">long</span> <span style="color: #46657B;">count</span> = 0;

    <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">long</span> <span style="color: #C6B032;">getCount</span>() {
        <span style="color: #AE5825;">return</span> count;
    }

    <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">service</span>(<span style="color: #C6B032; font-style: italic;">ServletRequest</span> <span style="color: #46657B;">req</span>, <span style="color: #C6B032; font-style: italic;">ServletRequest</span> <span style="color: #46657B;">resp</span>) {
        <span style="color: #C6B032; font-style: italic;">BigInteger</span> <span style="color: #46657B;">i</span> = extractFromRequest(req);
        <span style="color: #C6B032; font-style: italic;">BigInteger</span>[] <span style="color: #46657B;">factors</span> = factor(i);
        ++count;
        encodeIntoResponse(resp, factors);
    }
}
</pre>
</div>
</li>
<li>这种例子有个别名叫做read-modify-write的race condition:因为这个动作其实是三个
动作的合体:
<ol class="org-ol">
<li>fetch the current value
</li>
<li>add one to it
</li>
<li>write the new value back
</li>
</ol>
</li>
<li>atomicity的原则就是消灭上面的"三步走",把操作变成"一步走",就可以达到thread-safe
的目的
</li>
<li>第一章的例子已经讲到, 如果调度非常不幸运的话,会出现两个线程返回值相同的情况,
或许你觉得,极端返回一个相同的计数,这种低概率的精度错误可以忽略,那你可就打错特
错了. 如果这个计数是用来产生序列,或者对象标识的话,那么从不同的调用处得到相同
的这种标识(或者序列)会导致数据一致性的多种问题,最常见的就是race condition
</li>
</ul>
</div>
<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">Race Conditions</h4>
<div class="outline-text-4" id="text-1-2-1">
<ul class="org-ul">
<li>当一个正确的结果,需要依赖幸运的时机掌握的时候(不完全靠自己就行), 竞争环境就
会发生
</li>
<li>最常见的一种race condition就是check-then-act(要观察下当前的情况,然后做
决定):
<ul class="org-ul">
<li>某天你和X约好去大学城旁边的地铁站见面
</li>
<li>到了你发现有两家星巴克A和星巴克B
</li>
<li>你去星巴克A, 没发现X, 去星巴克B, 又没发现X. 然后去A,然后去B&#x2026;非常繁忙,
但是还是找不到X,这时候存在很多种情况:
<ol class="org-ol">
<li>你朋友就没来
</li>
<li>你朋友刚才才星巴克B,当你去星巴克B的时候,他已经去星巴克A啊.
</li>
</ol>
</li>
<li>有可能这个下午你可能都见不到你的朋友,因为你的策略是:
<ol class="org-ol">
<li>去某个星巴克,发现X不在check
</li>
<li>然后去另外一个星巴克then-act
</li>
</ol>
</li>
<li>问题的根源在于[去某个星巴克, 发现X不在], 这个过程只是"当时正确",一旦你离开
你的朋友X可能就来了. 这个观察是无效的,换句话说就是, "无效的观察,导致了大多
数的race condition"
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2">Example: Race Conditions in Lazy Initialization</h4>
<div class="outline-text-4" id="text-1-2-2">
<ul class="org-ul">
<li>另外一个使用check-then-act的例子是lazy initialization: getInstance首先
测算一下ExpensiveObject是不是已经创建了,如果还没有创建, 就创建,如果已经创建了
就返回存在的object
<div class="org-src-container">

<pre class="src src-java"><span style="color: #86453A;">@NotThreadSafe</span>
<span style="color: #AE5825;">public</span> <span style="color: #AE5825;">class</span> <span style="color: #C6B032; font-style: italic;">LazyInitRace</span> {
    <span style="color: #AE5825;">private</span> <span style="color: #C6B032; font-style: italic;">ExpensiveObject</span> <span style="color: #46657B;">instance</span> = <span style="color: #86453A;">null</span>;

    <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">ExpensiveObject</span> <span style="color: #C6B032;">getInstance</span>() {
        <span style="color: #AE5825;">if</span> (instance == <span style="color: #86453A;">null</span>) {
            instance = <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">ExpensiveObject</span>();
        }
    }
}
</pre>
</div>
</li>
<li>LazyInitRace也存在race condition: 线程A和B同时调用getInstance, A看到的是
null, 然后创建ExpensiveObject, 恰巧在创建的同时(unluck timing)B也看到的是
null, 然后也创建ExpensiveObject.所以不同的调用者会收到不同的对象
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2-3" class="outline-4">
<h4 id="sec-1-2-3">Compound Actions</h4>
<div class="outline-text-4" id="text-1-2-3">
<ul class="org-ul">
<li>LazyInitRace 和 UnsafeCountingFactorizer 的数据都需要一种原子性的操作,数据
更改的过程变的不可分: 保证其他线程观察或者修改state的时候,要么是在我们开始之前,
要么是在我们修改之后, 而不是在这两者之间
</li>
<li>为了保证线程安全,check-then-act(lazy initialization)和read-modify-write(increment)
操作都必须是原子性的.
</li>
<li>我们把check-then-act和read-modify-write这种必须通过原子性来保证线程
安全的操作叫做 compound action
<div class="org-src-container">

<pre class="src src-java"><span style="color: #86453A;">@ThreadSafe</span>
<span style="color: #AE5825;">public</span> <span style="color: #AE5825;">class</span> <span style="color: #C6B032; font-style: italic;">CountingFactorizer</span> <span style="color: #AE5825;">implements</span> <span style="color: #C6B032; font-style: italic;">Servlet</span> {
    <span style="color: #AE5825;">private</span> <span style="color: #AE5825;">final</span> <span style="color: #C6B032; font-style: italic;">AtomicLong</span> <span style="color: #46657B;">count</span> = <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">AtomicLong</span>(0);

    <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">long</span> <span style="color: #C6B032;">getCount</span>() {
        <span style="color: #AE5825;">return</span> count.get();
    }

    <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">service</span>(<span style="color: #C6B032; font-style: italic;">ServletRequest</span> <span style="color: #46657B;">req</span>, <span style="color: #C6B032; font-style: italic;">ServletRequest</span> <span style="color: #46657B;">resp</span>) {
        <span style="color: #C6B032; font-style: italic;">BigInteger</span> <span style="color: #46657B;">i</span> = extractFromRequest(req);
        <span style="color: #C6B032; font-style: italic;">BigInteger</span>[] <span style="color: #46657B;">factors</span> = factors(i);
        count.incrementAndGet();
        encodeIntoResponse(resp, factors);
    }
}
</pre>
</div>
</li>
<li>上面这个例子就是利用了java的java.util.concurrent.atomic, 这个package能够使
得一切操作原子化.
</li>
<li>在实际操作中,尽可能的使用已有的线程安全的类(比如AtomicLong)来管理类的状态.
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Locking</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>我们前面通过一个线程安全的AtomicLong类来管理计数,保证了整个大类的线程安全, 如果我
要加入更多,类型更为复杂(不是long)的state,我还可以像下面的例子一样,全部都使用Atomic
帮手(这里是AtomicReference)么
</li>
<li>比如为了提高servlet的效率,我们设计了一个cache的机制, 如果新的请求和上一个请求是一样
的,那么我们就可以不用重复计算,而直接返回上次的计算结果
<div class="org-src-container">

<pre class="src src-java"><span style="color: #86453A;">@NotThreadSafe</span>
<span style="color: #AE5825;">public</span> <span style="color: #AE5825;">class</span> <span style="color: #C6B032; font-style: italic;">UnsafeCachingFactorizer</span> <span style="color: #AE5825;">implements</span> <span style="color: #C6B032; font-style: italic;">Servlet</span> {
    <span style="color: #AE5825;">private</span> <span style="color: #AE5825;">final</span> <span style="color: #C6B032; font-style: italic;">AtomicReference</span>&lt;<span style="color: #C6B032; font-style: italic;">BigInteger</span>&gt; <span style="color: #46657B;">lastNumber</span>
        = <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">AtomicReference</span>&lt;<span style="color: #C6B032; font-style: italic;">BigInteger</span>&gt; ();
    <span style="color: #AE5825;">private</span> <span style="color: #AE5825;">final</span> <span style="color: #C6B032; font-style: italic;">AtomicReference</span>&lt;<span style="color: #C6B032; font-style: italic;">BigInteger</span>[]&gt; <span style="color: #46657B;">lastFactors</span>
        = <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">AtomicReference</span>&lt;<span style="color: #C6B032; font-style: italic;">BigInteger</span>[]&gt;();

    <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">service</span>(<span style="color: #C6B032; font-style: italic;">ServletRequest</span> <span style="color: #46657B;">req</span>, <span style="color: #C6B032; font-style: italic;">ServletResponse</span> <span style="color: #46657B;">resp</span>) {
        <span style="color: #C6B032; font-style: italic;">BigInteger</span> <span style="color: #46657B;">i</span> = extractFromRequest(req);
        <span style="color: #AE5825;">if</span> (i.equals(lastNumber.get())) {
            encodeIntoResponse(resp, lastFactors.get());
        } <span style="color: #AE5825;">else</span> {
            <span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">factor&#26159;&#22240;&#24335;&#20998;&#35299; 6 = 3 * 2</span>
            <span style="color: #C6B032; font-style: italic;">BigInteger</span>[] <span style="color: #46657B;">factors</span> = factor(i);
            lastNumber.set(i);
            lastFactors.set(factors);
            encodeIntoResponse(resp, factors);
        }
    }
}
</pre>
</div>
</li>
<li>尽管上面的例子中,每一个变量都是线程安全的,但是整个类却无法达到线程安全.
</li>
<li>线程安全的定义,要求"不变式"一直有效, 我们这个逻辑的"不变式"就是:
<pre class="example">
lastFactors中缓存的factors数组的乘积,应该等于lastNumber中缓存的数
</pre>
<p>
一定要是lastNumber计算的结果,
</p>
</li>
<li>很遗憾,上面的代码无法满足这个要求.除非我们"原子
性"的同时更新两个变量: 线程A获取这两个变量的时候(分两次),线程B可能已经更改了他们
</li>
</ul>
</div>
<div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1">Intrinsic Locks</h4>
<div class="outline-text-4" id="text-1-3-1">
<ul class="org-ul">
<li>java提供了一种最简单的内置锁,叫做同步代码块(synchronized block)
<div class="org-src-container">

<pre class="src src-java"><span style="color: #AE5825;">synchronized</span> (lock) {
    <span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">Access or modify shared state guarded by lock</span>
}
</pre>
</div>
</li>
<li>同步代码块包括了两个部分:
<ul class="org-ul">
<li>reference to an objct : 作为lock
</li>
<li>block of code : 作为被锁关照的部分
</li>
</ul>
</li>
<li>java中的所有对象都可以作为"lock"存在, 换句话说,所有的对象内部都实现了一个锁,
而java中所有的block(包括函数),都是在一定的object内部的(或者class内部, 比如
static method).所以最正常的方法是把ref to current object(也就是this)作为lock
<div class="org-src-container">

<pre class="src src-java"><span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">addName</span>(<span style="color: #C6B032; font-style: italic;">String</span> <span style="color: #46657B;">name</span>) {
    <span style="color: #AE5825;">synchronized</span>(<span style="color: #AE5825;">this</span>) {
        lastName = name;
        nameCount++;
    }
    nameList.add(name);
}
</pre>
</div>
</li>
<li>只有进入"同步代码块"才能获得锁,退出或者抛出异常才能放弃"锁", 同一时间之恩
能够有一个thread拥有这个锁
</li>
<li>同步函数(synchronized method)就是同步代码块的一个个例:
<ul class="org-ul">
<li>lock是调用这个函数的object:就不用特别指定了,其实就是this
</li>
<li>被锁关照的部分是整个函数: 函数的{},作为block
</li>
</ul>
</li>
<li>同步函数默认使用当前object的this,所以static method和common method所使用的
this是不同的,锁也就不同了.
</li>
<li>下面就是使用synchronized method来获得thread-safe的办法
<div class="org-src-container">

<pre class="src src-java"><span style="color: #86453A;">@ThreadSafe</span>
<span style="color: #AE5825;">public</span> <span style="color: #AE5825;">class</span> <span style="color: #C6B032; font-style: italic;">SynchronizedFactorizer</span> <span style="color: #AE5825;">implements</span> <span style="color: #C6B032; font-style: italic;">Servlet</span> {
    <span style="color: #86453A;">@GuardedBy</span>(<span style="color: #5A7644;">"this"</span>) <span style="color: #AE5825;">private</span> <span style="color: #C6B032; font-style: italic;">BigInteger</span> <span style="color: #46657B;">lastNumber</span>;
    <span style="color: #86453A;">@GuardedBy</span>(<span style="color: #5A7644;">"this"</span>) <span style="color: #AE5825;">private</span> <span style="color: #C6B032; font-style: italic;">BigInteger</span>[] <span style="color: #46657B;">lastFactors</span>;

    <span style="color: #AE5825;">public</span> <span style="color: #AE5825;">synchronized</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">service</span>(<span style="color: #C6B032; font-style: italic;">ServletRequest</span> <span style="color: #46657B;">req</span>,
                                     <span style="color: #C6B032; font-style: italic;">ServletResponse</span> <span style="color: #46657B;">resp</span>) {
        <span style="color: #C6B032; font-style: italic;">BigInteger</span> <span style="color: #46657B;">i</span> = extractFromRequest(req);
        <span style="color: #AE5825;">if</span> (i.equals(lastNumber)) {
            encodeIntoResponse(resp, lastFactors);
        } <span style="color: #AE5825;">else</span> {
            <span style="color: #C6B032; font-style: italic;">BigInteger</span>[] <span style="color: #46657B;">factors</span> = factor(i);
            lastNumber = i;
            lastFactors = factors;
            encodeIntoResponse(resp, factors);
        }
    }
}
</pre>
</div>
</li>
<li>这种原子化虽然达到了线程安全的目的,但是确是以巨大的效率牺牲为代价的:因为内置锁本
质上是一种互斥锁,同一时间只能有一个线程访问函数.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-3-2" class="outline-4">
<h4 id="sec-1-3-2">Reentrancy</h4>
<div class="outline-text-4" id="text-1-3-2">
<ul class="org-ul">
<li>内置锁都是可重入(renentrancy)的, 所谓可重入,就是说一个线程自己已经获得了某个内
置锁, 当它试图再次获得这个内置锁的时候,是成功的!
</li>
<li>java实现了可重用,意味着java的锁的是每个线程获取一次, 而不是Pthread里面的每
个调用获取一次
</li>
<li>可是一个线程为什么会再次请求自己已经拥有的锁呢? 在面向对象当中,这种例子非
常常见. 可以说可重入的设计,极大的简化了面向对象的并发开发.
<div class="org-src-container">

<pre class="src src-java"><span style="color: #AE5825;">public</span> <span style="color: #AE5825;">class</span> <span style="color: #C6B032; font-style: italic;">Widget</span> {
    <span style="color: #AE5825;">public</span> <span style="color: #AE5825;">synchronized</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">doSomething</span>() {
    }
}

<span style="color: #AE5825;">public</span> <span style="color: #AE5825;">class</span> <span style="color: #C6B032; font-style: italic;">LoggingWidget</span> <span style="color: #AE5825;">extends</span> <span style="color: #C6B032; font-style: italic;">Widget</span> {
    pblic <span style="color: #AE5825;">synchronized</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">doSomething</span>() {
        System.out.println(toString() + <span style="color: #5A7644;">": calling doSomething"</span>);
        <span style="color: #AE5825;">super</span>.doSomething();
    }
}
</pre>
</div>
</li>
<li>上面的例子中,如果内置锁不是可重入的话, 在调用super.doSomething()的时候,就会永
远的等待下去,(因为子类的doSomething开始的时候,肯定会获取内置锁,而调用super父类
函数的时候,会再次试图获取内置锁)
</li>
<li>java实现内置锁的可重入的方法,就是计数,线程首次获得这个锁,计数为0, 如果其他线程线
程来,发现是0,就等待,而本线程再次获取这个锁,会导致计数变成1
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">Guarding State with Locks</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>我们上一节介绍了锁(主要是同步代码块), 是通过对"一个block"的访问限制(每次一
个访问)来达到对state排他("eclusive")访问的
</li>
<li>前面说到的check-then-act和read-modify-write需要的是atomic(一个操作之内的不间
断性), 当然可以用锁实现这种atomic(只有一个线程访问,当然是atomic的), 但是要变得非常复杂:
</li>
<li>锁的引入,让多线程有序访问变量(一个接一个,而不是同时)变得方便. 前面说到的check-then-act
和read-modify-write也可以使用锁, 但是要变得非常复杂:
<ul class="org-ul">
<li>在整个 compound action的过程当中都要用锁
</li>
<li>每个变量用到的地方还要用锁, 比如上面CountingFactorizer例子中,每次变量被使
用的时候,都是使用的自己的操作(比如.get(), .incrementAndGet())
</li>
</ul>
</li>
<li>一个常见的错误是,认为只有'共享变量被写入的时候,才需要锁',这是不对的.
<pre class="example">
For each mutable state variable that my be accessed by more than one thread,
all accesses to that variable must be performed with the same lock held. In this
case, we say that the variable is 'guarded by that lock'.
</pre>
</li>
<li>上面的定义,终于点了我们的题:guarding state with locks: 一个state是不是被保护
了,是看你是否synchronized了所有的access, 如果能成功保护了的话,可以使用@Guardedby
annotion来标记(Guardedby更多的是一种文档,起作用的还是synchronized), 再来看看
上一遍synchronized method的例子:
<div class="org-src-container">

<pre class="src src-java"><span style="color: #86453A;">@ThreadSafe</span>
<span style="color: #AE5825;">public</span> <span style="color: #AE5825;">class</span> <span style="color: #C6B032; font-style: italic;">SynchronizedFactorizer</span> <span style="color: #AE5825;">implements</span> <span style="color: #C6B032; font-style: italic;">Servlet</span> {
    <span style="color: #86453A;">@GuardedBy</span>(<span style="color: #5A7644;">"this"</span>) <span style="color: #AE5825;">private</span> <span style="color: #C6B032; font-style: italic;">BigInteger</span> <span style="color: #46657B;">lastNumber</span>;
    <span style="color: #86453A;">@GuardedBy</span>(<span style="color: #5A7644;">"this"</span>) <span style="color: #AE5825;">private</span> <span style="color: #C6B032; font-style: italic;">BigInteger</span>[] <span style="color: #46657B;">lastFactors</span>;

    <span style="color: #AE5825;">public</span> <span style="color: #AE5825;">synchronized</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">service</span>(<span style="color: #C6B032; font-style: italic;">ServletRequest</span> <span style="color: #46657B;">req</span>,
                                     <span style="color: #C6B032; font-style: italic;">ServletResponse</span> <span style="color: #46657B;">resp</span>) {
        <span style="color: #C6B032; font-style: italic;">BigInteger</span> <span style="color: #46657B;">i</span> = extractFromRequest(req);
        <span style="color: #AE5825;">if</span> (i.equals(lastNumber)) {
            encodeIntoResponse(resp, lastFactors);
        } <span style="color: #AE5825;">else</span> {
            <span style="color: #C6B032; font-style: italic;">BigInteger</span>[] <span style="color: #46657B;">factors</span> = factor(i);
            lastNumber = i;
            lastFactors = factors;
            encodeIntoResponse(resp, factors);
        }
    }
}
</pre>
</div>
</li>
<li>一个'object的内置锁(synchronized(this))'和这个'object的state'之间是没有任何
联系的:一个object的state完全可以使用其他的object ref作为锁. 只不过在一个object
内部, 使用this作为锁是synchronized method的默认行为,这样做更简单.
</li>
<li>一种常见的locking策略,是把所有的mutable变量都加内置锁:方法是所有能够接触到这些mutable
变量的函数(或者path)都加synzhronized.有些jdk内部的实现,就把object的内置锁和
object的state强行联系起来了.比如Vector, 其所有函数都被synchronized保护了
<div class="org-src-container">

<pre class="src src-java"><span style="color: #AE5825;">public</span> <span style="color: #AE5825;">synchronized</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">ensureCapacity</span>(<span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #46657B;">minCapacity</span>) {
    <span style="color: #AE5825;">if</span> (minCapacity &gt; 0) {
        modCount++;
        ensureCapacityHelper(minCapacity);
    }
}
</pre>
</div>
</li>
<li>Vector的这种做法其实是不太可取(虽然也凑合用), 因为一旦加入一个新的函数,忘了
加synchronized的话,就破坏了原来的约定.
</li>
<li>并不是每一个变量都需要加锁保护,但是如果这个变量能够被多个thread访问到,那么就
必须加锁保护
</li>
<li>更进一步的,如果class内部有两个变量都能被多个thread访问到, 而且class的'不变
式(正常工作的要求)'涉及道了这多个变量,那么这多个变量不仅仅要加锁,还要加"同一
个锁", 在class内部,这同一个锁就显然是this(内置锁), 其他锁当然也可以,只要是
同一个锁
<pre class="example">
For every invariant that involves more than one variabl, all the variables
involved in that invariant must be guarded by the same lock
</pre>
</li>
<li>既然synchronized是治愈race condition的良药,为什么说前面的Vector'给所有method
都加synchronized'的方法是不妥的呢?原因有如下:
<ul class="org-ul">
<li>即便为每一个method都加了锁,这些method配合的时候,还是会导致race condition,
比如下面的contains和add都加了锁,但是这两个动作之间,锁可能还是会丢失(因为执
行完contains, 某个thread就会离开Vector block), 从而导致race condition
<div class="org-src-container">

<pre class="src src-java"><span style="color: #AE5825;">if</span> (!vector.contains(element)) {
    vector.add(element);
}
</pre>
</div>
</li>
<li>为每个method加锁,还会导致liveness或者performance问题
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">Liveness and Performance</h3>
<div class="outline-text-3" id="text-1-5">
<ul class="org-ul">
<li>前面我们通过synchronized method来让serverlet的cache功能实现了thread-safe,但
是这样做存在着巨大的性能隐患:
<ul class="org-ul">
<li>每次只能有一个thread访问servlet,这违背了servlet需要被多个thread同时访问的设计初衷
</li>
<li>如果某个thread占用servlet时间过长会极大的影响server的响应率, 降低CPU的使用率
</li>
</ul>
</li>
<li>造成性能隐患的原因是我们锁的层次太高了, 锁的内容太多,容易造成性能的缺失
</li>
<li>刚才我们的锁是加在了函数层次,这里我们可以重新设计代码,让锁的层次更低一些, 用
了两次synchronized(this)来替代原来的整个函数synchronized(注意hits, 和cacheHits
只是新加的bonus而已,不是非得要才能达到threadsafe
<div class="org-src-container">

<pre class="src src-java"><span style="color: #86453A;">@ThreadSafe</span>
<span style="color: #AE5825;">public</span> <span style="color: #AE5825;">class</span> CachedFactorizer <span style="color: #C6B032; font-style: italic;">impements</span> <span style="color: #C6B032; font-style: italic;">Servlet</span> {
    <span style="color: #86453A;">@GuardedBy</span>(<span style="color: #5A7644;">"this"</span>) <span style="color: #AE5825;">private</span> <span style="color: #C6B032; font-style: italic;">BigInteger</span> <span style="color: #46657B;">lastNumber</span>;
    <span style="color: #86453A;">@GuardedBy</span>(<span style="color: #5A7644;">"this"</span>) <span style="color: #AE5825;">private</span> <span style="color: #C6B032; font-style: italic;">BigInteger</span>[] <span style="color: #46657B;">lastFactors</span>;
    <span style="color: #86453A;">@GuardedBy</span>(<span style="color: #5A7644;">"this"</span>) <span style="color: #AE5825;">private</span> <span style="color: #C6B032; font-style: italic;">long</span> <span style="color: #46657B;">hits</span>;
    <span style="color: #86453A;">@GuardedBy</span>(<span style="color: #5A7644;">"this"</span>) <span style="color: #AE5825;">private</span> <span style="color: #C6B032; font-style: italic;">long</span> <span style="color: #46657B;">cacheHits</span>;

    <span style="color: #AE5825;">public</span> <span style="color: #AE5825;">synchronized</span> <span style="color: #C6B032; font-style: italic;">long</span> <span style="color: #C6B032;">getHits</span>() {
        <span style="color: #AE5825;">return</span> hits;
    }

    <span style="color: #AE5825;">public</span> <span style="color: #AE5825;">synchronized</span> <span style="color: #C6B032; font-style: italic;">double</span> <span style="color: #C6B032;">getCacheHitRatio</span>() {
        <span style="color: #AE5825;">return</span> (<span style="color: #C6B032; font-style: italic;">double</span>) cacheHits / (<span style="color: #C6B032; font-style: italic;">double</span>) hits;
    }

    <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">service</span>(<span style="color: #C6B032; font-style: italic;">ServletRequest</span> <span style="color: #46657B;">req</span>, <span style="color: #C6B032; font-style: italic;">ServletResponse</span> <span style="color: #46657B;">resp</span>) {
        <span style="color: #C6B032; font-style: italic;">BigInteger</span> <span style="color: #46657B;">i</span> = extractFromRequest(req);
        <span style="color: #C6B032; font-style: italic;">BigInteger</span>[] <span style="color: #46657B;">factors</span> = <span style="color: #86453A;">null</span>;
        <span style="color: #AE5825;">synchronized</span>(<span style="color: #AE5825;">this</span>) {
            ++hits;
            <span style="color: #AE5825;">if</span> (i.equals(lastNumber)) {
                ++cacheHits;
                factors = lastFactors.clone();
            }
        }
        <span style="color: #AE5825;">if</span> (factors == <span style="color: #86453A;">null</span>) {
            factors = factor(i);
            <span style="color: #AE5825;">synchronized</span>(<span style="color: #AE5825;">this</span>) {
                lastNumber = i;
                lastFactors = factors.clone();
            }
        }
        encodeIntoResponse(resp, factors);
    }
}
</pre>
</div>
</li>
<li>从代码中我们看到,因为使用了内置锁, AtomaticLong这种线程安全类的方式被抛弃了,因为两种
同步方式常常会引发错误
</li>
<li>我们代码加锁的区域不大,但是必要的地方也都加了锁, 这样既坚固了效率,又保障了安全
</li>
<li>不要试图在如下两种情况下加锁:
<ul class="org-ul">
<li>时间较长的计算
</li>
<li>有可能无法快速完成的任务(比如网络IO, 控制台IO)
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

         <!-- Disqus Comment BEGIN -->
          <div id="disqus_thread"></div>
          <script type="text/javascript">
              var disqus_shortname = 'harrifeng';

              (function() {
                  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
              })();
          </script>
          <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

         <!-- Disqus Comment END -->
</div>
</body>
</html>
