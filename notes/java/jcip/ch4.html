<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Chapter 4</title>
<!-- 2014-07-18 Fri 16:15 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="your name" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>

         <link href="http://fonts.googleapis.com/css?family=Droid+Sans+Mono|Galdeano|Open+Sans:600italic,400,600|Roboto+Condensed:400,700" rel="stylesheet" type="text/css">
         <link rel="stylesheet" type="text/css" href="/static/css/main.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="http://harrifeng.github.io/sitemap.html"> UP </a>
 |
 <a accesskey="H" href="http://harrifeng.github.io/index.html"> HOME </a>
</div><div id="preamble" class="status">

         <div id="header">
            <div id="header-top">
                <div id="blog-title">Harrifeng's Path</div>
                <div id="blog-sub-title">纸上得来终觉浅,绝知此事要Coding</div>
            </div>
            <div id="nav">
                <ul>
                    <li><a href="/">首页</a></li>
                    <li><a href="/notes.html">读书笔记</a></li>
                    <li><a href="/algo.html">算法</a></li>
                    <li><a href="/about.html">About Me</a></li>
                    <li>
                    </li>
                </ul>
            </div>
         </div>
</div>
<div id="content">
<h1 class="title">Chapter 4</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Composing Objects</a>
<ul>
<li><a href="#sec-1-1">Designing a Thread-safe Class</a>
<ul>
<li><a href="#sec-1-1-1">Gathering Synchronization Requirements</a></li>
<li><a href="#sec-1-1-2">State-dependent Operations</a></li>
<li><a href="#sec-1-1-3">State Ownership</a></li>
</ul>
</li>
<li><a href="#sec-1-2">Instance Confinement</a>
<ul>
<li><a href="#sec-1-2-1">The Java Monitor Pattern</a></li>
<li><a href="#sec-1-2-2">Example: Tracking Fleet Vehicles</a></li>
</ul>
</li>
<li><a href="#sec-1-3">Delegating Thread Safety</a>
<ul>
<li><a href="#sec-1-3-1">Vehicle Tracker Using Delegation</a></li>
<li><a href="#sec-1-3-2">Independent State Variables</a></li>
<li><a href="#sec-1-3-3">When Delegation Fails</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Composing Objects</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>前面我们学到了如何在底层处理"线程安全"和"同步", 但是我们不希望分析每次内存访
问,分析, 然后来保证线程安全, 这一章就来分析如何使用线程安全的component来更加
容易的达到整体的线程安全
</li>
</ul>
</div>
<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Designing a Thread-safe Class</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>虽然我们可以把所有数据写成public,然后通过同步等手段来保证线程安全.但是显然
这样太麻烦了,远不如我们合理的利用"封装", 然后保证整个class的线程安全性.
</li>
<li>一个对象的state来源于他的数据域, 如果这些数据都是内置类型(primitive type)
的话, 这些数据就构成了整个对象的state.下面的例子中Counter只有一个内置类型
的数据,所以这唯一的数据线程安全了,整个对象就线程安全了.
<div class="org-src-container">

<pre class="src src-java"><span style="color: #268bd2; font-weight: bold;">@ThreadSafe</span>
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Counter</span> {
    <span style="color: #268bd2; font-weight: bold;">@GuardedBy</span>(<span style="color: #2aa198;">"this"</span>) <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #b58900;">long</span> <span style="color: #268bd2;">value</span> = 0;

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">synchronized</span> <span style="color: #b58900;">long</span> <span style="color: #268bd2;">getValue</span>() {
        <span style="color: #859900; font-weight: bold;">return</span> value;
    }
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">synchronized</span> <span style="color: #b58900;">long</span> <span style="color: #268bd2;">increment</span>() {
        <span style="color: #859900; font-weight: bold;">if</span> (value == <span style="color: #268bd2; font-weight: bold;">long</span>.MAX_VALUE) {
            <span style="color: #859900; font-weight: bold;">throw</span> <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">illegalStateException</span>(<span style="color: #2aa198;">"counter overflow"</span>);
        }
        <span style="color: #859900; font-weight: bold;">return</span> ++value;
    }
}
</pre>
</div>
</li>
<li>如果对象有多个数据域,那么肯定对象的state是和多个值相关的
</li>
<li>如果对象含有指向其他对象的域, 那么对象的state是和这些域都相关的.比如如果一个
LinkedList包含很多node,那么他的state就包括这些node的state
</li>
</ul>
</div>
<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">Gathering Synchronization Requirements</h4>
<div class="outline-text-4" id="text-1-1-1">
<ul class="org-ul">
<li>保证一个class的线程安全,其实就是保证在多个线程访问的情况下, 保证class的"不
变性": 这个不变性,需要我们对state加以控制:
<ul class="org-ul">
<li>这个state越小,越容易控制
</li>
<li>这就是为什么immutable 对象更容易控制,因为它只有一种state
</li>
</ul>
</li>
<li>上面的例子中, Counter的唯一一个域是value, 它是long, 取值范围是Long.MIN_VALUE
      和Long.MAX_VALUE. 但是因为是counter,所以负数是不合法的
</li>
<li>同样的,一些操作可以通过post-condition来判断现在的state是不是合法的, 比如
当前的counter是17,那么下一个唯一合法的数字是18.
</li>
<li>如果下一个state一定要来自于当前的state, 那么这种操作就必须是compound action(概
念来自第二章:我们把check-then-act和read-modify-write这种必须通过原子性来保证线
程安全的操作叫做compound action)
</li>
<li>并不是所有的操作都有要求和前一个state相关,比如测量当前的温度.就更上一次的温度没有
关系
</li>
<li>总结起来,如果遇到一下两种情况,那么一定要有"同步"来规划他们,如果没有下面两种情况,
那么你可以选择不使用"同步"来获得效率的提升:
<ul class="org-ul">
<li>数据的更新要依靠前一个state
</li>
<li>数据在更新的时候,可能会暂时的数据变成invalid
</li>
</ul>
</li>
<li>一个class可能会有多个的变量,然后他们共同维护一个不变式,比如一个Range类,有个最大
值,有个最小值. 你对最大值操作的时候,最小值也要一块加锁.不然的话你可能会在某个时段
处于"invalid"的状态: 所有关联的变量都在加锁的考虑范围内
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">State-dependent Operations</h4>
<div class="outline-text-4" id="text-1-1-2">
<ul class="org-ul">
<li>很多时候,某个对象存在一种叫做state-based的 precondition. 比如,一个队列里面必须
要有值,你才能从里面取值. 这个队列"非空"就是取值的precondition. 而需要precondition
的操作就叫做state-depdent.
</li>
<li>在单线程的程序中,如果precondition没有达到,那么相应的操作一定会失败的.但是在多线程
程序中,我们可以提供另外的选择,因为同一时段可能有其他线程放入数据,我们可以选择等一会
等有数据了再取.
</li>
<li>选择"等到有数据了通知我"的策略是和内置锁紧密联系的,非常难以实现.我们推荐使用已有的
库函数里面的类.比如BlockingQueue, Semaphore.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-1-3" class="outline-4">
<h4 id="sec-1-1-3">State Ownership</h4>
<div class="outline-text-4" id="text-1-1-3">
<ul class="org-ul">
<li>当我们要定义哪些变量组成对象的state的时候,我们只考虑了对象自己的数据."所有权(Ownership)"
这个概念,不是存在于语言里面的,而是一种class的设计.当你创建了一个HashMap的时候,你就
创建了多个对象: HashMap对象, 很多Map.Entry对象. 从逻辑上来讲,不止HashMap对象,其他
的Entry对象也是state的一个部分
</li>
<li>Java由于有GC的存在,我们很少去考虑"所有权"的问题了. 在java中一个对象封装了state,并且
拥有这个state. 只有你"拥有"这个state,你才能来决定应该采取怎样的同步策略.因为"拥有权"
就意味着"控制权"
</li>
<li>但是,如果一旦你把一个reference发布出去,给了一个mutable的对象,那么那就没有"独享"的
所有权,以及控制权了.
</li>
<li>另外,一般来说,一个类对它的ctor的参数是没有所有权的,对它的内部函数的参数传入变量也是
没有所有权的.
</li>
<li>Collection class经常出现所谓的"split ownership", 因为collection拥有collection
自己的state, 用户代码拥有collection里面的对象的state.
</li>
<li>一个"split ownership"的例子就是servlet框架里面ServletContext, 它提供了一个类似Map
的容器对象. 因为ServletContext会被多个线程同时访问.当Servlet需要从ServletContext
里面取得数据的时候,就一定要使用"同步方法"了,因为ServletContext里面的对象是application
拥有的. 所以访问他们的是application众多的线程.在使用的时候,还是要做到:
<ul class="org-ul">
<li>要么object本身就是thread-safe
</li>
<li>要么object是immutable
</li>
<li>要么object被锁保护.
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Instance Confinement</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>如果一个object不是thread-safe的,那么你依然可以通过如下的手段,使其在多线程的
环境中使用:
<ul class="org-ul">
<li>只能通过一个thread访问
</li>
<li>访问这个"线程不安全"的object的时候,一定记得加锁
</li>
</ul>
</li>
<li>我们也可以把一个线程不安全的object放入到另外的一个object里面
<pre class="example">
Encapsulating data within an object confines access to the data
to the object's methods, making it easier to ensure that the datat
is always accessed with the appropriate lock held
</pre>
</li>
<li>下面的例子中HashSet是线程不安全的, 但是通过把它设置为private, 而且把仅有的能
访问private变量的函数, addPersion和containsPerson进行lock
<div class="org-src-container">

<pre class="src src-java"><span style="color: #268bd2; font-weight: bold;">@ThreadSafe</span>
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">PersonSet</span> {
    <span style="color: #268bd2; font-weight: bold;">@GuardedBy</span>(<span style="color: #2aa198;">"this"</span>)
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">Set</span>&lt;Person&gt; mySet = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">HashSet</span>&lt;Person&gt;();

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">synchronized</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">addPerson</span>(<span style="color: #b58900;">Person</span> <span style="color: #268bd2;">p</span>) {
        mySet.add(p);
    }

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">synchronized</span> <span style="color: #b58900;">boolean</span> <span style="color: #268bd2;">containsPerson</span>(<span style="color: #b58900;">Person</span> <span style="color: #268bd2;">p</span>) {
        <span style="color: #859900; font-weight: bold;">return</span> mySet.contains(p);
    }
}
</pre>
</div>
</li>
<li>上例中的Person类需要threadsafe
</li>
<li>要注意不要泄漏哪怕是iterator给外界,这也会造成state escape,然后线程不再安全
</li>
</ul>
</div>
<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">The Java Monitor Pattern</h4>
<div class="outline-text-4" id="text-1-2-1">
<ul class="org-ul">
<li>Java monitor pattern仅仅是一种"约定俗成". 只要你使用lock把自己的state锁住
就可以了.用什么锁,无所谓. 比如下面,就是使用了一个private lock
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">PrivateLock</span> {
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">object</span> <span style="color: #268bd2;">myLock</span> = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Object</span>();
    <span style="color: #268bd2; font-weight: bold;">@GuardedBy</span>(<span style="color: #2aa198;">"myLock"</span>) <span style="color: #b58900;">Widget</span> <span style="color: #268bd2;">widget</span>;

    <span style="color: #b58900;">void</span> <span style="color: #268bd2;">someMethod</span>() {
        <span style="color: #859900; font-weight: bold;">synchronized</span>(myLock){
            <span style="color: #93a1a1;">// </span><span style="color: #93a1a1;">Access or modify the state of widget</span>
        }
    }
}
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2">Example: Tracking Fleet Vehicles</h4>
<div class="outline-text-4" id="text-1-2-2">
<ul class="org-ul">
<li>我们来看一个"追踪汽车位置"的应用:
<ul class="org-ul">
<li>VehicleTracker类用来把汽车id和他的位置进行包装
</li>
<li>view thread会取出某个汽车id,和他的位置,然后传递给显示器
<div class="org-src-container">

<pre class="src src-java">Map&lt;String, Point&gt; locations = vehicles.getLocations();
<span style="color: #859900; font-weight: bold;">for</span> (<span style="color: #b58900;">String</span> <span style="color: #268bd2;">key</span> : locations.keySet()) {
    renderVehicle(key, locations.get(key));
}
</pre>
</div>
</li>
<li>updater threads会从GPS(或者死机手动输入)取得汽车的新位置,然后更改
<div class="org-src-container">

<pre class="src src-java"><span style="color: #b58900;">void</span> <span style="color: #268bd2;">vehicleMoved</span>(<span style="color: #b58900;">VehicleMovedEvent</span> <span style="color: #268bd2;">evt</span>) {
    <span style="color: #b58900;">Point</span> <span style="color: #268bd2;">loc</span> = evt.getNewLocation();
    vehicles.setLocation(evt.getVehicleId(), loc.x, loc.y);
}
</pre>
</div>
</li>
</ul>
</li>
<li>由于view thread和updater thread都会同时访问data model, 所以thread safe对它
来说,是必须的.
</li>
<li>虽然内部的MutablePointer不是线程安全的, 但是我们只要包成tracker class线程
安全就可以了,因为所有的访问都是通过tracker class
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Delegating Thread Safety</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>Java monitor pattern的核心是,我们private所有的线程不安全的成员变量,然后"限制
并且lock"所有触及这些变量的函数
</li>
<li>但是如果一个class所有的变量都线程安全呢?答案是:在某些情况下,所有成员都线程安
全,合起来线程不安全&#x2026;
</li>
</ul>
</div>
<div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1">Vehicle Tracker Using Delegation</h4>
<div class="outline-text-4" id="text-1-3-1">
<ul class="org-ul">
<li>我们下面实现一个通过代理来"线程安全" 的例子. 所谓代理,就是把自己所有的state
不管线程安全不安全,都代理给一个"线程安全的state". 这样就可以保证万无一失了
</li>
<li>使用Immutable的Point, 这样,返回位置的时候,就不需要deepcopy了.直接返回就行,
因为immutable,也不怕被改
<div class="org-src-container">

<pre class="src src-java"><span style="color: #268bd2; font-weight: bold;">@Immutable</span>
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">Point</span> {
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">int</span> <span style="color: #268bd2;">x</span>, <span style="color: #268bd2;">y</span>;

    <span style="color: #859900; font-weight: bold;">public</span> Point(<span style="color: #b58900;">int</span> <span style="color: #268bd2;">x</span>, <span style="color: #b58900;">int</span> <span style="color: #268bd2;">y</span>) {
        <span style="color: #859900; font-weight: bold;">this</span>.x = x;
        <span style="color: #859900; font-weight: bold;">this</span>.y = y;
    }
}
</pre>
</div>
</li>
<li>下面就是代理版本的"追踪汽车位置"应用.需要深刻理解的是,我们返回的不再是一个,
个的snaphot(还是deepcopy的), 我们返回的是live的点(通过getLocations),会随着
我们内容的改变,而动态改变的
<div class="org-src-container">

<pre class="src src-java"><span style="color: #268bd2; font-weight: bold;">@ThreadSafe</span>
<span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">DelegatingVehicleTracker</span> {
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">ConcurrentMap</span>&lt;String, Point&gt; locations;
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">Map</span>&lt;String, Point&gt; unmodifiableMap;

    <span style="color: #859900; font-weight: bold;">public</span> DelegatingVehicleTracker(Map&lt;String, Point&gt; points) {
        locations = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">ConcurrentHashMap</span>&lt;String, Point&gt;(points);
        unmodifiableMap = Collections.unmodifiableMap(locations);
    }

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">Map</span>&lt;String, Point&gt; getLocations() {
        <span style="color: #859900; font-weight: bold;">return</span> unmodifiableMap;
    }

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">Point</span> <span style="color: #268bd2;">getLocation</span>(<span style="color: #b58900;">String</span> <span style="color: #268bd2;">id</span>) {
        <span style="color: #859900; font-weight: bold;">return</span> locations.get(id);
    }

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">setLocation</span>(<span style="color: #b58900;">String</span> <span style="color: #268bd2;">id</span>, <span style="color: #b58900;">int</span> <span style="color: #268bd2;">x</span>, <span style="color: #b58900;">int</span> <span style="color: #268bd2;">y</span>) {
        <span style="color: #859900; font-weight: bold;">if</span> (locations.replace(id, <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">Point</span>(x, y)) == <span style="color: #268bd2; font-weight: bold;">null</span>) {
            <span style="color: #859900; font-weight: bold;">throw</span> <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">IllegalArgumentException</span>(<span style="color: #2aa198;">"invaid vehicle name: "</span> + id);
        }
    }
}
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-3-2" class="outline-4">
<h4 id="sec-1-3-2">Independent State Variables</h4>
<div class="outline-text-4" id="text-1-3-2">
<ul class="org-ul">
<li>前面讲的代理是说,多个state代理给"一个线程安全的state". 如果你想的话,你也可
以把你的多个state代理给"多个相互之间没有关系的states"
<div class="org-src-container">

<pre class="src src-java"><span style="color: #859900; font-weight: bold;">public</span> <span style="color: #859900; font-weight: bold;">class</span> <span style="color: #b58900;">VisualComponent</span> {
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">List</span>&lt;KeyListener&gt; keyListeners
        = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">CopyOnWriteArrayList</span>&lt;KeyListener&gt;();
    <span style="color: #859900; font-weight: bold;">private</span> <span style="color: #859900; font-weight: bold;">final</span> <span style="color: #b58900;">List</span>&lt;MouseListener&gt; mouseListeners
        = <span style="color: #859900; font-weight: bold;">new</span> <span style="color: #b58900;">CopyOnWriteArrayList</span>&lt;MouseListener&gt;();

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">addKeyListener</span>(<span style="color: #b58900;">KeyListener</span> <span style="color: #268bd2;">listener</span>) {
        keyListeners.add(listener);
    }

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">addMouseListener</span>(<span style="color: #b58900;">MouseListener</span> <span style="color: #268bd2;">listener</span>) {
        mouseListeners.add(listener);
    }

    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">removeKeyListener</span>(<span style="color: #b58900;">KeyListener</span> <span style="color: #268bd2;">listener</span>) {
        keyListeners.remove(listener);
    }
    <span style="color: #859900; font-weight: bold;">public</span> <span style="color: #b58900;">void</span> <span style="color: #268bd2;">removeMouseListener</span>(<span style="color: #b58900;">MouseListener</span> <span style="color: #268bd2;">listener</span>) {
        mouseListeners.remove(listener);
    }
}
</pre>
</div>
</li>
<li>上例中使用的CopyOnWriteArrayList是一种thread-safe的List实现.其所有的可变操
作（add、set 等）都是通过对底层数组进行一次新的复制来实现的，代价昂贵.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-3-3" class="outline-4">
<h4 id="sec-1-3-3">When Delegation Fails</h4>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

         <!-- Disqus Comment BEGIN -->
          <div id="disqus_thread"></div>
          <script type="text/javascript">
              var disqus_shortname = 'harrifeng';

              (function() {
                  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
              })();
          </script>
          <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

         <!-- Disqus Comment END -->
</div>
</body>
</html>
