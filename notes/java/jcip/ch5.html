<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Chapter 5</title>
<!-- 2015-03-18 Wed 14:16 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="your name" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>

         <link href="http://fonts.googleapis.com/css?family=Droid+Sans+Mono|Galdeano|Open+Sans:600italic,400,600|Roboto+Condensed:400,700" rel="stylesheet" type="text/css">
         <link rel="stylesheet" type="text/css" href="/static/css/main.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="http://harrifeng.github.io/sitemap.html"> UP </a>
 |
 <a accesskey="H" href="http://harrifeng.github.io/index.html"> HOME </a>
</div><div id="preamble" class="status">

         <div id="header">
            <div id="header-top">
                <div id="blog-title">Harrifeng's Path</div>
                <div id="blog-sub-title">纸上得来终觉浅,绝知此事要Coding</div>
            </div>
            <div id="nav">
                <ul>
                    <li><a href="/">首页</a></li>
                    <li><a href="/notes.html">读书笔记</a></li>
                    <li><a href="/algo.html">算法</a></li>
                    <li><a href="/about.html">About Me</a></li>
                    <li>
                    </li>
                </ul>
            </div>
         </div>
</div>
<div id="content">
<h1 class="title">Chapter 5</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Building Blocks</a>
<ul>
<li><a href="#sec-1-1">Synchronized Collections</a>
<ul>
<li><a href="#sec-1-1-1">Problems with Synchronized Collections</a></li>
<li><a href="#sec-1-1-2">Iterators and Concurrentmodificationexception</a></li>
<li><a href="#sec-1-1-3">Hidden Iterators</a></li>
</ul>
</li>
<li><a href="#sec-1-2">Concurrent Collections</a>
<ul>
<li><a href="#sec-1-2-1">ConcurrentHashMap</a></li>
<li><a href="#sec-1-2-2">Additional Atomic Map Operations</a></li>
<li><a href="#sec-1-2-3">CopyOnWriteArrayList</a></li>
</ul>
</li>
<li><a href="#sec-1-3">Blocking Queues and the Producer-consumer Pattern</a>
<ul>
<li><a href="#sec-1-3-1">Example: Desktop Search</a></li>
<li><a href="#sec-1-3-2">Deques and Work Stealing</a></li>
</ul>
</li>
<li><a href="#sec-1-4">Blocking and Interruptible Methods</a></li>
<li><a href="#sec-1-5">Synchronizers</a>
<ul>
<li><a href="#sec-1-5-1">Latches</a></li>
<li><a href="#sec-1-5-2">FutureTask</a></li>
<li><a href="#sec-1-5-3">Semaphores</a></li>
<li><a href="#sec-1-5-4">Barriers</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Building Blocks</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>上一章,我们介绍了如何将class的thread-safety代理给某些已经thread-safe的class
从而做到class自己的thread safe
</li>
<li>java的lib在5.0和6.0引入了许多的concurrent building blocks,我们在这一章进行介
绍
</li>
</ul>
</div>
<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Synchronized Collections</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>synchronized collection class主要包括:
<ul class="org-ul">
<li>Vector
</li>
<li>HashTable
</li>
<li>Collections.synchronizedXXX factory methods
</li>
</ul>
</li>
<li>synchronized collection class的主要原理是:
<ul class="org-ul">
<li>encapsulating states (private 或者 protected-private)
</li>
<li>synchronized every public method, 从而保障每次只能有一个thread真正使用collection
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">Problems with Synchronized Collections</h4>
<div class="outline-text-4" id="text-1-1-1">
<ul class="org-ul">
<li>synchronized collection是thread-safe的,但是这只能保证你使用一个method之内
是thread-safe的,如果你要多个method连续使用,中间有被其他thread抢占lock的
可能.
</li>
<li>如果在你连续调用method的中间被其他thread抢占了lock, 你当前的调用会抛出异常
(而不会进入invalid state), 所以从技术角度讲,还算是thread-safe的
</li>
<li>compound action就是连续调用method,所以compound action在client side被使用的
时候,是需要额外加锁的. 常见的compound action主要有:
<ul class="org-ul">
<li>iteration : repleatedly fetch elements until the collection is exhausted
</li>
<li>navigation: find the next element after this one according to some order
</li>
<li>conditional operations such as put-if-absent : check if a Map has a mapping
for key K, and if not, add the mapping (K, V)
</li>
</ul>
</li>
<li>下面是一个compund action的例子: 一个client helper调用Vector的method来完成自己的method
<div class="org-src-container">

<pre class="src src-java"><span style="color: #AE5825;">package</span> org.hfeng.book.jcip.<span style="color: #86453A;">ch5</span>;

<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">util</span>.<span style="color: #C6B032; font-style: italic;">Vector</span>;

<span style="color: #AE5825;">public</span> <span style="color: #AE5825;">class</span> <span style="color: #C6B032; font-style: italic;">UnSafeVectorHelpers</span> {
    <span style="color: #AE5825;">public</span> <span style="color: #AE5825;">static</span> <span style="color: #C6B032; font-style: italic;">Object</span> <span style="color: #C6B032;">getLast</span>(<span style="color: #C6B032; font-style: italic;">Vector</span> <span style="color: #46657B;">list</span>) {
        <span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #46657B;">lastIndex</span> = list.size() - 1;
        <span style="color: #AE5825;">return</span> list.get(lastIndex);
    }

    <span style="color: #AE5825;">public</span> <span style="color: #AE5825;">static</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">deleteLast</span>(<span style="color: #C6B032; font-style: italic;">Vector</span> <span style="color: #46657B;">list</span>) {
        <span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #46657B;">lastIndex</span> = list.size() - 1;
        list.remove(lastIndex);
    }
}
</pre>
</div>
</li>
<li>上面的代码即便被多个thread同时访问,也"不会"破坏Vector,但是在多thread访问的
情况下却不会"完全按照"我们的想法运行
<pre class="example">
           +-----------+      +-----------+
Thread A   | size = 10 +-----&gt;| remove(9) |
           +-----------+      +-----------+

           +-----------+                     +-----------+    +-----------+
Thread B   | size = 10 +--------------------&gt;|  get(9)   +---&gt;|   boom    |
           +-----------+                     +-----------+    +-----------+
</pre>
</li>
<li>比如,当按照上图访问的顺序访问的时候:
<ul class="org-ul">
<li>Thread B在和Thread A的争夺中, 获得lock,调用size函数,获得size为10, 放弃lock
</li>
<li>Thread A在和Thread B的争夺中, 获得lock,调用size函数,获得size为10, 放弃lock
</li>
<li>Thread A在和Thread B的争夺中, 再次获得lock, 然后调用remove(9), 放弃lock
</li>
<li>Thread B在无其他Thread竞争的情况下,获得lock,然后调用get(9), 程序抛出异常
ArrayIndexOutOfBoundsException
</li>
</ul>
</li>
<li>上面本来在单线程访问的时候,正常的代码,由于有其他thread的同时运行,产生了意
想不到的结果(虽然还是thread-safe的,因为没有invalid state出现)
</li>
<li>为了防止上面的情况出现,我们查阅了synchronized collection的文档,得知,我们可
以使用client side的lock, 同时也必然通知了我们collection使用了intrinsic lock
<div class="org-src-container">

<pre class="src src-java"><span style="color: #AE5825;">package</span> org.hfeng.book.jcip.<span style="color: #86453A;">ch5</span>;

<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">util</span>.<span style="color: #C6B032; font-style: italic;">Vector</span>;

<span style="color: #AE5825;">public</span> <span style="color: #AE5825;">class</span> <span style="color: #C6B032; font-style: italic;">SafeVectorHelpers</span> {
    <span style="color: #AE5825;">public</span> <span style="color: #AE5825;">static</span> <span style="color: #C6B032; font-style: italic;">Object</span> <span style="color: #C6B032;">getLast</span>(<span style="color: #C6B032; font-style: italic;">Vector</span> <span style="color: #46657B;">list</span>) {
        <span style="color: #AE5825;">synchronized</span> (list) {
            <span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #46657B;">lastIndex</span> = list.size() - 1;
            <span style="color: #AE5825;">return</span> list.get(lastIndex);
        }
    }

    <span style="color: #AE5825;">public</span> <span style="color: #AE5825;">static</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">deleteLast</span>(<span style="color: #C6B032; font-style: italic;">Vector</span> <span style="color: #46657B;">list</span>) {
        <span style="color: #AE5825;">synchronized</span> (list) {
            <span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #46657B;">lastIndex</span> = list.size() - 1;
            list.remove(lastIndex);
        }
    }
}
</pre>
</div>
</li>
<li>下面的iteration也会遇到相同的情况(被其他thread抢到lock,然后自己的thread会
抛异常).
<div class="org-src-container">

<pre class="src src-java"><span style="color: #AE5825;">for</span> (<span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #46657B;">i</span> = 0; i &lt; vector.<span style="color: #C6B032; font-style: italic;">size</span>(); i++) {
    doSomething(vector.get(i));
}
</pre>
</div>
</li>
<li>解决方法也是client加锁
<div class="org-src-container">

<pre class="src src-java"><span style="color: #AE5825;">synchronized</span>(vector) {
    <span style="color: #AE5825;">for</span> (<span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #46657B;">i</span> = 0; i &lt; vector.<span style="color: #C6B032; font-style: italic;">size</span>(); i++) {
        doSomething(vector.get(i));
    }
}
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">Iterators and Concurrentmodificationexception</h4>
<div class="outline-text-4" id="text-1-1-2">
<ul class="org-ul">
<li>Vector的循环道size()是比较原始的遍历手段,比较新的java遍历手段是iterator,有
两种表现形式:
<ul class="org-ul">
<li>通过明确的Iterator
</li>
<li>通过foreach
</li>
</ul>
</li>
<li>iterator的手段并不是说能够"不显式加锁"就做到thread-safe,而是
<pre class="example">
把一个modification count和collection联系起来,在遍历的时候,如果发现
modification count改变了(通常是被其他thread改变)hasNext,或者next
就会抛出ConcurrentModificationException
</pre>
</li>
<li>下面就是一个Iterator的例子(通过foreach实现), 如果有其他thread来更改widgetList
的内容, foreach内部实现的hashNext就会抛ConcurrentModificationException,如果
想防止这种事情的发生,那么就必须synchronized(widgetList)
<div class="org-src-container">

<pre class="src src-java"><span style="color: #C6B032; font-style: italic;">List</span>&lt;<span style="color: #C6B032; font-style: italic;">widget</span>&gt; <span style="color: #46657B;">wdigetList</span> =
    Collections.synchronizedList(<span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">ArrayList</span>&lt;<span style="color: #C6B032; font-style: italic;">widget</span>&gt;());

<span style="color: #4C565D;">//</span><span style="color: #333B40; font-style: italic;">...</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">May throw ConcurrentModificationException</span>
<span style="color: #AE5825;">for</span> (<span style="color: #C6B032; font-style: italic;">widget</span> <span style="color: #46657B;">w</span> : widgetList) {
    doSomething(w);
}
</pre>
</div>
</li>
<li>上面的foreach会抛出异常,但是手段却"不是通过synchronized", 这种做法是存在如
下一种可能, 从而导致invalid state的
<pre class="example">
modification count的stale value被hasNext()看到了,从而导致iterator
没有意识到别的thread更改了数据
</pre>
</li>
<li>但是新的jdk这样做的原因是为了提高并发访问下, 程序performance的一种tradeoff
</li>
<li>foreach是由缺陷,但是在client side对遍历代码加锁的方法,缺陷更大:
<ul class="org-ul">
<li>其他的thread在你遍历的时候是无法进入的,如果遍历是一个非常漫长的过程,那么
这会极大的降低性能
</li>
<li>如果在for循环里面doSomething,的话,很可能会导致deadlock
</li>
</ul>
</li>
<li>另外一个遍历的方法是clone整个collection,然后遍历整个克隆.因为clone是thread-confined
所以不会存在线程安全的问题.当然了,性能方面是得优点损失.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-1-3" class="outline-4">
<h4 id="sec-1-1-3">Hidden Iterators</h4>
<div class="outline-text-4" id="text-1-1-3">
<ul class="org-ul">
<li>下面的例子,在最后输出DEBUG信息的时候,使用了+,也就会"遍历的"调用toString函数
<div class="org-src-container">

<pre class="src src-java"><span style="color: #AE5825;">package</span> org.hfeng.book.jcip.<span style="color: #86453A;">ch5</span>;

<span style="color: #AE5825;">import</span> <span style="color: #86453A;">org</span>.<span style="color: #86453A;">apache</span>.<span style="color: #86453A;">http</span>.<span style="color: #86453A;">annotation</span>.<span style="color: #C6B032; font-style: italic;">GuardedBy</span>;

<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">util</span>.<span style="color: #C6B032; font-style: italic;">HashSet</span>;
<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">util</span>.<span style="color: #C6B032; font-style: italic;">Random</span>;
<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">util</span>.<span style="color: #C6B032; font-style: italic;">Set</span>;

<span style="color: #AE5825;">public</span> <span style="color: #AE5825;">class</span> <span style="color: #C6B032; font-style: italic;">HiddenIterator</span> {
    <span style="color: #86453A;">@GuardedBy</span>(<span style="color: #5A7644;">"this"</span>)
    <span style="color: #AE5825;">private</span> <span style="color: #AE5825;">final</span> <span style="color: #C6B032; font-style: italic;">Set</span>&lt;<span style="color: #C6B032; font-style: italic;">Integer</span>&gt; <span style="color: #46657B;">set</span> = <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">HashSet</span>&lt;<span style="color: #C6B032; font-style: italic;">Integer</span>&gt;();

    <span style="color: #AE5825;">public</span> <span style="color: #AE5825;">synchronized</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">add</span>(<span style="color: #C6B032; font-style: italic;">Integer</span> <span style="color: #46657B;">i</span>) {
        set.add(i);
    }

    <span style="color: #AE5825;">public</span> <span style="color: #AE5825;">synchronized</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">remove</span>(<span style="color: #C6B032; font-style: italic;">Integer</span> <span style="color: #46657B;">i</span>) {
        set.remove(i);
    }

    <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">addTenThings</span>() {
        <span style="color: #C6B032; font-style: italic;">Random</span> <span style="color: #46657B;">r</span> = <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">Random</span>();
        <span style="color: #AE5825;">for</span> (<span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #46657B;">i</span> = 0; i &lt; 10; i++) {
            add(r.nextInt());
        }
        System.out.println(<span style="color: #5A7644;">"DEBUG: added ten elements to "</span> + set);
    }
}
</pre>
</div>
</li>
<li>"遍历的"调用toString函数,在多线程访问的情况下会导致抛出ConcurrentModificationException
</li>
<li>更重要的错误,是上面的代码thread-safe不safe(如果thread-safe了,可能会像for
size()循环一样返回其他异常), 因为println代码附近没有加锁!(调试代码经常忘了加锁)
</li>
<li>如果想让上面的代码变成thread-safe,那么一个可行的办法是把set的类型声明成synchronizedSet,
此外就不需要再加其他同步手段.这等于把同步封装在了class的成员变量里面
<pre class="example">
Just as encapsulating a object's state make it easier to preserve
its invariants, encapsulating its synchronization makes it easier
to enforce its synchronization policy
</pre>
</li>
<li>Iteration还会出现在调用collection的hashCode和equals函数的时候(因为collection
会把所有的成员都遍历一遍,计算自己的hashCode),所有这种"隐藏"的遍历,都可能会
抛出ConcurrentModificationException
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">Concurrent Collections</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>Java 5.0的贡献,就是提供了concurrent collection class:
<ul class="org-ul">
<li>jdk 1.0开始提供的synchronized collection是通过每次"只允许一个thread access"
collection来做到线程安全的,这种做法的代价太大,效率太低
</li>
<li>而concurrent collection则采取了完全不同的策略:它允许多个thread共同访问collection
</li>
</ul>
</li>
<li>Java 5.0几个常见的concurrent collection是
<ul class="org-ul">
<li>ConcurrentHashMap -&gt; Hashed Maps
</li>
<li>CopyOnWriteArrayList -&gt; Lists
</li>
<li>interface ConcurrentMap 新增了put-if-absent, replace, conditional remove等
操作
</li>
</ul>
</li>
<li>Java 5.0增加了两个新的collection type:
<ul class="org-ul">
<li>Queue(interface) : 提供了排队策略. 如果队列是空的,从这个队列retrieval的操作
就会返回空. 继承这个接口的主要有如下
<ul class="org-ul">
<li>LinkedList (FIFO, 非concurrent)
</li>
<li>ConcurrentLinkedQueue(FIFO, concurrent)
</li>
<li>PriorityQueue (优先队列, 非concurrent)
</li>
</ul>
</li>
<li>BlockingQueue(interface): 其extends了Queue, 也就有了Queue所有的功能,只是如
果队列是空的,从这个队列retrieval element的操作会block,等待其他thread放进去!
相似的,如果队列是满的,向里面加入element的操作也会block.这对于Producer-consumer
设计来说很适用
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">ConcurrentHashMap</h4>
<div class="outline-text-4" id="text-1-2-1">
<ul class="org-ul">
<li>synchronized collection的每一个操作,都必须一直hold住锁,但是很多的操作非常费
时间,比如HashTable.get或者是Vector.contains(因为要遍历整个数据结构, 对于HashTable
来说,有时候hash function设计不好,hashCode的collision过多,如果collision出现
冲突,那么那个hash table entry就需要一个LinkedList来防止所有的值). 这样一来
在寻找的时候,就会让其他thread等待过久
</li>
<li>ConcurrentHashMap是一个hash-based Map, 只不过它使用了一个完全不同的lock策略
来加锁, 总结起来就是:
<ul class="org-ul">
<li>很多reader可以共同外加writer访问map
</li>
<li>限定个数的writer(不止一个)可以和reader一起访问map
</li>
</ul>
</li>
<li>Concurrent collection的另外一个提升是:
<ul class="org-ul">
<li>他们提供了不会抛出异常的iterator, 这样一来就不必再iterator的时候对collection加锁了
</li>
<li>他们提供的iterator可以容忍concurrent的改动(也就是说在遍历的同时,更改map的
值是被允许的,不会抛出异常的), 虽然可以容忍concurrent的改动,但是最后只能
"尽最大努力"的反应当时concurrent map的状况,不保证完全重现.这和原来synchronized
的map实现是不一样
<div class="org-src-container">

<pre class="src src-java"><span style="color: #AE5825;">package</span> org.hfeng.book.jcip.<span style="color: #86453A;">ch5</span>;

<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">util</span>.<span style="color: #C6B032; font-style: italic;">HashMap</span>;
<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">util</span>.<span style="color: #C6B032; font-style: italic;">Iterator</span>;
<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">util</span>.<span style="color: #C6B032; font-style: italic;">Map</span>;
<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">util</span>.<span style="color: #86453A;">concurrent</span>.<span style="color: #C6B032; font-style: italic;">ConcurrentHashMap</span>;

<span style="color: #AE5825;">public</span> <span style="color: #AE5825;">class</span> <span style="color: #C6B032; font-style: italic;">ConcurrentHashMapExample</span> {
    <span style="color: #AE5825;">public</span> <span style="color: #AE5825;">static</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">main</span>(<span style="color: #C6B032; font-style: italic;">String</span>[] <span style="color: #46657B;">args</span>) {
        <span style="color: #4C565D;">//</span><span style="color: #333B40; font-style: italic;">ConcurrentHashMap</span>
        <span style="color: #C6B032; font-style: italic;">Map</span>&lt;<span style="color: #C6B032; font-style: italic;">String</span>, <span style="color: #C6B032; font-style: italic;">String</span>&gt; <span style="color: #46657B;">myMap</span> = <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">ConcurrentHashMap</span>&lt;<span style="color: #C6B032; font-style: italic;">String</span>, <span style="color: #C6B032; font-style: italic;">String</span>&gt;();
        myMap.put(<span style="color: #5A7644;">"1"</span>, <span style="color: #5A7644;">"1"</span>);
        myMap.put(<span style="color: #5A7644;">"2"</span>, <span style="color: #5A7644;">"2"</span>);
        myMap.put(<span style="color: #5A7644;">"3"</span>, <span style="color: #5A7644;">"3"</span>);
        System.out.println(<span style="color: #5A7644;">"ConcurrentHashMap before iterator"</span> + myMap);

        <span style="color: #C6B032; font-style: italic;">Iterator</span>&lt;<span style="color: #C6B032; font-style: italic;">String</span>&gt; <span style="color: #46657B;">it</span> = myMap.keySet().iterator();

        <span style="color: #AE5825;">while</span> (it.hasNext()) {
            <span style="color: #C6B032; font-style: italic;">String</span> <span style="color: #46657B;">key</span> = it.next();
            <span style="color: #AE5825;">if</span> (key.equals(<span style="color: #5A7644;">"3"</span>)) {
                myMap.put(key + <span style="color: #5A7644;">"new"</span>, <span style="color: #5A7644;">"new3"</span>);
            }
        }
        System.out.println(<span style="color: #5A7644;">"ConcurrentHashMap after iterator"</span> + myMap);

        <span style="color: #4C565D;">//</span><span style="color: #333B40; font-style: italic;">HashMap</span>
        myMap = <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">HashMap</span>&lt;<span style="color: #C6B032; font-style: italic;">String</span>, <span style="color: #C6B032; font-style: italic;">String</span>&gt;();
        myMap.put(<span style="color: #5A7644;">"1"</span>, <span style="color: #5A7644;">"1"</span>);
        myMap.put(<span style="color: #5A7644;">"2"</span>, <span style="color: #5A7644;">"2"</span>);
        myMap.put(<span style="color: #5A7644;">"3"</span>, <span style="color: #5A7644;">"3"</span>);
        System.out.println(<span style="color: #5A7644;">"HashMap before iterator"</span> + myMap);
        <span style="color: #C6B032; font-style: italic;">Iterator</span>&lt;<span style="color: #C6B032; font-style: italic;">String</span>&gt; <span style="color: #46657B;">it1</span> = myMap.keySet().iterator();

        <span style="color: #AE5825;">while</span> (it1.hasNext()) {
            <span style="color: #C6B032; font-style: italic;">String</span> <span style="color: #46657B;">key</span> = it1.next();
            <span style="color: #AE5825;">if</span> (key.equals(<span style="color: #5A7644;">"3"</span>)) {
                myMap.put(key + <span style="color: #5A7644;">"new"</span>, <span style="color: #5A7644;">"new3"</span>);
            }
        }
        System.out.println(<span style="color: #5A7644;">"HashMap after iterator"</span> + myMap);
    }
}

<span style="color: #4C565D;">///////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">&lt;===================OUTPUT===================&gt;                                                    //</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">ConcurrentHashMap before iterator{1=1, 3=3, 2=2}                                                  //</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">ConcurrentHashMap after iterator{3new=new3, 1=1, 3=3, 2=2}                                        //</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">HashMap before iterator{3=3, 2=2, 1=1}                                                            //</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">java.lang.reflect.InvocationTargetException                                                       //</span>
<span style="color: #4C565D;">//  </span><span style="color: #333B40; font-style: italic;">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)                                   //</span>
<span style="color: #4C565D;">//  </span><span style="color: #333B40; font-style: italic;">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)                 //</span>
<span style="color: #4C565D;">//  </span><span style="color: #333B40; font-style: italic;">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)         //</span>
<span style="color: #4C565D;">//  </span><span style="color: #333B40; font-style: italic;">at java.lang.reflect.Method.invoke(Method.java:606)                                              //</span>
<span style="color: #4C565D;">//  </span><span style="color: #333B40; font-style: italic;">at org.codehaus.mojo.exec.ExecJavaMojo$1.run(ExecJavaMojo.java:293)                              //</span>
<span style="color: #4C565D;">//  </span><span style="color: #333B40; font-style: italic;">at java.lang.Thread.run(Thread.java:745)                                                         //</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">Caused by: java.util.ConcurrentModificationException                                              //</span>
<span style="color: #4C565D;">//  </span><span style="color: #333B40; font-style: italic;">at java.util.HashMap$HashIterator.nextEntry(HashMap.java:922)                                    //</span>
<span style="color: #4C565D;">//  </span><span style="color: #333B40; font-style: italic;">at java.util.HashMap$KeyIterator.next(HashMap.java:956)                                          //</span>
<span style="color: #4C565D;">//  </span><span style="color: #333B40; font-style: italic;">at org.hfeng.book.jcip.ch5.ConcurrentHashMapExample.main(ConcurrentHashMapExample.java:36)       //</span>
<span style="color: #4C565D;">//  </span><span style="color: #333B40; font-style: italic;">... 6 more                                                                                       //</span>
<span style="color: #4C565D;">///////////////////////////////////////////////////////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</li>
<li>Concurrent collection新的加锁策略也是有一些牺牲的,比如,对全局进行操作的函
数(像size(), isEmpty()), 都是"没有那么真实的"反映collection的concurrent nature
</li>
<li>这也很好理解,因为在size()在被计算的时候,map的大小可能已经改变了,返回的值可
能过时了.所以这里的size()只是一个大概的估计,而不是准确的描述
</li>
<li>仔细一想,size()这类函数在多线程环境下确实不是很重要,因为这些值都是不停的在
改变, Java牺牲了这些函数的准确性,提高了"最重要操作get, put, containsKey remove"
的性能
</li>
<li>ConcurrentHashMap唯一"不能"提供的而synchronized Map能够提供的功能就是exclusive
access.也只有在这种情况下,synchronized Map是比ConcurrentHashMap更好的选择.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2">Additional Atomic Map Operations</h4>
<div class="outline-text-4" id="text-1-2-2">
<ul class="org-ul">
<li>因为ConcurrentHashMap不能exclusive access,所以内部实现的时候也没有对this加
锁,所以不能使用client side的lock来创建atomic的操作(比如put-if-absent), 为了
弥补,JDK在concurrent collection的内部实现了常用atomic操作
<div class="org-src-container">

<pre class="src src-java"><span style="color: #AE5825;">public</span> <span style="color: #AE5825;">interface</span> <span style="color: #C6B032; font-style: italic;">ConcurrentMap</span>&lt;<span style="color: #C6B032; font-style: italic;">K</span>, <span style="color: #C6B032; font-style: italic;">V</span>&gt; <span style="color: #AE5825;">extends</span> <span style="color: #C6B032; font-style: italic;">Map</span>&lt;<span style="color: #C6B032; font-style: italic;">K</span>, <span style="color: #C6B032; font-style: italic;">V</span>&gt; {
    <span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">Inert into map only if no value is mapped from K</span>
    <span style="color: #C6B032; font-style: italic;">V</span> <span style="color: #C6B032;">putIfAbsent</span>(<span style="color: #C6B032; font-style: italic;">K</span> <span style="color: #46657B;">key</span>, <span style="color: #C6B032; font-style: italic;">V</span> <span style="color: #46657B;">value</span>);

    <span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">Remove only if K is mapped to V</span>
    <span style="color: #C6B032; font-style: italic;">boolean</span> <span style="color: #C6B032;">remove</span>(<span style="color: #C6B032; font-style: italic;">K</span> <span style="color: #46657B;">key</span>, <span style="color: #C6B032; font-style: italic;">V</span> <span style="color: #46657B;">value</span>);

    <span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">Replace value only if K is mpaaed to oldValue</span>
    <span style="color: #C6B032; font-style: italic;">boolean</span> <span style="color: #C6B032;">replace</span>(<span style="color: #C6B032; font-style: italic;">K</span> <span style="color: #46657B;">key</span>, <span style="color: #C6B032; font-style: italic;">V</span> <span style="color: #46657B;">oldValue</span>, <span style="color: #C6B032; font-style: italic;">V</span> <span style="color: #46657B;">newValue</span>);
}
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2-3" class="outline-4">
<h4 id="sec-1-2-3">CopyOnWriteArrayList</h4>
<div class="outline-text-4" id="text-1-2-3">
<ul class="org-ul">
<li>CopyOnWriteArrayList是在并发访问下面效率更高,遍历的时候不需要加锁的List
</li>
<li>同样的,CopyOnWriteArraySet也是在并发访问下面效率更高,遍历的时候不需要加锁的Set
</li>
<li>CopyOnWriteArrayList的原理来自于:immutable对象如果合适的publish,那么对于这
个对象的访问就不再需要加锁
</li>
<li>CopyOnWriteArrayList的"原数组"可以认为是immutable的,每次write操作,都会触发
一次拷贝整个数组,然后write是在这个新的数组上面完成的,更改完以后再把原来的ref
指向新的数组
</li>
<li>CopyOnWriteArrayList的操作都是在"原数组"上进行的,因为是"immutable"的,所以读
也不需要加任何的锁
</li>
<li>CopyOnWriteArrayList的iterator不会抛出ConcurrentModificationException,
而且返回值能够"完全精确"的反应collection当前的状况
</li>
<li>当然CopyOnWriteArrayList的效率不高,因为write的时候要重新拷贝.所以CopyOnWriteArrayList
非常适合的领域必定是read操作远大于write操作的领域.
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Blocking Queues and the Producer-consumer Pattern</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>Blocking queue的特点如下:
<ul class="org-ul">
<li>提供queue的常规操作put, take
</li>
<li>提供等待一定时间的操作offer(对应put), poll(对应take)
</li>
<li>常规put, take如果在queue满的情况下会block
</li>
</ul>
</li>
<li>Blocking queue的设计简化了java实现producer-consumer pattern的方法:
<ul class="org-ul">
<li>Producer不用管有多少Consumer(甚至有多少Producer也不用管), 只管把数据放到
queue里面(只要queue ready)
</li>
<li>Consumer不管有多少Producer,只管从queue里面取数据(只要queue ready)
</li>
</ul>
</li>
<li>最常见的producer-consumer设计就是thread-pool
</li>
<li>类库里面有多重BlockingQueue的FIFO实现(都是concurrent collection):
<ul class="org-ul">
<li>LinkedBlockingQueue 对应LinkedList
</li>
<li>ArrayBlockingQueue 对应ArrayList
</li>
</ul>
</li>
<li>Blocking Queue的另外一个实现是PriorityBlockingQueue, 这个queue"不是"按照某
种"先来后到"的顺序,而是按照natural order,或者是Comparator定义的order来行事
</li>
<li>BlockingQueue还有一种特殊实现叫做SynchronousQueue,这个queue很奇特,它自己不维
护任何的存储空间(好像一个零仓储的超市!)produce的element,马上就被consume光了.
这种queue适合consumer特别多,然后producer特别少,每次基本只有一个element可供
consumer抢夺的情况(也就没有必要维护存储空间)
</li>
</ul>
</div>
<div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1">Example: Desktop Search</h4>
<div class="outline-text-4" id="text-1-3-1">
<ul class="org-ul">
<li>producer-consumer的一个例子是desktop search, 一般来说desktop search都有如下
两个步骤:
<ul class="org-ul">
<li>首先是"爬取"所有的文件,放入blockingQueue(如果满就block):
<div class="org-src-container">

<pre class="src src-java"><span style="color: #AE5825;">static</span> <span style="color: #AE5825;">class</span> <span style="color: #C6B032; font-style: italic;">FileCrawler</span> <span style="color: #AE5825;">implements</span> <span style="color: #C6B032; font-style: italic;">Runnable</span> {
    <span style="color: #AE5825;">private</span> <span style="color: #AE5825;">final</span> <span style="color: #C6B032; font-style: italic;">BlockingQueue</span>&lt;<span style="color: #C6B032; font-style: italic;">File</span>&gt; <span style="color: #46657B;">fileQueue</span>;
    <span style="color: #AE5825;">private</span> <span style="color: #AE5825;">final</span> <span style="color: #C6B032; font-style: italic;">FileFilter</span> <span style="color: #46657B;">fileFilter</span>;
    <span style="color: #AE5825;">private</span> <span style="color: #AE5825;">final</span> <span style="color: #C6B032; font-style: italic;">File</span> <span style="color: #46657B;">root</span>;

    <span style="color: #AE5825;">public</span> <span style="color: #C6B032;">FileCrawler</span>(<span style="color: #C6B032; font-style: italic;">BlockingQueue</span>&lt;<span style="color: #C6B032; font-style: italic;">File</span>&gt; <span style="color: #46657B;">fileQueue</span>,
                       <span style="color: #AE5825;">final</span> <span style="color: #C6B032; font-style: italic;">FileFilter</span> <span style="color: #46657B;">fileFilter</span>,
                       <span style="color: #C6B032; font-style: italic;">File</span> <span style="color: #46657B;">root</span>) {
        <span style="color: #AE5825;">this</span>.fileQueue = fileQueue;
        <span style="color: #AE5825;">this</span>.root = root;
        <span style="color: #AE5825;">this</span>.fileFilter = <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">FileFilter</span>() {
                <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">boolean</span> <span style="color: #C6B032;">accept</span>(<span style="color: #C6B032; font-style: italic;">File</span> <span style="color: #46657B;">pathname</span>) {
                    <span style="color: #AE5825;">return</span> <span style="color: #86453A;">true</span>;
                }
            };
    }

    <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">run</span>() {
        <span style="color: #AE5825;">try</span> {
            crawl(root);
        } <span style="color: #AE5825;">catch</span> (<span style="color: #C6B032; font-style: italic;">InterruptedException</span> <span style="color: #46657B;">e</span>) {
            Thread.currentThread().interrupt();
        }
    }

    <span style="color: #AE5825;">private</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">crawl</span>(<span style="color: #C6B032; font-style: italic;">File</span> <span style="color: #46657B;">root</span>) <span style="color: #AE5825;">throws</span> <span style="color: #C6B032; font-style: italic;">InterruptedException</span> {
        <span style="color: #C6B032; font-style: italic;">File</span>[] <span style="color: #46657B;">entries</span> = root.listFiles(fileFilter);
        <span style="color: #AE5825;">if</span> (entries != <span style="color: #86453A;">null</span>) {
            <span style="color: #AE5825;">for</span> (<span style="color: #C6B032; font-style: italic;">File</span> <span style="color: #46657B;">entry</span> : entries) {
                <span style="color: #AE5825;">if</span> (entry.isDirectory()) {
                    crawl(entry);
                } <span style="color: #AE5825;">else</span> <span style="color: #AE5825;">if</span> (!alreadyIndexed(entry)) {
                    fileQueue.put(entry);
                }
            }
        }
    }

    <span style="color: #AE5825;">private</span> <span style="color: #C6B032; font-style: italic;">boolean</span> <span style="color: #C6B032;">alreadyIndexed</span>(<span style="color: #C6B032; font-style: italic;">File</span> <span style="color: #46657B;">f</span>) {
        <span style="color: #AE5825;">return</span> <span style="color: #86453A;">false</span>;
    }

}
</pre>
</div>
</li>
<li>其次是"索引"所有文件,从blockingQueue中取出(如果空就block)
<div class="org-src-container">

<pre class="src src-java"><span style="color: #AE5825;">static</span> <span style="color: #AE5825;">class</span> <span style="color: #C6B032; font-style: italic;">Indexer</span> <span style="color: #AE5825;">implements</span> <span style="color: #C6B032; font-style: italic;">Runnable</span> {
    <span style="color: #AE5825;">private</span> <span style="color: #AE5825;">final</span> <span style="color: #C6B032; font-style: italic;">BlockingQueue</span>&lt;<span style="color: #C6B032; font-style: italic;">File</span>&gt; <span style="color: #46657B;">queue</span>;

    <span style="color: #AE5825;">public</span> <span style="color: #C6B032;">Indexer</span>(<span style="color: #C6B032; font-style: italic;">BlockingQueue</span>&lt;<span style="color: #C6B032; font-style: italic;">File</span>&gt; <span style="color: #46657B;">queue</span>) {
        <span style="color: #AE5825;">this</span>.queue = queue;
    }

    <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">run</span>() {
        <span style="color: #AE5825;">try</span> {
            <span style="color: #AE5825;">while</span> (<span style="color: #86453A;">true</span>) {
                indexFile(queue.take());
            }
        } <span style="color: #AE5825;">catch</span> (<span style="color: #C6B032; font-style: italic;">InterruptedException</span> <span style="color: #46657B;">e</span>) {
            Thread.currentThread().interrupt();
        }
    }

    <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">indexFile</span>(<span style="color: #C6B032; font-style: italic;">File</span> <span style="color: #46657B;">file</span>) {
        <span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">Index the file</span>
        System.out.println(<span style="color: #5A7644;">"Indexing at file -&gt; "</span> + file.getName());
    }

}
</pre>
</div>
</li>
</ul>
</li>
<li>调用代码如下
<div class="org-src-container">

<pre class="src src-java"><span style="color: #AE5825;">public</span> <span style="color: #AE5825;">static</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">startIndexing</span>(<span style="color: #C6B032; font-style: italic;">File</span>[] <span style="color: #46657B;">roots</span>) {
    <span style="color: #C6B032; font-style: italic;">BlockingQueue</span>&lt;<span style="color: #C6B032; font-style: italic;">File</span>&gt; <span style="color: #46657B;">queue</span> = <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">LinkedBlockingQueue</span>&lt;<span style="color: #C6B032; font-style: italic;">File</span>&gt;(BOUND);
    <span style="color: #C6B032; font-style: italic;">FileFilter</span> <span style="color: #46657B;">filter</span> = <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">FileFilter</span>() {
            <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">boolean</span> <span style="color: #C6B032;">accept</span>(<span style="color: #C6B032; font-style: italic;">File</span> <span style="color: #46657B;">file</span>) {
                <span style="color: #AE5825;">return</span> <span style="color: #86453A;">true</span>;
            }
        };

    <span style="color: #AE5825;">for</span> (<span style="color: #C6B032; font-style: italic;">File</span> <span style="color: #46657B;">root</span> : roots) {
        <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">Thread</span>(<span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">FileCrawler</span>(queue, filter, root)).start();
    }

    <span style="color: #AE5825;">for</span> (<span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #46657B;">i</span> = 0; i &lt; <span style="color: #C6B032; font-style: italic;">N_CONSUMERS</span>; i++) {
        <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">Thread</span>(<span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">Indexer</span>(queue)).start();
    }
}
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-3-2" class="outline-4">
<h4 id="sec-1-3-2">Deques and Work Stealing</h4>
<div class="outline-text-4" id="text-1-3-2">
<ul class="org-ul">
<li>java 6又在原来的基础上增加了可以在首位两端进行插入删除操作的双向队列:
<ol class="org-ol">
<li>Deque(interface) : ArrayDeque(implementation)
</li>
<li>BlockingDeque(inteface) : LinkedBlockingDeque(implementation)
</li>
</ol>
</li>
<li>dqueue也是为了一种pattern而创造的, producer-consumer pattern的变形: Work
stealing:
<ul class="org-ul">
<li>每个consumer 拥有自己的deque(这样多个consumer就不会去竞争一个queue)
</li>
<li>每个consumer 在自己的deque使用完了以后,可以去其他consumer的deque里面stealing
element. 而且是在尾部进行stealing(这样也会减少和deque consumer的正面冲突,
只会和其他前来stealing的consumer进行争夺)
</li>
</ul>
</li>
<li>Work stealing在解决consumer同时也是producer的问题中非常的合适:比如在web
crawler的处理中:
<ul class="org-ul">
<li>从自己的deque里面得到一个任务. 在处理这个任务的同时,会发现这个网页有很多
链接,同样需要抓取,
</li>
<li>就从"后面"把这些链接任务放入到自己的deque(像producer一样),
</li>
<li>而如果自己的deque里面没有任务了,它就会从其他consumer deque的"后面(也就是
producer放入的地方)获得任务"
</li>
</ul>
</li>
<li>总体上来讲, working stealing减少了竞争,让每个consumer都处于busy的状态,从而
提高了效率
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">Blocking and Interruptible Methods</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>Thread有很多种情况下都会被block,常见的情况有:
<ul class="org-ul">
<li>等待IO完成
</li>
<li>等待获得一个锁
</li>
<li>等待自己调用的Thread.sleep完成
</li>
<li>等待另外一个线程计算结果
</li>
</ul>
</li>
<li>当一个thread进入block状态的时候, 它通常会被"搁置(suspended)",然后被置于如下
的一种blocked thread state:
<ul class="org-ul">
<li>BLOCKED
</li>
<li>WAITING
</li>
<li>TIMED_WAITING
</li>
</ul>
</li>
<li>一个blocking operation和'一个普通的但是需要较长时间完成的'operation之间的差
距是: blocked thread必须等待一个"它自己无法控制"的event,然后才能继续执行.这些
event就是前面说的几种情况:
<ul class="org-ul">
<li>I/O 结束
</li>
<li>lock available了
</li>
<li>外部的计算结束了
</li>
</ul>
</li>
<li>当"thread自己无法控制,但又需要"的event出现以后, thread就会又进入RUNNABLE state
重新可以被调度运行了
</li>
<li>BlockingQueue里面的操作put和take都是checked InterruptedException,也就是说,
这些操作suppose是会被interrupted(而且是checked的,所以调用者要自己处理,或者throw
到上一层解决).
</li>
<li>一旦put和take等抛出InterruptedException的操作被interrupted, 他们就有机会停止
自己的blocking状态
</li>
<li>Thread也提供了一些interrupt的函数, 比如:
<ul class="org-ul">
<li>interrupting a thread的函数
</li>
<li>querying whether a thread has been interrupted的函数
</li>
</ul>
</li>
<li>Interruption是一个"合作"的机制,它并不能"强行的"让其他thread停止:
<pre class="example">
Thread A interrupt了 Thread B,并不是"强行"停止Thread B,而是"建议" Thread B 停止
</pre>
</li>
<li>ThreadA interrupt另外的threads的例子
<div class="org-src-container">

<pre class="src src-java"><span style="color: #AE5825;">package</span> org.hfeng.book.jcip.<span style="color: #86453A;">ch5</span>;

<span style="color: #AE5825;">public</span> <span style="color: #AE5825;">class</span> <span style="color: #C6B032; font-style: italic;">InterruptOthers</span> {
    <span style="color: #AE5825;">final</span> <span style="color: #C6B032; font-style: italic;">Thread</span> <span style="color: #46657B;">subject1</span> = <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">Thread</span>(<span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">Runnable</span>() {
        <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">run</span>() {
            <span style="color: #AE5825;">while</span> (!Thread.interrupted()) {
                Thread.yield();
            }
            System.out.println(<span style="color: #5A7644;">"subject 1 stopped!"</span>);
        }
    });

    <span style="color: #AE5825;">final</span> <span style="color: #C6B032; font-style: italic;">Thread</span> <span style="color: #46657B;">subject2</span> = <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">Thread</span>(<span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">Runnable</span>() {
        <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">run</span>() {
            <span style="color: #AE5825;">while</span> (!Thread.interrupted()) {
                Thread.yield();
            }
            System.out.println(<span style="color: #5A7644;">"subject 2 stopped!"</span>);
        }
    });

    <span style="color: #AE5825;">final</span> <span style="color: #C6B032; font-style: italic;">Thread</span> <span style="color: #46657B;">coordinator</span> = <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">Thread</span>(<span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">Runnable</span>() {
        <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">run</span>() {
            <span style="color: #AE5825;">try</span> {
                Thread.sleep(500);
            } <span style="color: #AE5825;">catch</span> (<span style="color: #C6B032; font-style: italic;">InterruptedException</span> <span style="color: #46657B;">exe</span>) {

            }
            System.out.println(<span style="color: #5A7644;">"coordinator stopping!"</span>);
            subject1.interrupt();
            subject2.interrupt();
        }
    });

    <span style="color: #AE5825;">public</span> <span style="color: #AE5825;">static</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">main</span>(<span style="color: #C6B032; font-style: italic;">String</span>[] <span style="color: #46657B;">args</span>) {
        <span style="color: #C6B032; font-style: italic;">InterruptOthers</span> <span style="color: #46657B;">interruptOthers</span> = <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">InterruptOthers</span>();
        interruptOthers.subject1.start();
        interruptOthers.subject2.start();
        interruptOthers.coordinator.start();
    }
}

<span style="color: #4C565D;">////////////////////////////////////////////////////</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">coordinator stopping!                          //</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">subject 1 stopped!                             //</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">subject 2 stopped!                             //</span>
<span style="color: #4C565D;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>如果一个函数会抛出InterruptedException,那么说明你的函数是blocking method,也
就意味着你的函数必须对于interruption的到来,有"预案":
<ul class="org-ul">
<li>可以选择把exception抛给上层
</li>
<li>也可以选择restore这个interrupt(也就是让当前thread重新call一遍interrupt):
这是因为某些情况下你无法throw exception,那么你要选择让其他code(higher up
the call stack)来发现这个interrupt,然后来处理
<div class="org-src-container">

<pre class="src src-java"><span style="color: #AE5825;">public</span> <span style="color: #AE5825;">class</span> <span style="color: #C6B032; font-style: italic;">TaskRunnable</span> <span style="color: #AE5825;">implements</span> <span style="color: #C6B032; font-style: italic;">Runnable</span> {
    <span style="color: #C6B032; font-style: italic;">BlockingQueue</span>&lt;<span style="color: #C6B032; font-style: italic;">Task</span>&gt; <span style="color: #46657B;">queue</span>;

    <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">run</span>() {
        <span style="color: #AE5825;">try</span> {
            <span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">take is a blocking method</span>
            processTask(queue.take());
        } <span style="color: #AE5825;">catch</span> (<span style="color: #C6B032; font-style: italic;">InterruptException</span> <span style="color: #46657B;">e</span>) {
            <span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">restore interrupted status</span>
            Thread.currentThread().interrupt();
        }
    }
}
</pre>
</div>
</li>
</ul>
</li>
<li>上面是应该"如何处理中断", 而下面的我们要介绍一种"不应该如何处理中断"
<pre class="example">
       捕获了总段,但是不做任何的响应, 这样做会丢失中断的证据
</pre>
</li>
<li>只有一种情况允许掩盖中断,那就是你extends了Thread,因此控制了所有处于调用栈上
层, 就像我们上面的InterruptOthers代码.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">Synchronizers</h3>
<div class="outline-text-3" id="text-1-5">
<ul class="org-ul">
<li>Blocking queues是一类特殊的容器:
<ul class="org-ul">
<li>首先能够实现普通容器的功能: contains object
</li>
<li>其次能够对"进出容器进行梳理": 因为put和take都会在"不合适的时候",自动block
</li>
</ul>
</li>
<li>所谓的Synchronizers,就是满足Blocking queue第二个特性的一种object
<pre class="example">
A synchronizer is any object that coordinates the control flow of
threads based on its state
</pre>
</li>
<li>除了Blocking queue以外,jdk自带的synchronizer还有:
<ul class="org-ul">
<li>semaphores
</li>
<li>barriers
</li>
<li>latches
</li>
<li>根据需要,自己创建的synchronizer
</li>
</ul>
</li>
<li>所有的synchronizer都有一些共性:
<ul class="org-ul">
<li>封装state: 这些state可以决定到达synchronizer的thread是否被允许进入,还是要
wait
</li>
<li>管理state: 提供一些函数来管理这些state
</li>
<li>提高等待效率: 提供一些函数来提高仅需desired state的等待效率
</li>
</ul>
</li>
</ul>
</div>
<div id="outline-container-sec-1-5-1" class="outline-4">
<h4 id="sec-1-5-1">Latches</h4>
<div class="outline-text-4" id="text-1-5-1">
<ul class="org-ul">
<li>Latch是一种synchronizer,它的特点是
<ul class="org-ul">
<li>在latch到达它的terminal state之前, 所有的thread都是被它block住的,没有一个thread
可以通过.
</li>
<li>一旦latch到达了它的terminal state,所有的thread都可以通过,
</li>
<li>而且latch一旦到达它的terminal state,它再也无法改变了,只能一直允许thread通过.
</li>
</ul>
</li>
<li>latch的这种特性让它在比较适合应用在"直到某些one-time activity完成,某些
thread才能往前走!", 例子有如下:
<ul class="org-ul">
<li>直到运算的某些资源被创建完成, 这些运算才能开始
</li>
<li>一个service运行需要"另外的service"先运行.
</li>
<li>等待自己所有的"组成部分"都完成,然后向前进.
</li>
</ul>
</li>
<li>CountDownLatch就是java里面一种简单的latch实现:
<ul class="org-ul">
<li>初始化的时候设置一个正整数, 就是内部的counter number, 也就说,这个latch会在"多少"次后"开门"
</li>
<li>countDown()函数会减少内部的count number
</li>
<li>await()函数会等待如下事件:
<ol class="org-ol">
<li>counter number变成0
</li>
<li>等待的thread 被interrupted
</li>
<li>wait超时
</li>
</ol>
</li>
</ul>
</li>
<li>下面的Testharness就是介绍了两种常见的latch实现:
<ul class="org-ul">
<li>"starting gate"的count是1, 也就是说有一thread到达了,它就terminal了, 保证
是最快的thread开启了"前门"
</li>
<li>"ending gate"的count是thread总的数目,也就是说,所有的thread都到达的时候,才
开启了"后门".这样来计算"thread运行的时间", 才能保证准确!
</li>
</ul>
</li>
<li>例子如下
<div class="org-src-container">

<pre class="src src-java"><span style="color: #AE5825;">package</span> org.hfeng.book.jcip.<span style="color: #86453A;">ch5</span>;

<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">util</span>.<span style="color: #86453A;">concurrent</span>.<span style="color: #C6B032; font-style: italic;">CountDownLatch</span>;

<span style="color: #AE5825;">public</span> <span style="color: #AE5825;">class</span> <span style="color: #C6B032; font-style: italic;">TestHarness</span> {
    <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">long</span> <span style="color: #C6B032;">timeTasks</span>(<span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #46657B;">nThreads</span>, <span style="color: #AE5825;">final</span> <span style="color: #C6B032; font-style: italic;">Runnable</span> <span style="color: #46657B;">task</span>) <span style="color: #AE5825;">throws</span> <span style="color: #C6B032; font-style: italic;">InterruptedException</span>{
        <span style="color: #AE5825;">final</span> <span style="color: #C6B032; font-style: italic;">CountDownLatch</span> <span style="color: #46657B;">startGate</span> = <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">CountDownLatch</span>(1);
        <span style="color: #AE5825;">final</span> <span style="color: #C6B032; font-style: italic;">CountDownLatch</span> <span style="color: #46657B;">endGate</span> = <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">CountDownLatch</span>(nThreads);

        <span style="color: #AE5825;">for</span> (<span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #46657B;">i</span> = 0; i &lt; <span style="color: #C6B032; font-style: italic;">nThreads</span>; i++) {
            <span style="color: #C6B032; font-style: italic;">Thread</span> <span style="color: #46657B;">t</span> = <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">Thread</span>() {
                <span style="color: #86453A;">@Override</span>
                <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">run</span>() {
                    <span style="color: #AE5825;">try</span> {
                        startGate.await();
                        <span style="color: #AE5825;">try</span> {
                            task.run();
                        }<span style="color: #AE5825;">finally</span> {
                            endGate.countDown();
                        }
                    } <span style="color: #AE5825;">catch</span> (<span style="color: #C6B032; font-style: italic;">InterruptedException</span> <span style="color: #46657B;">ignored</span>) {

                    }
                }
            };
            t.start();

        }

        <span style="color: #C6B032; font-style: italic;">long</span> <span style="color: #46657B;">start</span> = System.nanoTime();
        startGate.countDown();
        endGate.await();
        <span style="color: #C6B032; font-style: italic;">long</span> <span style="color: #46657B;">end</span> = System.nanoTime();
        <span style="color: #AE5825;">return</span> end - start;
    }

    <span style="color: #AE5825;">public</span> <span style="color: #AE5825;">static</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">main</span>(<span style="color: #C6B032; font-style: italic;">String</span>[] <span style="color: #46657B;">args</span>) {
        System.out.println(<span style="color: #5A7644;">"Start!"</span>);
        <span style="color: #C6B032; font-style: italic;">TestHarness</span> <span style="color: #46657B;">testHarness</span> = <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">TestHarness</span>();
        <span style="color: #AE5825;">final</span> <span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #46657B;">count</span> = 10;
        <span style="color: #AE5825;">try</span> {
            <span style="color: #C6B032; font-style: italic;">long</span> <span style="color: #46657B;">ii</span> = testHarness.timeTasks(count, <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">TaskRunnable</span>());
            System.out.println(<span style="color: #5A7644;">"Time (in nano second) is "</span> + ii);
        } <span style="color: #AE5825;">catch</span> (<span style="color: #C6B032; font-style: italic;">InterruptedException</span> <span style="color: #46657B;">e</span>) {

        }

    }
}

<span style="color: #AE5825;">class</span> <span style="color: #C6B032; font-style: italic;">TaskRunnable</span> <span style="color: #AE5825;">implements</span> <span style="color: #C6B032; font-style: italic;">Runnable</span> {
    <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">run</span>() {
        System.out.println(<span style="color: #5A7644;">"In task!"</span>);
    }
}

<span style="color: #4C565D;">////////////////////////////////////////////////////</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">Start!                                         //</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">In task!                                       //</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">In task!                                       //</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">In task!                                       //</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">In task!                                       //</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">In task!                                       //</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">In task!                                       //</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">In task!                                       //</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">In task!                                       //</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">In task!                                       //</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">In task!                                       //</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">Time (in nano second) is 479000                //</span>
<span style="color: #4C565D;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>使用上面的方法,而不是直接new了thread以后就马上start是因为, 使用CountDownLatch
的方法,计算的更准确:
<ul class="org-ul">
<li>在循环里面,虽然每个thread都start了,但是因为其run()内部调用了startGate.await()
鉴于startGate开始的时候还是1, 所以,所有的循环里面初始化的thread都会block!
</li>
<li>直到startGate.countDown()的一瞬间,所有thread开始"竞争". 在startGate.countDown()
之前,已经开始计时
</li>
<li>endGate会一直等到所有thread都完结,才结束计时
</li>
</ul>
</li>
<li>反观设置thread,马上开始start的话. 就会出现某些thread先完成了.比如3个, 而我
们想测试的是"N个thread同时并发的时间", 少了这三个,我们的测试变成了"N-3个thread
同时并发的时间.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-5-2" class="outline-4">
<h4 id="sec-1-5-2">FutureTask</h4>
<div class="outline-text-4" id="text-1-5-2">
<ul class="org-ul">
<li>FutureTask是一种非常特别的"能够返回值"的Thread,原因在于:
<ul class="org-ul">
<li>使用Callable作为参数, 就能返回值
</li>
<li>它继承了Runnable接口, 就本质上说,就是一个thread了. 当然使用的时候是作为Thread
class的参数.
</li>
</ul>
</li>
<li>下面是一个使用FutureTask的例子
<div class="org-src-container">

<pre class="src src-java"><span style="color: #AE5825;">package</span> org.hfeng.book.jcip.<span style="color: #86453A;">ch5</span>;

<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">util</span>.<span style="color: #86453A;">concurrent</span>.<span style="color: #C6B032; font-style: italic;">Callable</span>;
<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">util</span>.<span style="color: #86453A;">concurrent</span>.<span style="color: #C6B032; font-style: italic;">ExecutionException</span>;
<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">util</span>.<span style="color: #86453A;">concurrent</span>.<span style="color: #C6B032; font-style: italic;">FutureTask</span>;

<span style="color: #AE5825;">public</span> <span style="color: #AE5825;">class</span> <span style="color: #C6B032; font-style: italic;">PreLoader</span> {
    <span style="color: #C6B032; font-style: italic;">ProductInfo</span> <span style="color: #C6B032;">loadProductInfo</span>() <span style="color: #AE5825;">throws</span> <span style="color: #C6B032; font-style: italic;">DataLoadException</span> {
        <span style="color: #AE5825;">return</span> <span style="color: #86453A;">null</span>;
    }

    <span style="color: #AE5825;">private</span> <span style="color: #AE5825;">final</span> <span style="color: #C6B032; font-style: italic;">FutureTask</span>&lt;<span style="color: #C6B032; font-style: italic;">ProductInfo</span>&gt; <span style="color: #46657B;">future</span> =
            <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">FutureTask</span>&lt;<span style="color: #C6B032; font-style: italic;">ProductInfo</span>&gt;(<span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">Callable</span>&lt;<span style="color: #C6B032; font-style: italic;">ProductInfo</span>&gt;() {
                <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">ProductInfo</span> <span style="color: #C6B032;">call</span>() <span style="color: #AE5825;">throws</span> <span style="color: #C6B032; font-style: italic;">Exception</span> {
                    <span style="color: #AE5825;">return</span> loadProductInfo();
                }
            });

    <span style="color: #AE5825;">private</span> <span style="color: #AE5825;">final</span> <span style="color: #C6B032; font-style: italic;">Thread</span> <span style="color: #46657B;">thread</span> = <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">Thread</span>(future);

    <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">start</span>() {
        thread.start();
    }

    <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">ProductInfo</span> <span style="color: #C6B032;">get</span>() <span style="color: #AE5825;">throws</span> <span style="color: #C6B032; font-style: italic;">DataLoadException</span>, <span style="color: #C6B032; font-style: italic;">InterruptedException</span> {
        <span style="color: #AE5825;">try</span> {
            <span style="color: #AE5825;">return</span> future.get();
        } <span style="color: #AE5825;">catch</span> (<span style="color: #C6B032; font-style: italic;">ExecutionException</span> <span style="color: #46657B;">e</span>) {
            <span style="color: #C6B032; font-style: italic;">Throwable</span> <span style="color: #46657B;">cause</span> = e.getCause();
            <span style="color: #AE5825;">if</span> (cause <span style="color: #AE5825;">instanceof</span> DataLoadException) {
                <span style="color: #AE5825;">throw</span> (<span style="color: #C6B032; font-style: italic;">DataLoadException</span>) cause;
            } <span style="color: #AE5825;">else</span> {
                <span style="color: #AE5825;">throw</span> launderThrowable(cause);
            }
        }
    }

    <span style="color: #AE5825;">public</span> <span style="color: #AE5825;">static</span> <span style="color: #C6B032; font-style: italic;">RuntimeException</span> <span style="color: #C6B032;">launderThrowable</span>(<span style="color: #C6B032; font-style: italic;">Throwable</span> <span style="color: #46657B;">t</span>) {
        <span style="color: #AE5825;">if</span> (t <span style="color: #AE5825;">instanceof</span> RuntimeException) {
            <span style="color: #AE5825;">return</span> (<span style="color: #C6B032; font-style: italic;">RuntimeException</span>) t;
        } <span style="color: #AE5825;">else</span> <span style="color: #AE5825;">if</span> (t <span style="color: #AE5825;">instanceof</span>  Error) {
            <span style="color: #AE5825;">throw</span> (<span style="color: #C6B032; font-style: italic;">Error</span>) t;
        } <span style="color: #AE5825;">else</span> {
            <span style="color: #AE5825;">throw</span> <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">IllegalStateException</span>(<span style="color: #5A7644;">"Not unchecked"</span>, t);
        }
    }

    <span style="color: #AE5825;">interface</span> <span style="color: #C6B032; font-style: italic;">ProductInfo</span> {
    }
}

<span style="color: #AE5825;">class</span> <span style="color: #C6B032; font-style: italic;">DataLoadException</span> <span style="color: #AE5825;">extends</span> <span style="color: #C6B032; font-style: italic;">Exception</span> {}
</pre>
</div>
</li>
<li>从上面的例子我们可以看到:
<ul class="org-ul">
<li>future初始化的时候,成员是Callable类型的匿名class
</li>
<li>future.get()会:
<ul class="org-ul">
<li>如果callable的instance运行完了以后,能够返回值,get()也就会返回
</li>
<li>如果callable的instance还没运行完,那么就会block住.
</li>
</ul>
</li>
<li>因为Callable是一种会抛出异常的thread,那么,我们的future.get()也要处理各种
异常
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-5-3" class="outline-4">
<h4 id="sec-1-5-3">Semaphores</h4>
<div class="outline-text-4" id="text-1-5-3">
<ul class="org-ul">
<li>Counting semaphores用来控制访问某种resource的数量.
</li>
<li>Counting semaphores可以用来实现资源库,或者给一个collection增加"额度"
</li>
<li>一个semaphore开始的时候会被设置一个初始的数字,代表它可以发放的permits数量:
<ul class="org-ul">
<li>thread在开始"真正运行以前"先acquire锁
</li>
<li>thread在离开之前,释放这个锁
</li>
</ul>
</li>
<li>Semaphore在实现数据库连接池(Data Connection Pool)的时候非常管用.因为连接池
里面就是"一定数量"的资源,如果用尽,再请求的话,就是block了
<div class="org-src-container">

<pre class="src src-java"><span style="color: #AE5825;">package</span> org.hfeng.misc.concurrent.<span style="color: #86453A;">semaphore</span>;

<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">util</span>.<span style="color: #86453A;">concurrent</span>.<span style="color: #C6B032; font-style: italic;">ExecutorService</span>;
<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">util</span>.<span style="color: #86453A;">concurrent</span>.<span style="color: #C6B032; font-style: italic;">Executors</span>;
<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">util</span>.<span style="color: #86453A;">concurrent</span>.<span style="color: #C6B032; font-style: italic;">Semaphore</span>;

<span style="color: #AE5825;">public</span> <span style="color: #AE5825;">class</span> <span style="color: #C6B032; font-style: italic;">SemaphoreTest</span> {
    <span style="color: #AE5825;">private</span> <span style="color: #AE5825;">static</span> <span style="color: #AE5825;">final</span> <span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #46657B;">THREAD_COUNT</span> = 10;

    <span style="color: #AE5825;">private</span> <span style="color: #AE5825;">static</span> <span style="color: #C6B032; font-style: italic;">ExecutorService</span> <span style="color: #46657B;">threadPool</span> = Executors.newFixedThreadPool(THREAD_COUNT);

    <span style="color: #AE5825;">private</span> <span style="color: #AE5825;">static</span> <span style="color: #C6B032; font-style: italic;">Semaphore</span> <span style="color: #46657B;">s</span> = <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">Semaphore</span>(3);

    <span style="color: #AE5825;">public</span> <span style="color: #AE5825;">static</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">main</span>(<span style="color: #C6B032; font-style: italic;">String</span>[] <span style="color: #46657B;">args</span>) {
        <span style="color: #AE5825;">for</span> (<span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #46657B;">i</span> = 0; i &lt; <span style="color: #C6B032; font-style: italic;">THREAD_COUNT</span>; i++) {
            threadPool.execute(<span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">Runnable</span>() {
                <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">run</span>() {
                    <span style="color: #AE5825;">try</span> {
                        s.acquire();
                        System.out.println(<span style="color: #5A7644;">"Save data\n"</span>);
                        Thread.sleep(5000);
                        s.release();
                    } <span style="color: #AE5825;">catch</span> (<span style="color: #C6B032; font-style: italic;">InterruptedException</span> <span style="color: #46657B;">e</span>) {

                    }
                }
            });
        }
        threadPool.shutdown();
    }
}
</pre>
</div>
</li>
<li>可以使用Semaphore把任何一个collection都变成blocking bounded collection.
<ul class="org-ul">
<li>初始化Semaphore为collection的长度
</li>
<li>add会减少permit
</li>
<li>remove会增加permit
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-5-4" class="outline-4">
<h4 id="sec-1-5-4">Barriers</h4>
<div class="outline-text-4" id="text-1-5-4">
<ul class="org-ul">
<li>前面我们看到了,latch是一种"一次性"开关的存在,一旦进入terminal state,就不允许改变state了
</li>
<li>Barrier和latch不同,它在释放后,可以重复利用
</li>
<li>Barrier最本质的用法和latch也有点"相反",比如去饭店吃饭:
<ul class="org-ul">
<li>latch是"只要有一个人来了"就开饭
</li>
<li>barrier是"要等待所有人都来齐了"才开饭
</li>
</ul>
</li>
<li>CyclicBarrier例子如下
<div class="org-src-container">

<pre class="src src-java"><span style="color: #AE5825;">package</span> org.hfeng.misc.concurrent.<span style="color: #86453A;">barrier</span>;

<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">util</span>.<span style="color: #C6B032; font-style: italic;">Random</span>;
<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">util</span>.<span style="color: #86453A;">concurrent</span>.<span style="color: #C6B032; font-style: italic;">BrokenBarrierException</span>;
<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">util</span>.<span style="color: #86453A;">concurrent</span>.<span style="color: #C6B032; font-style: italic;">CyclicBarrier</span>;
<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">util</span>.<span style="color: #86453A;">concurrent</span>.<span style="color: #C6B032; font-style: italic;">ExecutorService</span>;
<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">util</span>.<span style="color: #86453A;">concurrent</span>.<span style="color: #C6B032; font-style: italic;">Executors</span>;

<span style="color: #AE5825;">public</span> <span style="color: #AE5825;">class</span> <span style="color: #C6B032; font-style: italic;">CyclicBarrierTest</span> {
    <span style="color: #AE5825;">public</span> <span style="color: #AE5825;">static</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">main</span>(<span style="color: #C6B032; font-style: italic;">String</span>[] <span style="color: #46657B;">args</span>) {
        <span style="color: #C6B032; font-style: italic;">ExecutorService</span> <span style="color: #46657B;">exec</span> = Executors.newCachedThreadPool();
        <span style="color: #AE5825;">final</span> <span style="color: #C6B032; font-style: italic;">Random</span> <span style="color: #46657B;">random</span> = <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">Random</span>();

        <span style="color: #AE5825;">final</span> <span style="color: #C6B032; font-style: italic;">CyclicBarrier</span> <span style="color: #46657B;">barrier</span> = <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">CyclicBarrier</span>(4, <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">Runnable</span>() {
            <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">run</span>() {
                System.out.println(<span style="color: #5A7644;">"All people are here, go to lunch!"</span>);
            }
        });

        <span style="color: #AE5825;">for</span> (<span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #46657B;">i</span> = 0; i &lt; 4; i++) {
            exec.execute(<span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">Runnable</span>() {
                <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">run</span>() {
                    <span style="color: #AE5825;">try</span> {
                        Thread.sleep(random.nextInt(1000));
                    } <span style="color: #AE5825;">catch</span> (<span style="color: #C6B032; font-style: italic;">InterruptedException</span> <span style="color: #46657B;">e</span>) {
                        e.printStackTrace();
                    }
                    System.out.println(Thread.currentThread().getName() + <span style="color: #5A7644;">" is here"</span>);
                    <span style="color: #AE5825;">try</span> {
                        barrier.await(); <span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">wait for others</span>
                    } <span style="color: #AE5825;">catch</span> (<span style="color: #C6B032; font-style: italic;">InterruptedException</span> <span style="color: #46657B;">e</span>) {
                        e.printStackTrace();
                    } <span style="color: #AE5825;">catch</span> (<span style="color: #C6B032; font-style: italic;">BrokenBarrierException</span> <span style="color: #46657B;">e</span>) {
                        e.printStackTrace();
                    }
                }
            });
        }
        exec.shutdown();
    }
}

<span style="color: #4C565D;">////////////////////////////////////////////////////</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">&lt;===================OUTPUT===================&gt; //</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">pool-1-thread-2 is here                        //</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">pool-1-thread-4 is here                        //</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">pool-1-thread-1 is here                        //</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">pool-1-thread-3 is here                        //</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">All people are here, go to lunch!              //</span>
<span style="color: #4C565D;">////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

         <!-- Disqus Comment BEGIN -->
          <div id="disqus_thread"></div>
          <script type="text/javascript">
              var disqus_shortname = 'harrifeng';

              (function() {
                  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
              })();
          </script>
          <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

         <!-- Disqus Comment END -->
</div>
</body>
</html>
