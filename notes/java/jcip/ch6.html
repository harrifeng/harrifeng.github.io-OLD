<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>Chapter 6</title>
<!-- 2015-03-18 Wed 17:27 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="your name" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>

         <link href="http://fonts.googleapis.com/css?family=Droid+Sans+Mono|Galdeano|Open+Sans:600italic,400,600|Roboto+Condensed:400,700" rel="stylesheet" type="text/css">
         <link rel="stylesheet" type="text/css" href="/static/css/main.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="http://harrifeng.github.io/sitemap.html"> UP </a>
 |
 <a accesskey="H" href="http://harrifeng.github.io/index.html"> HOME </a>
</div><div id="preamble" class="status">

         <div id="header">
            <div id="header-top">
                <div id="blog-title">Harrifeng's Path</div>
                <div id="blog-sub-title">纸上得来终觉浅,绝知此事要Coding</div>
            </div>
            <div id="nav">
                <ul>
                    <li><a href="/">首页</a></li>
                    <li><a href="/about.html">About Me</a></li>
                    <li>
                    </li>
                </ul>
            </div>
         </div>
</div>
<div id="content">
<h1 class="title">Chapter 6</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">Task Execution</a>
<ul>
<li><a href="#sec-1-1">Executing Tasks in Threads</a>
<ul>
<li><a href="#sec-1-1-1">Executing Tasks Sequentially</a></li>
<li><a href="#sec-1-1-2">Explicity Creating Threads for Tasks</a></li>
<li><a href="#sec-1-1-3">Disadvantages of Unbounded Thread Creation</a></li>
</ul>
</li>
<li><a href="#sec-1-2">The Executor Framework</a>
<ul>
<li><a href="#sec-1-2-1">Example: Web Server Using Executor</a></li>
<li><a href="#sec-1-2-2">Execution Policies</a></li>
<li><a href="#sec-1-2-3">Thread Pools</a></li>
<li><a href="#sec-1-2-4">Executor Lifecycle</a></li>
<li><a href="#sec-1-2-5">Delayed and Periodic Tasks</a></li>
</ul>
</li>
<li><a href="#sec-1-3">Finding Exploitable Parallelism</a>
<ul>
<li><a href="#sec-1-3-1">Example: Sequential Page Renderer</a></li>
<li><a href="#sec-1-3-2">Result-bearing Tasks: Callable and Future</a></li>
<li><a href="#sec-1-3-3">Example: Page Renderer with Future</a></li>
<li><a href="#sec-1-3-4">Limitations of Parallelizing Heterogeneous Tasks</a></li>
<li><a href="#sec-1-3-5">CompletionService: Executor Meets BlockingQueue</a></li>
<li><a href="#sec-1-3-6">Example: Page Renderer with CompletionService</a></li>
<li><a href="#sec-1-3-7">Placing Time Limits on Tasks</a></li>
<li><a href="#sec-1-3-8">Example: A Travel Reservation Portal</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">Task Execution</h2>
<div class="outline-text-2" id="text-1">
<ul class="org-ul">
<li>大多数的并发应用程序都是以task为基础单位组合起来的.
</li>
<li>所谓task,就是高度抽象,单独的一份工作
</li>
<li>如果能够清晰的划分task,其实也会提高并发程序的响应
</li>
</ul>
</div>
<div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">Executing Tasks in Threads</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>划分task的第一步就是区分出"可以感知的task边界(sensible task boundaries)"
</li>
<li>理想情况下, task都是独立的行动, 他们不依赖于任何的其他task的state, result,
或者side effect
</li>
<li>独立的task会提高并发性能, 因为相互独立,就意味着可以在资源足够多的情况下,尽可
能的并发运行!
</li>
<li>为了提高1调度的灵活性和2task的负载均衡, 每个task使用的资源的不易过大
</li>
<li>在正常的吞吐情况下, server应该兼具如下两点:
<ul class="org-ul">
<li>好的吞吐量(good throughput)
</li>
<li>好的向英雄(good responsiveness)
</li>
</ul>
</li>
<li>而server在承受更大的overload的时候,良好的设计会'平缓的裂化'(graceful degradation)
而拙劣的设计则会迅速宕机.
</li>
<li>清晰的划分task边界,配合清晰的task执行政策,能够让server得到良好的设计避免过
载时候的简单粗暴宕机.
</li>
<li>大部分的服务器都会选择一个最简单的task边界区分方法:
<pre class="example">
       每个单独的用户请求(individual client request),作为一个单独的task
</pre>
</li>
<li>这种task的"区分"方法非常的明确且简单,所以,很多服务器程序都是这样区分task的:
<ul class="org-ul">
<li>Web server
</li>
<li>mail server
</li>
<li>file server
</li>
<li>EJB container
</li>
<li>database server (remote client request)
</li>
</ul>
</li>
<li>这种区分很明显是不会影响其他'任务'的. 比如你'发送一封邮件到mail server'这个
task,显然是不受'别的邮件发送到同一个mail server'的影响的
</li>
</ul>
</div>
<div id="outline-container-sec-1-1-1" class="outline-4">
<h4 id="sec-1-1-1">Executing Tasks Sequentially</h4>
<div class="outline-text-4" id="text-1-1-1">
<ul class="org-ul">
<li>前面说到的是server如何区分task, 下面我们来讲的都是server如何在多个task到来
的情况下处理这些请求(task),并返回结果的
</li>
<li>最简单同时也是最安全,也是最低效的方法就是'线性的'(也就是整个进程只有一个线程的)处理这些请求
</li>
<li>下面就是一个单线程处理请求的例子, HTTP请求都是通过80端口到达这个程序
<div class="org-src-container">

<pre class="src src-java"><span style="color: #AE5825;">public</span> <span style="color: #AE5825;">class</span> <span style="color: #C6B032; font-style: italic;">SingleThreadWebServer</span> {
    <span style="color: #AE5825;">public</span> <span style="color: #AE5825;">static</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">main</span>(<span style="color: #C6B032; font-style: italic;">String</span>[] <span style="color: #46657B;">args</span>) <span style="color: #AE5825;">throws</span> <span style="color: #C6B032; font-style: italic;">IOException</span>{
        <span style="color: #C6B032; font-style: italic;">ServerSocket</span> <span style="color: #46657B;">socket</span> = <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">ServerSocket</span>(80);
        <span style="color: #AE5825;">while</span> (<span style="color: #86453A;">true</span>) {
            <span style="color: #C6B032; font-style: italic;">Socket</span> <span style="color: #46657B;">connection</span> = socket.accept();
            handleRequest(connection);
        }
    }

    <span style="color: #AE5825;">private</span> <span style="color: #AE5825;">static</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">handleRequest</span>(<span style="color: #C6B032; font-style: italic;">Socket</span> <span style="color: #46657B;">connection</span>) {
        <span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">reuest-handling logic here</span>
    }
}
</pre>
</div>
</li>
<li>这种方法正确性是无疑的,但是在生产环境中效率也必定是非常的差.每次只能处理一
个请求的server在实际情况中不存在.
</li>
<li>理想情况下,如果server处理request的时间短到忽略不计,那么single thread server
还是有市场的,但现实的情况下, server至少会在如下两个情况下block:
<ul class="org-ul">
<li>perform socket I/O
</li>
<li>perform database
</li>
</ul>
</li>
<li>在桌面CS系统中,由于没有上述两种IO,而single thread server的设计简单而又安全
所以GUI框架往往采取single thread的架构
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-1-2" class="outline-4">
<h4 id="sec-1-1-2">Explicity Creating Threads for Tasks</h4>
<div class="outline-text-4" id="text-1-1-2">
<ul class="org-ul">
<li>一个更高效的方法是为每一个请求都创建一个thread
<div class="org-src-container">

<pre class="src src-java"><span style="color: #AE5825;">public</span> <span style="color: #AE5825;">class</span> <span style="color: #C6B032; font-style: italic;">ThreadPerTaskWebServer</span> {
    <span style="color: #AE5825;">public</span> <span style="color: #AE5825;">static</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">main</span>(<span style="color: #C6B032; font-style: italic;">String</span>[] <span style="color: #46657B;">args</span>) <span style="color: #AE5825;">throws</span> <span style="color: #C6B032; font-style: italic;">IOException</span>{
        <span style="color: #C6B032; font-style: italic;">ServerSocket</span> <span style="color: #46657B;">socket</span> = <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">ServerSocket</span>(80);
        <span style="color: #AE5825;">while</span> (<span style="color: #86453A;">true</span>) {
            <span style="color: #AE5825;">final</span> <span style="color: #C6B032; font-style: italic;">Socket</span> <span style="color: #46657B;">connectio</span> = socket.accept();
            <span style="color: #C6B032; font-style: italic;">Runnable</span> <span style="color: #46657B;">task</span> = <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">Runnable</span>() {
                <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">run</span>() {
                    handleRequest(connection);
                }
            };
            <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">Thread</span>(task).start();
        }
    }

    <span style="color: #AE5825;">private</span> <span style="color: #AE5825;">static</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">handleRequest</span>(<span style="color: #C6B032; font-style: italic;">Socket</span> <span style="color: #46657B;">connection</span>) {
        <span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">request-handling logic here</span>
    }
}
</pre>
</div>
</li>
<li>这里的main thread在接受到一个新的请求以后,不再是简单的自己埋头处理了,而是
创建了一个新的thread来处理这个task. 这样做会产生如下的后果:
<ul class="org-ul">
<li>处理task的线程会和main线程分道扬镳(有不同的call stack), 所以会提高main
thread的响应速率
</li>
<li>所有被接收的task都有了自己的thread,在资源多的情况下,可以"并行"的执行,在
IO block的时候,也不至于让CPU空转(可以调度给其他thread).
</li>
<li>函数handleRequest必须是thread-safe的, 因为它会同时被多个thread访问
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-1-3" class="outline-4">
<h4 id="sec-1-1-3">Disadvantages of Unbounded Thread Creation</h4>
<div class="outline-text-4" id="text-1-1-3">
<ul class="org-ul">
<li>为每一个thread分别一个线程的作法,其实也无法达到在production的应用强度.因为
这个方法也有比较明显的问题,特别是在thread数量过多的时候:
<ul class="org-ul">
<li>Thread的创建和删除其实也是需要消耗一定的CPU时间的
</li>
<li>Thread的创建也是需要浪费内存的,特别是thread数目超过了processor的数目,那
么多出来的thread只是白白的占用内存而已.
</li>
<li>一个进程可以创建的thread数目是有限制的,这个限制通常是操作系统给的.一旦超
过这个限制, OutOfMemoryError是肯定无法避免的了.
</li>
</ul>
</li>
<li>为每一个request创建一个thread的方法,在实验的时候还可以试试,但是它"无法控制
thread创建的数目", 所以一旦布置上线,很可能会被黑客攻击.即便不算黑客,用户过
多也会让整个server突然宕机.
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">The Executor Framework</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>task是从逻辑上来区分出的一个块工作,而thread是java中能够支持"一个快工作"的机
制. 从逻辑上来讲,每个task一个thread是合乎情理的,但是task来了以后,多久给一个
thread是前面争论的焦点:
<ul class="org-ul">
<li>Single Thread Server是说每一个时刻都只给最前面的task建立一个thread. 这种
方法对server来说,效率太差
</li>
<li>Thread Per Task Server是说,所有的task,只要来了,立马给你建立一个thread. 这
种方法,资源申请容易超出控制.
</li>
</ul>
</li>
<li>所以很明显上面两种做法是两个极端,正确的做法是:
<ul class="org-ul">
<li>给一个task赋予一个thread是肯定的
</li>
<li>但是要控制thread的规模,在某一个时段,只能有N个thread.如果超过了这个thread数
目,再有task来,就block他们.
</li>
</ul>
</li>
<li>java 5给出的答案是Executor的一个implementation(因为Executor):
<pre class="example">
fixed-sized thread pool (能够保证同时只有一定数目thread的存在)
</pre>
</li>
<li>我们首先来看看Executor(它是一个接口)
<div class="org-src-container">

<pre class="src src-java"><span style="color: #AE5825;">public</span> <span style="color: #AE5825;">interface</span> <span style="color: #C6B032; font-style: italic;">Executor</span> {
    <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">execute</span>(<span style="color: #C6B032; font-style: italic;">Runnable</span> <span style="color: #46657B;">command</span>);
}
</pre>
</div>
</li>
<li>Executor接口本身没有多么代码,但是它确有强大的意义, 因为它提供了一种规范(standard),
把task submission和task execution区分开了.它使用了Runnable 来描述task.
<pre class="example">
Executor provides a standard means of decoupling task submission
from task execution, describing tasks as Runnable.
</pre>
</li>
<li>Executor主要关注producer-consumer 模式,也可以这么认为,如果你的代码主要是这
种模式,那么你可以使用Executor,放弃Thread的方式来创建新线程. 而且不出所料的在
某个Executor的实现里面我们发现了BlockingQueue的身影
<div class="org-src-container">

<pre class="src src-java"><span style="color: #AE5825;">private</span> <span style="color: #AE5825;">final</span> <span style="color: #C6B032; font-style: italic;">BlockingQueue</span>&lt;<span style="color: #C6B032; font-style: italic;">Runnable</span>&gt; <span style="color: #46657B;">workQueue</span>;
<span style="color: #AE5825;">public</span> <span style="color: #AE5825;">class</span> <span style="color: #C6B032; font-style: italic;">ThreadPoolExecutor</span> <span style="color: #AE5825;">extends</span> <span style="color: #C6B032; font-style: italic;">AbstractExecutorService</span> {
    <span style="color: #4C565D;">//</span><span style="color: #333B40; font-style: italic;">...</span>
    <span style="color: #AE5825;">private</span> <span style="color: #AE5825;">final</span> <span style="color: #C6B032; font-style: italic;">BlockingQueue</span>&lt;<span style="color: #C6B032; font-style: italic;">Runnable</span>&gt; <span style="color: #46657B;">workQueue</span>;
    <span style="color: #4C565D;">//</span><span style="color: #333B40; font-style: italic;">...</span>
}
</pre>
</div>
</li>
</ul>
</div>
<div id="outline-container-sec-1-2-1" class="outline-4">
<h4 id="sec-1-2-1">Example: Web Server Using Executor</h4>
<div class="outline-text-4" id="text-1-2-1">
<ul class="org-ul">
<li>下面就是一个使用executor来创建thread的例子
<div class="org-src-container">

<pre class="src src-java"><span style="color: #AE5825;">package</span> org.hfeng.book.jcip.<span style="color: #86453A;">ch6</span>;

<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">io</span>.<span style="color: #C6B032; font-style: italic;">IOException</span>;
<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">net</span>.<span style="color: #C6B032; font-style: italic;">ServerSocket</span>;
<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">net</span>.<span style="color: #C6B032; font-style: italic;">Socket</span>;
<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">util</span>.<span style="color: #86453A;">concurrent</span>.<span style="color: #C6B032; font-style: italic;">Executor</span>;
<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">util</span>.<span style="color: #86453A;">concurrent</span>.<span style="color: #C6B032; font-style: italic;">Executors</span>;

<span style="color: #AE5825;">public</span> <span style="color: #AE5825;">class</span> <span style="color: #C6B032; font-style: italic;">TaskExecutionWebServer</span> {
    <span style="color: #AE5825;">private</span> <span style="color: #AE5825;">static</span> <span style="color: #AE5825;">final</span> <span style="color: #C6B032; font-style: italic;">int</span> <span style="color: #46657B;">NTHREADS</span> = 100;
    <span style="color: #AE5825;">private</span> <span style="color: #AE5825;">static</span> <span style="color: #AE5825;">final</span> <span style="color: #C6B032; font-style: italic;">Executor</span> <span style="color: #46657B;">exec</span> = Executors.newFixedThreadPool(NTHREADS);

    <span style="color: #AE5825;">public</span> <span style="color: #AE5825;">static</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">main</span>(<span style="color: #C6B032; font-style: italic;">String</span>[] <span style="color: #46657B;">args</span>) <span style="color: #AE5825;">throws</span> <span style="color: #C6B032; font-style: italic;">IOException</span>{
        <span style="color: #C6B032; font-style: italic;">ServerSocket</span> <span style="color: #46657B;">socket</span> = <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">ServerSocket</span>(80);
        <span style="color: #AE5825;">while</span> (<span style="color: #86453A;">true</span>) {
            <span style="color: #AE5825;">final</span> <span style="color: #C6B032; font-style: italic;">Socket</span> <span style="color: #46657B;">connection</span> = socket.accept();
            <span style="color: #C6B032; font-style: italic;">Runnable</span> <span style="color: #46657B;">task</span> = <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">Runnable</span>() {
                <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">run</span>() {
                    handleRequest(connection);
                }
            };
            exec.execute(task);
        }
    }

    <span style="color: #AE5825;">private</span> <span style="color: #AE5825;">static</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">handleRequest</span>(<span style="color: #C6B032; font-style: italic;">Socket</span> <span style="color: #46657B;">connection</span>) {
        <span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">request-handling logic here</span>
    }
}
</pre>
</div>
</li>
<li>我们也可以使用executor来实现ThreadPer-TaskWebServer, 代码如下
<div class="org-src-container">

<pre class="src src-java"><span style="color: #AE5825;">public</span> <span style="color: #AE5825;">class</span> <span style="color: #C6B032; font-style: italic;">ThreadPerTaskExecutor</span> <span style="color: #AE5825;">implements</span> <span style="color: #C6B032; font-style: italic;">Executor</span> {
    <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">execute</span>(<span style="color: #C6B032; font-style: italic;">Runnable</span> <span style="color: #46657B;">r</span>) {
        <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">Thread</span>(r).start();
    }
}
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2-2" class="outline-4">
<h4 id="sec-1-2-2">Execution Policies</h4>
<div class="outline-text-4" id="text-1-2-2">
<ul class="org-ul">
<li>所谓execution policy是用来决定"what, where, when, and how" of task
execution, 具体来说就是:
<ul class="org-ul">
<li>task会在哪个thread里面执行(并不是每个task都有一个thread)
</li>
<li>task执行的顺序是什么
</li>
<li>最多有多少task"并发concurrently"执行
</li>
<li>最多有多少task可以pending等待执行
</li>
<li>如果系统过载,需要杀掉一些task, 哪些task会被首先牺牲
</li>
<li>执行task之前和之后要有什么操作
</li>
</ul>
</li>
<li>Execution policy是一种资源管理池(resource management tool): 通过限制同时执
行的task的数目， 来达到保证系统不会因为资源耗尽而崩溃，或者太多线程争抢系统
资源大打出手，导致系统响应过慢。
</li>
<li>因为executor的天然的将"submission"和"execution"分开了,导致我们更加容易的更
改execution policy: 比如我们可以在编译阶段再根据硬件状况来决定使用何种的
execution policy
</li>
<li>每当你看到如下代码. 你就可以想办法把它变成executor了, 因为后者更加的灵活,更
容易面对不断更改的需求.
<div class="org-src-container">

<pre class="src src-java"><span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">Thread</span>(runnable).start()
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2-3" class="outline-4">
<h4 id="sec-1-2-3">Thread Pools</h4>
<div class="outline-text-4" id="text-1-2-3">
<ul class="org-ul">
<li>所谓Thread Pool，就是管理一系列相似的worker thread的"容器"
</li>
<li>一个thread pool都会和一个work queue合作
</li>
<li>work thread会从work queue里面申请一个任务,执行完之后,再放回去.
</li>
<li>使用thread pool相比于thread-per-task有很多的优势:
<ul class="org-ul">
<li>重用thread,就不必为每个thread都创建和销毁thread: 创建和销毁thread通常是
消耗系统资源的
</li>
<li>task来的时候,thread已经在了.所以反应会很快
</li>
<li>thread pool的大小设计的合适,会在机器能够承受的情况下,最大限度利用机器资源
</li>
</ul>
</li>
<li>java的Executors(注意有个s) class里面有如下的static factory method来提供 thread
pool实现:
<ul class="org-ul">
<li>newFixedThreadPool : 线程数固定
</li>
<li>newCachedThreadPool : 线程数可以在一定限度下增加
</li>
<li>newSingleThraedExecutor: 只有一个线程的池子
</li>
<li>newScheduledThreadPool: 线程数目固定:主要用来支持delayed, periodic task(和
后面的Timer类似)
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2-4" class="outline-4">
<h4 id="sec-1-2-4">Executor Lifecycle</h4>
<div class="outline-text-4" id="text-1-2-4">
<ul class="org-ul">
<li>下面我们来看看如何关闭executor. 关闭executor就好像关闭一个网上服务:
<ul class="org-ul">
<li>优雅的关闭方式: 不在接受新的任务,老的任务逐渐停止,一旦全部停止了,服务也
就停止
</li>
<li>"粗暴"的关闭方式:直接关机, 老的不再管,新的也不会接受成功.
</li>
<li>介于"粗暴"和"优雅"之间的方式
</li>
</ul>
</li>
<li>ExecutorService借口继承了Executor接口,提供了一系列的处理executor lifecycle
的函数
<div class="org-src-container">

<pre class="src src-java"><span style="color: #AE5825;">public</span> <span style="color: #AE5825;">interface</span> <span style="color: #C6B032; font-style: italic;">ExecutorService</span> <span style="color: #AE5825;">extends</span> <span style="color: #C6B032; font-style: italic;">Executor</span> {
    <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">shutdown</span>();
    <span style="color: #C6B032; font-style: italic;">List</span>&lt;<span style="color: #C6B032; font-style: italic;">Runnable</span>&gt; <span style="color: #C6B032;">shutdownNow</span>();
    <span style="color: #C6B032; font-style: italic;">boolean</span> <span style="color: #C6B032;">isShutdown</span>();
    <span style="color: #C6B032; font-style: italic;">boolean</span> <span style="color: #C6B032;">isTrminated</span>();
    <span style="color: #C6B032; font-style: italic;">boolean</span> <span style="color: #C6B032;">awaitTermination</span>(<span style="color: #C6B032; font-style: italic;">long</span> <span style="color: #46657B;">timeout</span>, <span style="color: #C6B032; font-style: italic;">TimeUnit</span> <span style="color: #46657B;">unit</span>)
        <span style="color: #AE5825;">throws</span> <span style="color: #C6B032; font-style: italic;">InterruptedException</span>;
    <span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">... additional convenience methods for task submission</span>
}
</pre>
</div>
</li>
<li>对于ExecutorService的Executor来说,它有三种state:
<ul class="org-ul">
<li>running: 程序开始的时候就是这个状态
</li>
<li>shutting down:
<ol class="org-ol">
<li>调用了shutdown函数后:此时执行的是graceful shutdown
</li>
<li>调用了shutdownNow函数后: 此时执行的是abrupt shutdown
</li>
</ol>
</li>
<li>terminated: 所有的task都结束以后(比如graceful shutdown了,还要把手头的task
结束掉), 就进入了terminated模式
</li>
</ul>
</li>
<li>下面就是一个使用ExecutorService接口的实现
<div class="org-src-container">

<pre class="src src-java"><span style="color: #AE5825;">package</span> org.hfeng.book.jcip.<span style="color: #86453A;">ch6</span>;

<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">io</span>.<span style="color: #C6B032; font-style: italic;">IOException</span>;
<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">net</span>.<span style="color: #C6B032; font-style: italic;">ServerSocket</span>;
<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">net</span>.<span style="color: #C6B032; font-style: italic;">Socket</span>;
<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">util</span>.<span style="color: #86453A;">concurrent</span>.<span style="color: #C6B032; font-style: italic;">ExecutorService</span>;
<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">util</span>.<span style="color: #86453A;">concurrent</span>.<span style="color: #C6B032; font-style: italic;">Executors</span>;
<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">util</span>.<span style="color: #86453A;">concurrent</span>.<span style="color: #C6B032; font-style: italic;">RejectedExecutionException</span>;
<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">util</span>.<span style="color: #86453A;">logging</span>.<span style="color: #C6B032; font-style: italic;">Level</span>;
<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">util</span>.<span style="color: #86453A;">logging</span>.<span style="color: #C6B032; font-style: italic;">Logger</span>;

<span style="color: #AE5825;">public</span> <span style="color: #AE5825;">class</span> <span style="color: #C6B032; font-style: italic;">LifecycleWebServer</span> {
    <span style="color: #AE5825;">private</span> <span style="color: #AE5825;">final</span> <span style="color: #C6B032; font-style: italic;">ExecutorService</span> <span style="color: #46657B;">exec</span> = Executors.newCachedThreadPool();

    <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">start</span>() <span style="color: #AE5825;">throws</span> <span style="color: #C6B032; font-style: italic;">IOException</span> {
        <span style="color: #C6B032; font-style: italic;">ServerSocket</span> <span style="color: #46657B;">socket</span> = <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">ServerSocket</span>(80);

        <span style="color: #AE5825;">while</span> (!exec.isShutdown()) {
            <span style="color: #AE5825;">try</span> {
                <span style="color: #AE5825;">final</span> <span style="color: #C6B032; font-style: italic;">Socket</span> <span style="color: #46657B;">conn</span> = socket.accept();
                exec.execute(<span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">Runnable</span>() {
                    <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">run</span>() {
                        handleRequest(conn);
                    }
                });
            } <span style="color: #AE5825;">catch</span> (<span style="color: #C6B032; font-style: italic;">RejectedExecutionException</span> <span style="color: #46657B;">e</span>) {
                <span style="color: #AE5825;">if</span> (!exec.isShutdown()) {
                    log(<span style="color: #5A7644;">"task submission rejected"</span>, e);
                }
            }
        }
    }

    <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">stop</span>() {
        exec.shutdown();
    }

    <span style="color: #AE5825;">private</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">log</span>(<span style="color: #C6B032; font-style: italic;">String</span> <span style="color: #46657B;">msg</span>, <span style="color: #C6B032; font-style: italic;">Exception</span> <span style="color: #46657B;">e</span>) {
        Logger.getAnonymousLogger().log(<span style="color: #86453A;">Level</span>.WARNING, msg, e);
    }

    <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">handleRequest</span>(<span style="color: #C6B032; font-style: italic;">Socket</span> <span style="color: #46657B;">connection</span>) {
        <span style="color: #C6B032; font-style: italic;">Request</span> <span style="color: #46657B;">req</span> = readRequest(connection);
        <span style="color: #AE5825;">if</span> (isShutdownRequest(req)) {
            stop();
        } <span style="color: #AE5825;">else</span> {
            dispatchRequest(req);
        }
    }

    <span style="color: #AE5825;">private</span> <span style="color: #C6B032; font-style: italic;">Request</span> <span style="color: #C6B032;">readRequest</span>(<span style="color: #C6B032; font-style: italic;">Socket</span> <span style="color: #46657B;">s</span>) {
        <span style="color: #AE5825;">return</span> <span style="color: #86453A;">null</span>;
    }

    <span style="color: #AE5825;">private</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">dispatchRequest</span>(<span style="color: #C6B032; font-style: italic;">Request</span> <span style="color: #46657B;">r</span>) {
    }

    <span style="color: #AE5825;">private</span> <span style="color: #C6B032; font-style: italic;">boolean</span> <span style="color: #C6B032;">isShutdownRequest</span>(<span style="color: #C6B032; font-style: italic;">Request</span> <span style="color: #46657B;">r</span>) {
        <span style="color: #AE5825;">return</span> <span style="color: #86453A;">false</span>;
    }

    <span style="color: #AE5825;">interface</span> <span style="color: #C6B032; font-style: italic;">Request</span> {
    }
}
</pre>
</div>
</li>
<li>从上面的代码我们可以看到,如果想关闭这个executor,有两个办法:
<ul class="org-ul">
<li>本地stop()
</li>
<li>client端还可以发送一个request过来,如果是一个shutdownrequest(函数isShutdownRequest(req)
的结果为true的话), 那么也会导致executor关闭
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2-5" class="outline-4">
<h4 id="sec-1-2-5">Delayed and Periodic Tasks</h4>
<div class="outline-text-4" id="text-1-2-5">
<ul class="org-ul">
<li>Java里面有Timer一类的函数,用来运行 deferred 和 periodic的事件:
<ul class="org-ul">
<li>deferred task: run this task in 100ms
</li>
<li>periodic task: run this task every 10 ms
</li>
</ul>
</li>
<li>Timer类函数,有一些自身的缺点,比如只能使用absolute的time设置,无法设置relative
的time设置. 所以一旦系统时间有改变,对于Time来说就可能会有问题.
</li>
<li>Timer的问题还主要在它内部给"所有"Timer task分配的"总共"只有一个thread,所以
如果一个TimerTask被设定为没10ms运行一次,而另外一个设置为每40ms运行一次. 那
么可能的结果是:
<ol class="org-ol">
<li>要么40ms的先得到那个thread运行,然后结束了.另外一个task猜得到thread,会接
连运行两次
</li>
<li>要么10ms的先得到thread,然后运行, 40ms的就被完全忘记了
</li>
</ol>
</li>
<li>Timer的再一个问题也是"自己只有一个thread为所有的TimeTask服务"这个原因造成的,
比如其中一个TimeTask抛出异常,这个内部的thread就结束了,全然不顾可能还有其他
TimeTask还要用到它, 例子如下
<div class="org-src-container">

<pre class="src src-java"><span style="color: #AE5825;">package</span> org.hfeng.book.jcip.<span style="color: #86453A;">ch6</span>;

<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">util</span>.<span style="color: #C6B032; font-style: italic;">Timer</span>;
<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">util</span>.<span style="color: #C6B032; font-style: italic;">TimerTask</span>;
<span style="color: #AE5825;">import</span> <span style="color: #AE5825;">static</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">util</span>.<span style="color: #86453A;">concurrent</span>.<span style="color: #86453A;">TimeUnit</span>.<span style="color: #C6B032; font-style: italic;">SECONDS</span>;

<span style="color: #AE5825;">public</span> <span style="color: #AE5825;">class</span> <span style="color: #C6B032; font-style: italic;">OutOfTime</span> {
    <span style="color: #AE5825;">public</span> <span style="color: #AE5825;">static</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">main</span>(<span style="color: #C6B032; font-style: italic;">String</span>[] <span style="color: #46657B;">args</span>) <span style="color: #AE5825;">throws</span> <span style="color: #C6B032; font-style: italic;">Exception</span>{
        <span style="color: #C6B032; font-style: italic;">Timer</span> <span style="color: #46657B;">timer</span> = <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">Timer</span>();
        timer.schedule(<span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">ThrowTask</span>(), 1);
        SECONDS.sleep(1);
        timer.schedule(<span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">ThrowTask</span>(), 1);
        SECONDS.sleep(5);
    }

    <span style="color: #AE5825;">static</span> <span style="color: #AE5825;">class</span> <span style="color: #C6B032; font-style: italic;">ThrowTask</span> <span style="color: #AE5825;">extends</span> <span style="color: #C6B032; font-style: italic;">TimerTask</span> {
        <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">run</span>() {
            <span style="color: #AE5825;">throw</span> <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">RuntimeException</span>();
        }
    }
}

<span style="color: #4C565D;">/////////////////////////////////////////////////////////////////////////////////////////////////////</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">&lt;===================OUTPUT===================&gt;                                                  //</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">Exception in thread "Timer-0" java.lang.RuntimeException                                        //</span>
<span style="color: #4C565D;">//  </span><span style="color: #333B40; font-style: italic;">at org.hfeng.book.jcip.ch6.OutOfTime$ThrowTask.run(OutOfTime.java:18)                          //</span>
<span style="color: #4C565D;">//  </span><span style="color: #333B40; font-style: italic;">at java.util.TimerThread.mainLoop(Timer.java:555)                                              //</span>
<span style="color: #4C565D;">//  </span><span style="color: #333B40; font-style: italic;">at java.util.TimerThread.run(Timer.java:505)                                                   //</span>
<span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">Exception in thread "main" java.lang.IllegalStateException: Timer already cancelled.            //</span>
<span style="color: #4C565D;">//  </span><span style="color: #333B40; font-style: italic;">at java.util.Timer.sched(Timer.java:397)                                                       //</span>
<span style="color: #4C565D;">//  </span><span style="color: #333B40; font-style: italic;">at java.util.Timer.schedule(Timer.java:193)                                                    //</span>
<span style="color: #4C565D;">//  </span><span style="color: #333B40; font-style: italic;">at org.hfeng.book.jcip.ch6.OutOfTime.main(OutOfTime.java:12)                                   //</span>
<span style="color: #4C565D;">//  </span><span style="color: #333B40; font-style: italic;">at sun.reflect.NativeMethodAccessorImpl.invoke0(Native Method)                                 //</span>
<span style="color: #4C565D;">//  </span><span style="color: #333B40; font-style: italic;">at sun.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:57)               //</span>
<span style="color: #4C565D;">//  </span><span style="color: #333B40; font-style: italic;">at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)       //</span>
<span style="color: #4C565D;">//  </span><span style="color: #333B40; font-style: italic;">at java.lang.reflect.Method.invoke(Method.java:606)                                            //</span>
<span style="color: #4C565D;">//  </span><span style="color: #333B40; font-style: italic;">at com.intellij.rt.execution.application.AppMain.main(AppMain.java:134)                        //</span>
<span style="color: #4C565D;">/////////////////////////////////////////////////////////////////////////////////////////////////////</span>
</pre>
</div>
</li>
<li>ScheduledThreadPoolExecutor一定程度上弥补了Timer的缺点,可以看做是Timer实现
delay或periodic task的一种replacement
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">Finding Exploitable Parallelism</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>在server系统中,一个request就天然的是一个task,也就天然的可以分给一个thread去
使用
</li>
<li>但是在desktop开发中,却没有request这么好的"自然边界"存在.需要我们自己去找寻.
</li>
</ul>
</div>
<div id="outline-container-sec-1-3-1" class="outline-4">
<h4 id="sec-1-3-1">Example: Sequential Page Renderer</h4>
<div class="outline-text-4" id="text-1-3-1">
<ul class="org-ul">
<li>处理HTML解析最简单的办法,当然就是线性的处理HTML文件:
<ul class="org-ul">
<li>遇到文字markup, 放到处理结果里面
</li>
<li>遇到图片markup, 下载图片, 然后放到处理结果里面
</li>
<li>最后都解析完,把结果展示给用户
</li>
</ul>
</li>
<li>上述线性处理HTML解析的方法非常容易实现,但是这可能会让用户不满:因为你要过很
久才能把网页全部解析完,然后用户才能看. 但是很多时候,用户不想傻等,他想先看到
点什么
</li>
<li>一个微小的改进,就是先显示"文字",因为文字解析的快.然后图片是作为"占位符"放在
那里.等待下载完成. 下面就是这样一个例子: 先renderText, image在后面慢慢来.
<div class="org-src-container">

<pre class="src src-java"><span style="color: #AE5825;">package</span> org.hfeng.book.jcip.<span style="color: #86453A;">ch6</span>;

<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">util</span>.<span style="color: #C6B032; font-style: italic;">ArrayList</span>;
<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">util</span>.<span style="color: #C6B032; font-style: italic;">List</span>;

<span style="color: #AE5825;">public</span> <span style="color: #AE5825;">abstract</span> <span style="color: #AE5825;">class</span> <span style="color: #C6B032; font-style: italic;">SingleThreadRenderer</span> {
    <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">renderPage</span>(<span style="color: #C6B032; font-style: italic;">CharSequence</span> <span style="color: #46657B;">source</span>) {
        renderText(source);
        <span style="color: #C6B032; font-style: italic;">List</span>&lt;<span style="color: #C6B032; font-style: italic;">ImageData</span>&gt; <span style="color: #46657B;">imageData</span> = <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">ArrayList</span>&lt;<span style="color: #C6B032; font-style: italic;">ImageData</span>&gt;();
        <span style="color: #AE5825;">for</span> (<span style="color: #C6B032; font-style: italic;">ImageInfo</span> <span style="color: #46657B;">imageinfo</span>: scanForImageInfo(source)) {
            imageData.add(imageinfo.downloadImage());
        }
        <span style="color: #AE5825;">for</span> (<span style="color: #C6B032; font-style: italic;">ImageData</span> <span style="color: #46657B;">data</span> : imageData) {
            renderImage(data);
        }
    }

    <span style="color: #AE5825;">interface</span> <span style="color: #C6B032; font-style: italic;">ImageData</span> {
    }

    <span style="color: #AE5825;">interface</span> <span style="color: #C6B032; font-style: italic;">ImageInfo</span> {
        <span style="color: #C6B032; font-style: italic;">ImageData</span> <span style="color: #C6B032;">downloadImage</span>();
    }

    <span style="color: #AE5825;">abstract</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">renderText</span>(<span style="color: #C6B032; font-style: italic;">CharSequence</span> <span style="color: #46657B;">s</span>);
    <span style="color: #AE5825;">abstract</span> <span style="color: #C6B032; font-style: italic;">List</span>&lt;<span style="color: #C6B032; font-style: italic;">ImageInfo</span>&gt; <span style="color: #C6B032;">scanForImageInfo</span>(<span style="color: #C6B032; font-style: italic;">CharSequence</span> <span style="color: #46657B;">s</span>);
    <span style="color: #AE5825;">abstract</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">renderImage</span>(<span style="color: #C6B032; font-style: italic;">ImageData</span> <span style="color: #46657B;">i</span>);
}
</pre>
</div>
</li>
<li>上面的操作还是线性的, 更好的方法当然是把整个解析HTML语言的过程分成'不同的
相互不干扰'的task,然后分给不同的thread去做
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-3-2" class="outline-4">
<h4 id="sec-1-3-2">Result-bearing Tasks: Callable and Future</h4>
<div class="outline-text-4" id="text-1-3-2">
<ul class="org-ul">
<li>Exacutor内部使用了Runnable接口来表达"task"的概念, 但是Runnable接口有如下的
缺点:
<ul class="org-ul">
<li>无法返回值
</li>
<li>无法抛出checked exception
</li>
</ul>
</li>
<li>Callable弥补了Runnable的两个缺陷,可以看做是一种良好的replacement.Executor是
可以include callable的
<div class="org-src-container">

<pre class="src src-java"><span style="color: #AE5825;">public</span> <span style="color: #AE5825;">interface</span> <span style="color: #C6B032; font-style: italic;">Callable</span>&lt;<span style="color: #C6B032; font-style: italic;">V</span>&gt; {
    <span style="color: #C6B032; font-style: italic;">V</span> <span style="color: #C6B032;">call</span>() <span style="color: #AE5825;">throws</span> <span style="color: #C6B032; font-style: italic;">Exception</span>;
}
</pre>
</div>
</li>
<li>无论是Runnable还是Callable其实都是描述task的, 而这个"task"一旦被Executor所
包括,那么它通常有如下四个生命周期:
<ul class="org-ul">
<li>created
</li>
<li>submitted
</li>
<li>started
</li>
<li>completed
</li>
</ul>
</li>
<li>我们前面说了,Executor的提出就是用有限的几个thread来运行"多得多的"task, 也
就是说,一个task可能要过很久才能轮的上去执行.那么我们就会想着去cancle某些task,
在Executor framework下,cancle规则如下:
<ul class="org-ul">
<li>submitted了但是没started的,总是可以cancle
</li>
<li>started了,某些情况下可以cancle
</li>
<li>如果已经completed了,那么即便你调用了cancle,也不会有副作用
</li>
</ul>
</li>
<li>Future用来管理(比如查看task是否完成, 是否被cancel, 读取结果等待)task的声明
周期.
<div class="org-src-container">

<pre class="src src-java"><span style="color: #AE5825;">public</span> <span style="color: #AE5825;">interface</span> <span style="color: #C6B032; font-style: italic;">Future</span>&lt;<span style="color: #C6B032; font-style: italic;">V</span>&gt; {
    <span style="color: #C6B032; font-style: italic;">boolean</span> <span style="color: #C6B032;">cancel</span>(<span style="color: #C6B032; font-style: italic;">boolean</span> <span style="color: #46657B;">mayInterruptIfRunning</span>);
    <span style="color: #C6B032; font-style: italic;">boolean</span> <span style="color: #C6B032;">isCancelled</span>();
    <span style="color: #C6B032; font-style: italic;">boolean</span> <span style="color: #C6B032;">isDone</span>();
    <span style="color: #C6B032; font-style: italic;">V</span> <span style="color: #C6B032;">get</span>() <span style="color: #AE5825;">throws</span> <span style="color: #C6B032; font-style: italic;">InterruptedException</span>, <span style="color: #C6B032; font-style: italic;">ExecutionException</span>,
                   <span style="color: #C6B032; font-style: italic;">CancellationException</span>;
    <span style="color: #C6B032; font-style: italic;">V</span> <span style="color: #C6B032;">get</span>(<span style="color: #C6B032; font-style: italic;">long</span> <span style="color: #46657B;">timeout</span>, <span style="color: #C6B032; font-style: italic;">TimeUnit</span> <span style="color: #46657B;">unit</span>)
        <span style="color: #AE5825;">throws</span> <span style="color: #C6B032; font-style: italic;">InterruptedException</span>, <span style="color: #C6B032; font-style: italic;">ExecutionException</span>,
               <span style="color: #C6B032; font-style: italic;">CancellationException</span>, <span style="color: #C6B032; font-style: italic;">TimeoutException</span>;
}
</pre>
</div>
</li>
<li>ExecutorService的submit函数会返回一个Future的instance,用来追踪这个task的状
态.
</li>
<li>FutureTask是一个实现了1.Runnable和2.Future接口的类, 所以把它自己就可以检测
自己的状态
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-3-3" class="outline-4">
<h4 id="sec-1-3-3">Example: Page Renderer with Future</h4>
<div class="outline-text-4" id="text-1-3-3">
<ul class="org-ul">
<li>我们来实现我们刚才的设想: 把处理HTML代码的过程分成多个task. 这里我们的初
步设想是分成两个task:
<ul class="org-ul">
<li>一个转换text markup (CPU-bound)
</li>
<li>一个下载图片 (I/O-bound)
</li>
</ul>
</li>
<li>下面就是我们的代码, 我们使用Callable来下载图片,而在main thread里面进行进行
文本的转换. 而一旦所有的文本都下载下来的话,我们可以把他们都显示出来
<div class="org-src-container">

<pre class="src src-java"><span style="color: #AE5825;">package</span> org.hfeng.book.jcip.<span style="color: #86453A;">ch6</span>;

<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">util</span>.<span style="color: #C6B032; font-style: italic;">ArrayList</span>;
<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">util</span>.<span style="color: #C6B032; font-style: italic;">List</span>;
<span style="color: #AE5825;">import</span> <span style="color: #86453A;">java</span>.<span style="color: #86453A;">util</span>.<span style="color: #86453A;">concurrent</span>.*;

<span style="color: #AE5825;">public</span> <span style="color: #AE5825;">abstract</span> <span style="color: #AE5825;">class</span> <span style="color: #C6B032; font-style: italic;">FutureRenderer</span> {
    <span style="color: #AE5825;">private</span> <span style="color: #AE5825;">final</span> <span style="color: #C6B032; font-style: italic;">ExecutorService</span> <span style="color: #46657B;">executor</span> = Executors.newCachedThreadPool();

    <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">renderPage</span>(<span style="color: #C6B032; font-style: italic;">CharSequence</span> <span style="color: #46657B;">source</span>) {
        <span style="color: #AE5825;">final</span> <span style="color: #C6B032; font-style: italic;">List</span>&lt;<span style="color: #C6B032; font-style: italic;">ImageInfo</span>&gt; <span style="color: #46657B;">imageInfos</span> = scanForImageInfo(source);
        <span style="color: #C6B032; font-style: italic;">Callable</span>&lt;<span style="color: #C6B032; font-style: italic;">List</span>&lt;<span style="color: #C6B032; font-style: italic;">ImageData</span>&gt;&gt; <span style="color: #46657B;">task</span> =
                <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">Callable</span>&lt;<span style="color: #C6B032; font-style: italic;">List</span>&lt;<span style="color: #C6B032; font-style: italic;">ImageData</span>&gt;&gt;() {
                    <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">List</span>&lt;<span style="color: #C6B032; font-style: italic;">ImageData</span>&gt; <span style="color: #C6B032;">call</span>() <span style="color: #AE5825;">throws</span> <span style="color: #C6B032; font-style: italic;">Exception</span> {
                        <span style="color: #C6B032; font-style: italic;">List</span>&lt;<span style="color: #C6B032; font-style: italic;">ImageData</span>&gt; <span style="color: #46657B;">result</span> = <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">ArrayList</span>&lt;<span style="color: #C6B032; font-style: italic;">ImageData</span>&gt;();
                        <span style="color: #AE5825;">for</span> (<span style="color: #C6B032; font-style: italic;">ImageInfo</span> <span style="color: #46657B;">imageInfo</span> : imageInfos) {
                            result.add(imageInfo.downloadImage());
                        }
                        <span style="color: #AE5825;">return</span> result;
                    }
                };
        <span style="color: #C6B032; font-style: italic;">Future</span>&lt;<span style="color: #C6B032; font-style: italic;">List</span>&lt;<span style="color: #C6B032; font-style: italic;">ImageData</span>&gt;&gt; <span style="color: #46657B;">future</span> = executor.submit(task);
        renderText(source);

        <span style="color: #AE5825;">try</span> {
            <span style="color: #C6B032; font-style: italic;">List</span>&lt;<span style="color: #C6B032; font-style: italic;">ImageData</span>&gt; <span style="color: #46657B;">imageData</span> = future.get();
            <span style="color: #AE5825;">for</span> (<span style="color: #C6B032; font-style: italic;">ImageData</span> <span style="color: #46657B;">data</span> : imageData) {
                renderImage(data);
            }
        } <span style="color: #AE5825;">catch</span> (<span style="color: #C6B032; font-style: italic;">InterruptedException</span> <span style="color: #46657B;">e</span>) {
            <span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">Re-assert the thread's interrupted status</span>
            Thread.currentThread().interrupt();
            <span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">Wd don't need the result, so cancel the task too</span>
            future.cancel(<span style="color: #86453A;">true</span>);
        } <span style="color: #AE5825;">catch</span> (<span style="color: #C6B032; font-style: italic;">ExecutionException</span> <span style="color: #46657B;">e</span>) {

        }
    }

    <span style="color: #AE5825;">interface</span> <span style="color: #C6B032; font-style: italic;">ImageData</span> {
    }

    <span style="color: #AE5825;">interface</span> <span style="color: #C6B032; font-style: italic;">ImageInfo</span> {
        <span style="color: #C6B032; font-style: italic;">ImageData</span> <span style="color: #C6B032;">downloadImage</span>();
    }

    <span style="color: #AE5825;">abstract</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">renderText</span>(<span style="color: #C6B032; font-style: italic;">CharSequence</span> <span style="color: #46657B;">s</span>);

    <span style="color: #AE5825;">abstract</span> <span style="color: #C6B032; font-style: italic;">List</span>&lt;<span style="color: #C6B032; font-style: italic;">ImageInfo</span>&gt; <span style="color: #C6B032;">scanForImageInfo</span>(<span style="color: #C6B032; font-style: italic;">CharSequence</span> <span style="color: #46657B;">s</span>);

    <span style="color: #AE5825;">abstract</span> <span style="color: #C6B032; font-style: italic;">void</span> <span style="color: #C6B032;">renderImage</span>(<span style="color: #C6B032; font-style: italic;">ImageData</span> <span style="color: #46657B;">i</span>);
}
</pre>
</div>
</li>
<li>这个例子中已经有了一点"并发"了: 文本处理的同时,在下载图片. 但是其实我们可
以做的更加的并发:因为所有图片都下载好了再呈现,显然不如'有个图片就呈现'更好
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-3-4" class="outline-4">
<h4 id="sec-1-3-4">Limitations of Parallelizing Heterogeneous Tasks</h4>
<div class="outline-text-4" id="text-1-3-4">
<ul class="org-ul">
<li>上面我们区分task的方法是:把"不同"的task分给"不同"的thread:
<ul class="org-ul">
<li>下载的task分给callable thread
</li>
<li>处理文字的分给main thread
</li>
</ul>
</li>
<li>这种分配任务的方法有很大的缺点:因为任务不同,所以万一某个任务比较容易完成,
而另外一个需要的时间过长.那么其中有一个thread很快就结束了.使用多线程的意义
不大.
</li>
<li>比如上面的下载task用了10秒钟, 而文字处理使用了1秒钟,那么总共使用10秒,很原来
线性的11秒比起来,并没有多大的提升(9%而已), 而我们却使用了两个thread, 理论
最大提升是50%
</li>
<li>所以多线程的正道是把"相同"的task分到"不同"的thread里面
<pre class="example">
The real performance payoff of dividing a program's workload into
tasks comes when there are a large number of independent, homogeneous
tasks that can be processed concurrently
</pre>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-3-5" class="outline-4">
<h4 id="sec-1-3-5">CompletionService: Executor Meets BlockingQueue</h4>
<div class="outline-text-4" id="text-1-3-5">
<ul class="org-ul">
<li>下面我们的做法就应该是找到那些"相同"的task了. 一个页面上面有n个图片. 每个图
片的下载过程就是一个task
</li>
<li>我们有多个task,但是每个task的完成时间是有限度的.我们不可能busy waiting来
不停的去submit返回的那个Future来查看哪些已经可以了.这太麻烦了.我们期望有一
个container来管理这些Future, 而且希望能够做到每次take都能返回完成的工作, 没
有完成的就block (这很像blockingQueue)
</li>
<li>于是CompletionService在聚合(aggregate)了Executor和BlockingQueue之后为大家
提供了一个既"能够以Executor的形式运行相同task"又"能以容器的结构保存Future结果"
</li>
<li>下面是CompletionService的一个实现: ExecutorCompletionService
<div class="org-src-container">

<pre class="src src-java"><span style="color: #AE5825;">public</span> <span style="color: #AE5825;">class</span> <span style="color: #C6B032; font-style: italic;">ExecutorCompletionService</span>&lt;<span style="color: #C6B032; font-style: italic;">V</span>&gt; <span style="color: #AE5825;">implements</span> <span style="color: #C6B032; font-style: italic;">CompletionService</span>&lt;<span style="color: #C6B032; font-style: italic;">V</span>&gt; {
    <span style="color: #AE5825;">private</span> <span style="color: #AE5825;">final</span> <span style="color: #C6B032; font-style: italic;">Executor</span> <span style="color: #46657B;">executor</span>;
    <span style="color: #AE5825;">private</span> <span style="color: #AE5825;">final</span> <span style="color: #C6B032; font-style: italic;">AbstractExecutorService</span> <span style="color: #46657B;">aes</span>;
    <span style="color: #AE5825;">private</span> <span style="color: #AE5825;">final</span> <span style="color: #C6B032; font-style: italic;">BlockingQueue</span>&lt;<span style="color: #C6B032; font-style: italic;">Future</span>&lt;<span style="color: #C6B032; font-style: italic;">V</span>&gt;&gt; <span style="color: #46657B;">completionQueue</span>;
    <span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">...</span>
}
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-3-6" class="outline-4">
<h4 id="sec-1-3-6">Example: Page Renderer with CompletionService</h4>
<div class="outline-text-4" id="text-1-3-6">
<ul class="org-ul">
<li>下面就是使用CompletionService的一个例子.
</li>
<li>从例子中我们可以看到, CompletionService使用的是一个executor (具体使用哪种
executor,可以在实例化的时候再决定).
</li>
<li>这里的CompletionService: 处理了多个thread的返回结果(用BlockingQueue保存),
其实相当于处理"一个"thread时候的Future.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-3-7" class="outline-4">
<h4 id="sec-1-3-7">Placing Time Limits on Tasks</h4>
<div class="outline-text-4" id="text-1-3-7">
<ul class="org-ul">
<li>处理task的时候,如果过了一定的时间,这个task还没有完,那么就没有必要再等了.我
们可以使用timed版本的Future.get(): 一旦过了一定时间,它就不再去get了,而是抛
出TimeoutException
</li>
<li>下面就是一个timed版本的Future.get使用方法(多了两个时间参数), 如果在规定时间
内得不到值,那么就可以cancle这个task(通过Future), 然后调用default的广告.
<div class="org-src-container">

<pre class="src src-java"><span style="color: #C6B032; font-style: italic;">Page</span> <span style="color: #C6B032;">renderPageWithAd</span>() <span style="color: #AE5825;">throws</span> <span style="color: #C6B032; font-style: italic;">InterruptedException</span> {
    <span style="color: #C6B032; font-style: italic;">long</span> <span style="color: #46657B;">endnanos</span> = System.nanoTime() + TIME_BUDGET;
    <span style="color: #C6B032; font-style: italic;">Future</span>&lt;<span style="color: #C6B032; font-style: italic;">Ad</span>&gt; <span style="color: #46657B;">f</span> = exec.submit(<span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">FetchAdTask</span>());
    <span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">Render the page while waiting for the ad</span>
    <span style="color: #C6B032; font-style: italic;">Page</span> <span style="color: #46657B;">page</span> = renderPageBody();
    <span style="color: #C6B032; font-style: italic;">Ad</span> <span style="color: #46657B;">ad</span>;
    <span style="color: #AE5825;">try</span> {
        <span style="color: #4C565D;">// </span><span style="color: #333B40; font-style: italic;">Only wait for the remaining time budget</span>
        <span style="color: #C6B032; font-style: italic;">long</span> <span style="color: #46657B;">timeLeft</span> = endNanos - System.nanoTime();
        ad = f.get(timeLeft, NANOSECONDS);
    } <span style="color: #AE5825;">catch</span> (<span style="color: #C6B032; font-style: italic;">ExecutionException</span> <span style="color: #46657B;">e</span>) {
        ad = DEFAULT_AD;
    } <span style="color: #AE5825;">catch</span> (<span style="color: #C6B032; font-style: italic;">TimeoutException</span> <span style="color: #46657B;">e</span>) {
        ad = DEFAULT_AD;
        f.cancel(<span style="color: #86453A;">true</span>);
    }
    page.setAd(ad);
    <span style="color: #AE5825;">return</span> page;
}
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-3-8" class="outline-4">
<h4 id="sec-1-3-8">Example: A Travel Reservation Portal</h4>
<div class="outline-text-4" id="text-1-3-8">
<ul class="org-ul">
<li>前面讲了如何给一个Future.get设置timeout时间.如果有很多个task,要设置同样的
timeout的话,我们给出的解决方案是invokeAll
</li>
<li>下面是一个invokeAll的例子:航空公司选择网站
<div class="org-src-container">

<pre class="src src-java"><span style="color: #AE5825;">private</span> <span style="color: #AE5825;">class</span> <span style="color: #C6B032; font-style: italic;">QuoteTask</span> <span style="color: #AE5825;">implements</span> <span style="color: #C6B032; font-style: italic;">Callable</span>&lt;<span style="color: #C6B032; font-style: italic;">TrabelQueue</span>&gt; {
    <span style="color: #AE5825;">private</span> <span style="color: #AE5825;">final</span> <span style="color: #C6B032; font-style: italic;">TravelCompany</span> <span style="color: #46657B;">company</span>;
    <span style="color: #AE5825;">private</span> <span style="color: #AE5825;">final</span> <span style="color: #C6B032; font-style: italic;">TravelInfo</span> <span style="color: #46657B;">travelInfo</span>;
    <span style="color: #4C565D;">//</span><span style="color: #333B40; font-style: italic;">...</span>
    <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">TravelQuote</span> <span style="color: #C6B032;">call</span>() <span style="color: #AE5825;">throws</span> <span style="color: #C6B032; font-style: italic;">Exception</span> {
        <span style="color: #AE5825;">return</span> company.solicitQuote(travelInfo);
    }
}

<span style="color: #AE5825;">public</span> <span style="color: #AE5825;">class</span> <span style="color: #C6B032; font-style: italic;">Portal</span> {
    <span style="color: #AE5825;">public</span> <span style="color: #C6B032; font-style: italic;">List</span>&lt;<span style="color: #C6B032; font-style: italic;">TravelQuote</span>&gt; <span style="color: #C6B032;">getRankedTravelQuotes</span>(<span style="color: #C6B032; font-style: italic;">TravelInfo</span> <span style="color: #46657B;">travelInfo</span>,
                                                   <span style="color: #C6B032; font-style: italic;">Set</span>&lt;<span style="color: #C6B032; font-style: italic;">TravelCompany</span>&gt; <span style="color: #46657B;">companies</span>,
                                                   <span style="color: #C6B032; font-style: italic;">Comparator</span>&lt;<span style="color: #C6B032; font-style: italic;">TravelQuote</span>&gt; <span style="color: #46657B;">ranking</span>,
                                                   <span style="color: #C6B032; font-style: italic;">long</span> <span style="color: #46657B;">time</span>,
                                                   <span style="color: #C6B032; font-style: italic;">TimeUnit</span> <span style="color: #46657B;">unit</span>) <span style="color: #AE5825;">throws</span> <span style="color: #C6B032; font-style: italic;">InterruptedException</span> {
        <span style="color: #C6B032; font-style: italic;">List</span>&lt;<span style="color: #C6B032; font-style: italic;">QuoteTask</span>&gt; <span style="color: #46657B;">tasks</span> = <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">ArrayList</span>&lt;<span style="color: #C6B032; font-style: italic;">QuoteTask</span>&gt;();
        <span style="color: #AE5825;">for</span> (<span style="color: #C6B032; font-style: italic;">TravelCompany</span> <span style="color: #46657B;">company</span> : companies) {
            tasks.add(<span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">QuoteTask</span>(company, travelInfo));
        }

        <span style="color: #C6B032; font-style: italic;">List</span>&lt;<span style="color: #C6B032; font-style: italic;">Future</span>&lt;<span style="color: #C6B032; font-style: italic;">TravelQuote</span>&gt;&gt; <span style="color: #46657B;">futures</span> =
            exec.invokeAll(tasks, time, unit);

        <span style="color: #C6B032; font-style: italic;">List</span>&lt;<span style="color: #C6B032; font-style: italic;">TravelQuote</span>&gt; <span style="color: #46657B;">quotes</span> =
            <span style="color: #AE5825;">new</span> <span style="color: #C6B032; font-style: italic;">ArrayList</span>&lt;<span style="color: #C6B032; font-style: italic;">TravelQuote</span>&gt;(tasks.size());

        <span style="color: #C6B032; font-style: italic;">Iterator</span>&lt;<span style="color: #C6B032; font-style: italic;">QuoteTask</span>&gt; <span style="color: #46657B;">taskIter</span> = tasks.iterator();
        <span style="color: #AE5825;">for</span> (<span style="color: #C6B032; font-style: italic;">Future</span>&lt;<span style="color: #C6B032; font-style: italic;">TravelQuote</span>&gt; <span style="color: #46657B;">f</span> : futures) {
            <span style="color: #C6B032; font-style: italic;">QuoteTask</span> <span style="color: #46657B;">task</span> = tastIter.next();
            <span style="color: #AE5825;">try</span> {
                quotes.add(f.get());
            } <span style="color: #AE5825;">catch</span> (<span style="color: #C6B032; font-style: italic;">ExecutionException</span> <span style="color: #46657B;">e</span>) {
                quotes.add(task.getFailureQuote(e.getCause()));
            } <span style="color: #AE5825;">catch</span> (<span style="color: #C6B032; font-style: italic;">CancellationException</span> <span style="color: #46657B;">e</span>) {
                quotes.add(task.getTimeoutQuote(e));
            }
        }
    }
    Collections.sort(quotes, ranking);
    <span style="color: #AE5825;">return</span> quotes;
}
</pre>
</div>
</li>
<li>用户在输入了旅行时间和旅行要求以后.网站利用各个航空公司网站的API去查询. 显
然等到所有的航空公司都返回数据然后显示显然是不正确的.
</li>
<li>正确的做法是等待一定的时间,没返回数据的航空公司就不管了.然后把取到数据的航
空公司排序(因为要排序,所以不能出现一个显示一个), 然后显示给用户. 没返回数
据的航空公司就显示一条"没有从Airline Java得到数据"就可以了
</li>
<li>给他所有航空公司的timeout是一样的,所以我们在invokeAll里面一次设置就可以了.
</li>
</ul>
</div>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

         <!-- Disqus Comment BEGIN -->
          <div id="disqus_thread"></div>
          <script type="text/javascript">
              var disqus_shortname = 'harrifeng';

              (function() {
                  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
              })();
          </script>
          <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

         <!-- Disqus Comment END -->
</div>
</body>
</html>
