<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<title>go_learn_note</title>
<!-- 2016-10-09 Sun 01:51 -->
<meta  http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta  name="generator" content="Org-mode" />
<meta  name="author" content="your name" />
<style type="text/css">
 <!--/*--><![CDATA[/*><!--*/
  .title  { text-align: center; }
  .todo   { font-family: monospace; color: red; }
  .done   { color: green; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #ccc;
    box-shadow: 3px 3px 3px #eee;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: visible;
    padding-top: 1.2em;
  }
  pre.src:before {
    display: none;
    position: absolute;
    background-color: white;
    top: -10px;
    right: 10px;
    padding: 3px;
    border: 1px solid black;
  }
  pre.src:hover:before { display: inline;}
  pre.src-sh:before    { content: 'sh'; }
  pre.src-bash:before  { content: 'sh'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-R:before     { content: 'R'; }
  pre.src-perl:before  { content: 'Perl'; }
  pre.src-java:before  { content: 'Java'; }
  pre.src-sql:before   { content: 'SQL'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.right  { text-align: center;  }
  th.left   { text-align: center;   }
  th.center { text-align: center; }
  td.right  { text-align: right;  }
  td.left   { text-align: left;   }
  td.center { text-align: center; }
  dt { font-weight: bold; }
  .footpara:nth-child(2) { display: inline; }
  .footpara { display: block; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  /*]]>*/-->
</style>

         <link href="http://fonts.googleapis.com/css?family=Droid+Sans+Mono|Galdeano|Open+Sans:600italic,400,600|Roboto+Condensed:400,700" rel="stylesheet" type="text/css">
         <link rel="stylesheet" type="text/css" href="/static/css/main.css"/>
<script type="text/javascript">
/*
@licstart  The following is the entire license notice for the
JavaScript code in this tag.

Copyright (C) 2012-2013 Free Software Foundation, Inc.

The JavaScript code in this tag is free software: you can
redistribute it and/or modify it under the terms of the GNU
General Public License (GNU GPL) as published by the Free Software
Foundation, either version 3 of the License, or (at your option)
any later version.  The code is distributed WITHOUT ANY WARRANTY;
without even the implied warranty of MERCHANTABILITY or FITNESS
FOR A PARTICULAR PURPOSE.  See the GNU GPL for more details.

As additional permission under GNU GPL version 3 section 7, you
may distribute non-source (e.g., minimized or compacted) forms of
that code without the copy of the GNU GPL normally required by
section 4, provided you include this license notice and a URL
through which recipients can access the Corresponding Source.


@licend  The above is the entire license notice
for the JavaScript code in this tag.
*/
<!--/*--><![CDATA[/*><!--*/
 function CodeHighlightOn(elem, id)
 {
   var target = document.getElementById(id);
   if(null != target) {
     elem.cacheClassElem = elem.className;
     elem.cacheClassTarget = target.className;
     target.className = "code-highlighted";
     elem.className   = "code-highlighted";
   }
 }
 function CodeHighlightOff(elem, id)
 {
   var target = document.getElementById(id);
   if(elem.cacheClassElem)
     elem.className = elem.cacheClassElem;
   if(elem.cacheClassTarget)
     target.className = elem.cacheClassTarget;
 }
/*]]>*///-->
</script>
</head>
<body>
<div id="org-div-home-and-up">
 <a accesskey="h" href="http://harrifeng.github.io/sitemap.html"> UP </a>
 |
 <a accesskey="H" href="http://harrifeng.github.io/index.html"> HOME </a>
</div><div id="preamble" class="status">

         <div id="header">
            <div id="header-top">
                <div id="blog-title">Harrifeng's Path</div>
                <div id="blog-sub-title">纸上得来终觉浅,绝知此事要Coding</div>
            </div>
            <div id="nav">
                <ul>
                    <li><a href="/">首页</a></li>
                    <li><a href="/about.html">About Me</a></li>
                    <li>
                    </li>
                </ul>
            </div>
         </div>
</div>
<div id="content">
<h1 class="title">go_learn_note</h1>
<div id="table-of-contents">
<h2>Table of Contents</h2>
<div id="text-table-of-contents">
<ul>
<li><a href="#sec-1">第一章 类型</a>
<ul>
<li><a href="#sec-1-1">变量</a></li>
<li><a href="#sec-1-2">常量</a></li>
<li><a href="#sec-1-3">基本类型</a></li>
<li><a href="#sec-1-4">引用类型</a></li>
<li><a href="#sec-1-5">类型转换</a></li>
<li><a href="#sec-1-6">字符串</a></li>
<li><a href="#sec-1-7">指针</a></li>
<li><a href="#sec-1-8">自定义类型</a></li>
</ul>
</li>
<li><a href="#sec-2">第二章 表达式</a>
<ul>
<li><a href="#sec-2-1">保留字</a></li>
<li><a href="#sec-2-2">运算符</a></li>
<li><a href="#sec-2-3">初始化</a></li>
<li><a href="#sec-2-4">控制流</a>
<ul>
<li><a href="#sec-2-4-1">if</a></li>
<li><a href="#sec-2-4-2">for (while)</a></li>
<li><a href="#sec-2-4-3">range</a></li>
<li><a href="#sec-2-4-4">switch</a></li>
<li><a href="#sec-2-4-5">goto, break, continue</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-3">第三章 函数</a>
<ul>
<li><a href="#sec-3-1">函数定义</a></li>
<li><a href="#sec-3-2">变参类型</a></li>
<li><a href="#sec-3-3">返回值</a></li>
<li><a href="#sec-3-4">匿名函数</a></li>
<li><a href="#sec-3-5">延迟调用</a></li>
<li><a href="#sec-3-6">错误处理</a></li>
</ul>
</li>
<li><a href="#sec-4">第四章 数据</a>
<ul>
<li><a href="#sec-4-1">Array</a></li>
<li><a href="#sec-4-2">Slice</a>
<ul>
<li><a href="#sec-4-2-1">reslice</a></li>
<li><a href="#sec-4-2-2">append</a></li>
<li><a href="#sec-4-2-3">copy</a></li>
</ul>
</li>
<li><a href="#sec-4-3">Map</a></li>
<li><a href="#sec-4-4">Struct</a>
<ul>
<li><a href="#sec-4-4-1">匿名字段</a></li>
<li><a href="#sec-4-4-2">面向对象</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#sec-5">第五章 方法</a>
<ul>
<li><a href="#sec-5-1">方法定义</a></li>
<li><a href="#sec-5-2">匿名字段</a></li>
<li><a href="#sec-5-3">方法集</a></li>
<li><a href="#sec-5-4">表达式</a></li>
</ul>
</li>
<li><a href="#sec-6">第六章 接口</a>
<ul>
<li><a href="#sec-6-1">接口定义</a></li>
<li><a href="#sec-6-2">执行机制</a></li>
<li><a href="#sec-6-3">接口转换</a></li>
<li><a href="#sec-6-4">接口检查</a></li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1" class="outline-2">
<h2 id="sec-1">第一章 类型</h2>
<div class="outline-text-2" id="text-1">
</div><div id="outline-container-sec-1-1" class="outline-3">
<h3 id="sec-1-1">变量</h3>
<div class="outline-text-3" id="text-1-1">
<ul class="org-ul">
<li>Go是静态类型语言,不能在运行期改变变量的类型
</li>
<li>在函数外,使用var来定义变量,初始值为0;如果提供初始化值,可省略变量类型,由编译
器自动推导
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

var globalX int
var globalY = "abc"

func main() {
    fmt.Println(globalX)
    fmt.Println(globalY)
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// 0                                              //
// abc                                            //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>在函数内部,还可以使用`:=`初始化,需要注意是新创建的local变量,还是更改了global
变量!
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

var globalX int

func main() {
    localX := 123
    fmt.Println(globalX)
    fmt.Println(localX)
    // Be careful! `:=` can also change the global value
    globalX := 456
    fmt.Println(globalX)

    // Error !You can not REDEFINE one variable
    // localX := 789
    // But of cause, you can change it value
    localX = 987
    fmt.Println(localX)
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// 0                                              //
// 123                                            //
// 456                                            //
// 987                                            //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>定义多个变量的方式有如下几种
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

var x, y, z int
var s, n = "abc", 123

var (
    a int
    b float32
)

func main() {
    n, s := 0x1234, "Hello, World!"
    fmt.Println(x, s, n)
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// 0 Hello, World! 4660                           //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>多变量赋值是先计算相关值,然后从左到右依次赋值
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    data, i := [3]int{0, 1, 2}, 0
    fmt.Println(i)
    fmt.Println(data)

    // When assigning multiple values in one line
    // You should:
    // [1] make sure all the value: (i =&gt; 0) and (data[i] =&gt; data[0])
    // [2] assign value base on [1]: i = 2, data[0] = 100
    i, data[i] = 2, 100
    fmt.Println(i)
    fmt.Println(data)
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// 0                                              //
// [0 1 2]                                        //
// 2                                              //
// [100 1 2]                                      //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>"_"是特殊变量,用户忽略占位符
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func test() (int, string) {
    return 1, "abc"
}

func main() {
    _, s := test()
    fmt.Println(s)
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// o                                              //
// abc                                            //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>"_"的占位符作用还可以体现在规避'编译器认为没使用的局部变量是error'
<div class="org-src-container">

<pre class="src src-go">var s string  // global variable unused is OK

func main() {
    // Error ! =&gt; i declared and not used
    i := 0
    // use following to block previous error
    // _ = i
}
</pre>
</div>
</li>
<li>前面介绍过,一个变量是无法重定义(redefine)的,但是两个变量却可以重定义!这个是
go特别的地方:
<ul class="org-ul">
<li>可以在同一个block里面重定义已定义的变量(但是要两个变量一块的情况):这个也是
可以理解的,这是由go的特性决定的.比如下面的例子,我们s已经定义了,我们想再定义
一个y,而且两个定义写到一句里面(其实函数返回两个值就是这种情况).你不能苛求
我定义y的时候,能把s的值也写对啊,所以s就可以redefine了!
<div class="org-src-container">

<pre class="src src-go">s := "abc"
// same level, can redefine if define two variable at once
s, y := "hello", 20
</pre>
</div>
</li>
<li>不同的block里面的就不存在所谓的"重定义"了,因为即便是变量名相同,也其实是两个
不同的变量了
</li>
</ul>
</li>
<li>重定义例子如下
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    s := "abc"
    fmt.Println(&amp;s)

    s, y := "hello", 20
    fmt.Println(&amp;s, y)

    {
        s, z := 1000, 30
        fmt.Println(&amp;s, z)
    }
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// 0x82023e080                                    //
// 0x82023e080 20                                 //
// 0x82023e0b0 30                                 //
////////////////////////////////////////////////////
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-2" class="outline-3">
<h3 id="sec-1-2">常量</h3>
<div class="outline-text-3" id="text-1-2">
<ul class="org-ul">
<li>常亮必须是编译期可以确定的数字,字符串,布尔值
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

const x, y int = 1, 2
const s = "Hello, World!"

const (
    a, b      = 10, 100
    c    bool = false
)

func main() {
    // one day const, always const
    const x = "xxx"

    // only x is used
    // unused const variable will not incur Error
    fmt.Println(x)
}
</pre>
</div>
</li>
<li>常量还可以是len, cap, unsafe.Sizeof等编译器可确定结果的函数返回值
<div class="org-src-container">

<pre class="src src-go">package main

import (
    "fmt"
    "unsafe"
)

func main() {
    const (
        a = "abc"
        b = len(a)
        c = unsafe.Sizeof(b)
    )
    fmt.Println(a, b, c)
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// abc 3 8                                        //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>常量和iota是好朋友,iota能够提供"自增枚举值":
<ul class="org-ul">
<li>提供从0开始的自增枚举值是最简单的
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    const (
        Sunday = iota
        Monday
        Tuesday
        Wednesday
        Thursday
        Friday
        Saturday
    )

    fmt.Println(Sunday, Monday, Tuesday, Wednesday, Thursday, Friday, Saturday)
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// 0 1 2 3 4 5 6                                  //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>当前行的规则和"前面一行"的规则相同. 所以MB也是 1 &lt;&lt; (10 * iota) 只不过iota是2了
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    const (
        _        = iota             // itoa = 0
        KB int64 = 1 &lt;&lt; (10 * iota) // itoa = 1
        MB                          // Same with KB, but itoa = 2 here
        GB
        TB
    )
    fmt.Println(KB, MB, GB, TB)
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// 1024 1048576 1073741824 1099511627776          //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>还可以在一组赋值中,多次使用iota
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    const (
        A, B = iota, iota &lt;&lt; 10
        C, D
    )

    fmt.Println(A, B, C, D)
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// 0 0 1 1024                                     //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>如果iota的自增被打断,需要"显示"恢复,所谓显示,就是再输入一次iota
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    const (
        A = iota
        B
        C = "c"
        D        // same with previous
        E = iota // return to interrupted increasing number
        F
    )
    fmt.Println(A, B, C, D, E, F)
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// 0 1 c c 4 5                                    //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>如果想让函数的参数"只有枚举类型和常量"可以访问,而普通变量无法轻易的作为函
数参数,那么可以使用"枚举+自定义类型"的方式
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

type Color int

const (
    Black Color = iota
    Red
    Blue
)

func test(c Color) {
    fmt.Println("Color number is ", c)
}

func main() {
    c := Black
    test(c)

    // Const is auto convert
    test(1)

    x := 1
    _ = x
    // Error! can not use x (type int) as type Color in function argument
    // test(x)
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// Color number is  0                             //
// Color number is  1                             //
////////////////////////////////////////////////////
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-3" class="outline-3">
<h3 id="sec-1-3">基本类型</h3>
<div class="outline-text-3" id="text-1-3">
<ul class="org-ul">
<li>go的类型更加明确,支持Unicode,支持常用数据结构,简单的几个类型如下
<table border="2" cellspacing="0" cellpadding="6" rules="all" frame="border">


<colgroup>
<col  class="left" />

<col  class="right" />

<col  class="right" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">Type</th>
<th scope="col" class="right">Length</th>
<th scope="col" class="right">Default</th>
<th scope="col" class="left">Range</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">bool</td>
<td class="right">1</td>
<td class="right">false</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">byte</td>
<td class="right">1</td>
<td class="right">0</td>
<td class="left">unit8</td>
</tr>

<tr>
<td class="left">rune</td>
<td class="right">4</td>
<td class="right">0</td>
<td class="left">Unicode Code Point, int32</td>
</tr>

<tr>
<td class="left">int,uint</td>
<td class="right">4 or 8</td>
<td class="right">0</td>
<td class="left">32bit or 64bit</td>
</tr>

<tr>
<td class="left">float32</td>
<td class="right">4</td>
<td class="right">0.0</td>
<td class="left">&#xa0;</td>
</tr>

<tr>
<td class="left">float64</td>
<td class="right">8</td>
<td class="right">0.0</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-4" class="outline-3">
<h3 id="sec-1-4">引用类型</h3>
<div class="outline-text-3" id="text-1-4">
<ul class="org-ul">
<li>引用类型(reference type)包括slice, map和channel.它们有复杂的内部结构使用的
时候需要:
<ul class="org-ul">
<li>申请内存
</li>
<li>初始化相关属性
</li>
</ul>
</li>
<li>内置函数new计算类型大小,为期分配零值内存,返回指针.而make是分配内存,初始化成
员列表,返回对象而非指针
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    a := []int{0, 0, 0}
    a[1] = 10

    fmt.Println(a)

    // make return object
    b := make([]int, 3)
    b[1] = 10

    fmt.Println(b)

    // new return the pointer
    c := new([]int)
    fmt.Println(*c)
}
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-5" class="outline-3">
<h3 id="sec-1-5">类型转换</h3>
<div class="outline-text-3" id="text-1-5">
<ul class="org-ul">
<li>不支持隐式类型转换,即便是从窄转向宽也不行
<div class="org-src-container">

<pre class="src src-go">var b byte = 100
// var n int = b // Error: implicit convertation is not supported
var n int = int(b)              // ok for explicit convertation
</pre>
</div>
</li>
<li>同样不能将其他类型当成bool值使用
<div class="org-src-container">

<pre class="src src-go">a := 100
// Error: non-bool a (type int) used as if condition
if a {
    //
}
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-6" class="outline-3">
<h3 id="sec-1-6">字符串</h3>
<div class="outline-text-3" id="text-1-6">
<ul class="org-ul">
<li>字符串是immutable类型,内部指针指向UTF-8字节数组:
<ul class="org-ul">
<li>默认值是空字符串""
</li>
<li>用索引号访问某个字节,如s[i]
</li>
<li>不能用序列号获取字节元素指针,&amp;s[i]非法
</li>
<li>不可变类型,无法修改字节数组
</li>
<li>字节数组尾部不包含NULL
</li>
</ul>
</li>
<li>使用索引号访问字符(byte)
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    s := "abc"
    fmt.Println(s[0] == '\x61', s[1] == 'b', s[2] == 0x63)
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// true true true                                 //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>使用"`"定义不做转义处理的原始字符串,支持跨行
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    s := `a
b\r\n\x00
c`

    fmt.Println(s)
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// a                                              //
// b\r\n\x00                                      //
// c                                              //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>连接字符串时, "+"必须在上一行的末尾
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    // '+' should be at the tail of the line
    s := "Hello, " +
        "World!"
    fmt.Println(s)
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// Hello, World!                                  //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>支持用两个索引号返回子串，子串依然指向原字节数组
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    s := "Hello, World!"

    fmt.Println(s[:5])
    fmt.Println(s[7:])
    fmt.Println(s[1:5])
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// Hello                                          //
// World!                                         //
// ello                                           //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>单引号字符常量表示Unicode Code Point
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    fmt.Printf("%T\n", 'a')

    var c1, c2 rune = '\u6211', '们'
    fmt.Println(c1 == '我', string(c2) == "\xe4\xbb\xac")
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// int32                                          //
// true true                                      //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>要修改字符串，可以先将其转换成[]rune或者[]byte，完成后再转换成为string，无论
哪种转换，都会重新分配内存，并复制字节数组
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    s := "abcd"
    bs := []byte(s)

    bs[1] = 'B'
    fmt.Println(string(bs))

    u := "电脑"
    us := []rune(u)
    us[1] = '话'
    fmt.Println(string(us))
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// aBcd                                           //
// 电话                                           //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>for 循环遍历也会使用byte和rune两种方式
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    s := "abc汉字"

    for i := 0; i &lt; len(s); i++ {
        fmt.Printf("%c, ", s[i])
    }

    fmt.Println()

    for _, r := range s {
        fmt.Printf("%c,", r)
    }
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// a, b, c, æ, ±, , å, ­, ,               //
// a,b,c,汉,字,                                   //
////////////////////////////////////////////////////
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-7" class="outline-3">
<h3 id="sec-1-7">指针</h3>
<div class="outline-text-3" id="text-1-7">
<ul class="org-ul">
<li>支持指针类型*T, 指针的指针**T, 以及包含包名前缀的*&lt;package&gt;.T
</li>
<li>go的指针的特点有如下:
<ul class="org-ul">
<li>默认值nil，没有NULL常量
</li>
<li>操作符"&amp;"取变量地址, "*"透过指针访问目标对象
</li>
<li>不支持指针运算，不支持"-&gt;"运算符，直接使用"."访问目标成员
</li>
</ul>
</li>
<li>例子如下
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    type data struct{ a int }

    var d = data{1234}
    var p *data

    p = &amp;d

    fmt.Printf("%p, %v\n", p, p.a)
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// 0xc082008310, 1234                             //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>不能对指针做加减法等运算
<div class="org-src-container">

<pre class="src src-go">x := 1234
p := &amp;x
p++
</pre>
</div>
</li>
<li>可以在unsafe.Pointer和任意类型指针间进行转换
<div class="org-src-container">

<pre class="src src-go">package main

import (
    "fmt"
    "unsafe"
)

func main() {
    x := 0x12345678

    p := unsafe.Pointer(&amp;x)
    n := (*[4]byte)(p)

    for i := 0; i &lt; len(n); i++ {
        fmt.Printf("%X ", n[i])
    }
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// 78 56 34 12                                    //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>返回局部变量指针是安全的，编译器会根据需要将其分配在GC heap上
<div class="org-src-container">

<pre class="src src-go">func test() *int {
    x := 100
    return &amp;x
}
</pre>
</div>
</li>
<li>将Point而转换成uintptr，可变相实现指针运算
<div class="org-src-container">

<pre class="src src-go">package main

import (
    "fmt"
    "unsafe"
)

func main() {
    d := struct {
        s string
        x int
    }{"abc", 100}

    p := uintptr(unsafe.Pointer(&amp;d))
    p += unsafe.Offsetof(d.x)
    p2 := unsafe.Pointer(p)
    px := (*int)(p2)
    *px = 200

    fmt.Printf("%#v\n", d)
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// struct { s string; x int }{s:"abc", x:200}     //
////////////////////////////////////////////////////
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-1-8" class="outline-3">
<h3 id="sec-1-8">自定义类型</h3>
<div class="outline-text-3" id="text-1-8">
<ul class="org-ul">
<li>类型其实可以分成两大类：
<ul class="org-ul">
<li>命名类型，包括bool, int, string
</li>
<li>未命名类型，包括array, slice, map
</li>
</ul>
</li>
<li>具有相同声明的未命名类型被视为同一类型,比如：
<ul class="org-ul">
<li>具有相同基类型的指针
</li>
<li>具有相同元素类型和长度的array
</li>
<li>具有相同元素类型的slice
</li>
<li>具有相同键值类型的map
</li>
<li>具有相同元素类型和传输方向的channel
</li>
<li>具有相同字段序列(字段名，类型，标签，顺序）的匿名struct
</li>
<li>签名相同（参数和返回值，不包括参数名称）的function
</li>
<li>方法集相同(方法名，方法签名相同，和次序无关）的interface
</li>
</ul>
</li>
<li>a和b就不被认为是相同类型（不可以相互赋值）
<div class="org-src-container">

<pre class="src src-go">package main

func main() {

    var a struct {
        x int `a`
    }
    var b struct {
        x int `ab`
    }

    _ = a
    _ = b
    // Error! cannot use a (type struct { x int "a" })
    //as type struct { x int "ab" } in assignment
    // b = a
}
</pre>
</div>
</li>
<li>可用type在全局或函数内定义新类型
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    type bigint int64

    var x bigint = 100

    fmt.Println(x)
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// 100                                            //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>新类型不是原类型的别名，除拥有相同的数据类型结构外，它们之间没有任何关系，不
会持有原类型任何信息。除非目标类型是未命名类型，否则必须显示转换
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    x := 1234
    type bigint int64
    var b bigint = bigint(x)
    var b2 int64 = int64(b)

    type myslice []int
    var s myslice = []int{1, 2, 3}
    var s2 []int = s

    fmt.Println(b2)
    fmt.Println(s2)
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// 1234                                           //
// [1 2 3]                                        //
////////////////////////////////////////////////////
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-2" class="outline-2">
<h2 id="sec-2">第二章 表达式</h2>
<div class="outline-text-2" id="text-2">
</div><div id="outline-container-sec-2-1" class="outline-3">
<h3 id="sec-2-1">保留字</h3>
<div class="outline-text-3" id="text-2-1">
<ul class="org-ul">
<li>所有保留字如下
<div class="org-src-container">

<pre class="src src-go">break        default        func
case         defer          go
chan         else           goto
const        fallthrough    if
continue     for            import
interface      select
map            struct
package        switch
range          type
return         var
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-2" class="outline-3">
<h3 id="sec-2-2">运算符</h3>
<div class="outline-text-3" id="text-2-2">
<ul class="org-ul">
<li>几个常规的运算符.需要特别注意x$^y,其意义是把x中的某些bit上的值,值为零(无论
原来是1是0), 至于哪些位置y中所有为1,是由y中有哪些位置为1来决定的
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    a := 0x011
    b := 0x101
    fmt.println(a &amp; b)
    fmt.println(0x0001)

    fmt.println(a | b)
    fmt.println(0x0111)

    fmt.println(a ^ b)
    fmt.println(0x0110)

    // clear 1 to 0 on 0th and 3th from 0x101 for 0x011
    fmt.println(a &amp;^ b)
    fmt.println(0x010)
}

////////////////////////////////////////////////////
// &lt;===================output===================&gt; //
// 1                                              //
// 1                                              //
// 273                                            //
// 273                                            //
// 272                                            //
// 272                                            //
// 16                                             //
// 16                                             //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>不支持运算符重载
</li>
<li>尤其要注意的是"++", "&#x2013;"是语句而非表达式,这样做的原因,是为了防止一些低级错误
<div class="org-src-container">

<pre class="src src-go">n := 0
p := &amp;n
// b := n++                     // syntax error
// if n++ == 1 {}               // syntax error
// ++n                          // syntax error

n++
*p++                            // (*p)++
</pre>
</div>
</li>
<li>没有"~",取反也用"^"
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    x := 1
    fmt.println(x)
    fmt.println(^x)
}

////////////////////////////////////////////////////
// &lt;===================output===================&gt; //
// 1                                              //
// -2                                             //
////////////////////////////////////////////////////
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-3" class="outline-3">
<h3 id="sec-2-3">初始化</h3>
<div class="outline-text-3" id="text-2-3">
<ul class="org-ul">
<li>初始化复合类型,必须使用type,左括号必须在类型的尾部,而不是另起一行
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    a := struct{ x int }{100}
    b := []int{1, 2, 3}

    fmt.println(a)
    fmt.println(b)
}

////////////////////////////////////////////////////
// &lt;===================output===================&gt; //
// {100}                                          //
// [1 2 3]                                        //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>初始化以','分割,可以分几行,但是最后一行必须是以','或者'}'结尾,这里可以放心
因为gofmt会帮助你.
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4" class="outline-3">
<h3 id="sec-2-4">控制流</h3>
<div class="outline-text-3" id="text-2-4">
</div><div id="outline-container-sec-2-4-1" class="outline-4">
<h4 id="sec-2-4-1">if</h4>
<div class="outline-text-4" id="text-2-4-1">
<ul class="org-ul">
<li>if的写法和c有如下区别:
<ul class="org-ul">
<li>条件表达式括号省略了
</li>
<li>可以定义局部变量
</li>
<li>左括号必须在最后
</li>
</ul>
</li>
<li>注意!不支持三元操作符 "a &gt; b ? a : b"
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4-2" class="outline-4">
<h4 id="sec-2-4-2">for (while)</h4>
<div class="outline-text-4" id="text-2-4-2">
<ul class="org-ul">
<li>go中只有for,没有while:
<ul class="org-ul">
<li>常见的for循环,各种语言都有
<div class="org-src-container">

<pre class="src src-go">s := "abc"

for i, n := 0, len(s); i &lt; n; i++ {
    fmt.println(s[i])
}
</pre>
</div>
</li>
<li>替代while (n &gt; 0)
<div class="org-src-container">

<pre class="src src-go">n := len(s)
for n &gt; 0 {
    fmt.println(s[n])
    n--
}
</pre>
</div>
</li>
<li>替代while(true)
<div class="org-src-container">

<pre class="src src-go">for {
    fmt.println(s)
}
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4-3" class="outline-4">
<h4 id="sec-2-4-3">range</h4>
<div class="outline-text-4" id="text-2-4-3">
<ul class="org-ul">
<li>range操作的核心是返回(key,value), (key, value)并不是只有map有,其他的几种类
型如果能使用range的话,也有其`key`和`value`
<table border="2" cellspacing="0" cellpadding="6" rules="all" frame="border">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">&#xa0;</th>
<th scope="col" class="left">1st value (key)</th>
<th scope="col" class="left">2nd value(value)</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">string</td>
<td class="left">index</td>
<td class="left">s[index]</td>
</tr>

<tr>
<td class="left">array/slice</td>
<td class="left">index</td>
<td class="left">s[index]</td>
</tr>

<tr>
<td class="left">map</td>
<td class="left">key</td>
<td class="left">value</td>
</tr>

<tr>
<td class="left">channel</td>
<td class="left">element</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>
</li>
<li>range的使用方法如下, 不想使用的部分使用`_`
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    // string/array/slice they are the same
    s := "abc"
    for i, j := range s {
        fmt.printf("%d  %c\n", i, j)
    }

    for _, c := range s {
        fmt.println(c)
    }

    //map
    m := map[string]int{"a": 1, "b": 2}
    for k, v := range m {
        fmt.println(k, v)
    }
}

////////////////////////////////////////////////////
// &lt;===================output===================&gt; //
// 0  a                                           //
// 1  b                                           //
// 2  c                                           //
// 97                                             //
// 98                                             //
// 99                                             //
// a 1                                            //
// b 2                                            //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>range会涉及到"值拷贝",也就是说:
<ul class="org-ul">
<li>如果range所处理的类型是值, 那么key, value返回的都是copy value,典型的例子
就是array,下面的例子中`a`虽然已经开始被置为999,但是因为其"原始值"1已经
在range调用那一刻被拷贝出来了,所以a= v + 100的时候, v还是1
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    // array is not reference type, everytime range will
    // copy the value to i and v
    a := [3]int{0, 1, 2}
    for i, v := range a {
        if i == 0 {
            a[1], a[2] = 999, 999
            fmt.println(a) // change a's value succesfully
        }
        a[i] = v + 100 // use a's copied value to construct the final version

    }
    fmt.println(a)
}

////////////////////////////////////////////////////
// &lt;===================output===================&gt; //
// [0 999 999]                                    //
// [100 101 102]                                  //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>所以我们最好让range处理引用类型的容器,array的好基友slice就是引用类型的
"数组", 下面的例子中
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    // slice here is reference type, no copy happened when ranging
    s := []int{1, 2, 3, 4, 5}

    for i, v := range s {
        if i == 0 {
            // change s's size will not deduced the iteration times
            s = s[:3]
            s[2] = 100
        }

        fmt.println(i, v) // s[2] will changed
    }
    fmt.println(s) // s[2] will changed
}

////////////////////////////////////////////////////
// &lt;===================output===================&gt; //
// 0 1                                            //
// 1 2                                            //
// 2 100                                          //
// 3 4                                            //
// 4 5                                            //
// [1 2 100]                                      //
////////////////////////////////////////////////////
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4-4" class="outline-4">
<h4 id="sec-2-4-4">switch</h4>
<div class="outline-text-4" id="text-2-4-4">
<ul class="org-ul">
<li>switch表达式可以是任意类型,不限于常量:
<ul class="org-ul">
<li>可以省略break,默认自动终止
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    x := []int{1, 2, 3}
    i := 2

    switch i {
    case x[1]:
        fmt.println("a")
    case 1, 3:
        fmt.println("b")
    default:
        fmt.println("c")
    }
}

////////////////////////////////////////////////////
// &lt;===================output===================&gt; //
// a                                              //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>可以继续下一个(不是全部)分支,使用fallthrough, 但是条件不再判断(也就是自
动运行下一个分支)
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    x := 10
    switch x {
    case 10:
        fmt.println("a")
        fallthrough
    case 0:
        fmt.println("b")
    case -1:
        fmt.println("c")
    }
}

////////////////////////////////////////////////////
// &lt;===================output===================&gt; //
// a                                              //
// b                                              //
////////////////////////////////////////////////////
</pre>
</div>
</li>
</ul>
</li>
<li>switch省略条件表达式,或者把条件表达式作为初始化条件,可以把switch作为if
elseif else来用
<div class="org-src-container">

<pre class="src src-go">switch {
case x[1] &gt; 0:
    fmt.println("a")
case x[1] &lt; 0:
    fmt.println("b")
default:
    fmt.println("c")
}
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-2-4-5" class="outline-4">
<h4 id="sec-2-4-5">goto, break, continue</h4>
<div class="outline-text-4" id="text-2-4-5">
<ul class="org-ul">
<li>goto和c里面差不多,只不过标签必须使用大写
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {

    var i int
    for {
        fmt.println(i)
        i++
        if i &gt; 2 {
            goto break
        }
    }
break:
    fmt.println("break")
}

////////////////////////////////////////////////////
// &lt;===================output===================&gt; //
// 0                                              //
// 1                                              //
// 2                                              //
// break                                          //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>break用于在for, switch, select里面跳出当前循环, continue是进入下一次循环,
只能用于for循环
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-3" class="outline-2">
<h2 id="sec-3">第三章 函数</h2>
<div class="outline-text-2" id="text-3">
</div><div id="outline-container-sec-3-1" class="outline-3">
<h3 id="sec-3-1">函数定义</h3>
<div class="outline-text-3" id="text-3-1">
<ul class="org-ul">
<li>bgo首先去掉了几个不太实用的函数feature:
<ul class="org-ul">
<li>不支持嵌套(nested)
</li>
<li>不支持重载(overload)
</li>
<li>不支持默认参数(default parameter)
</li>
</ul>
</li>
<li>go函数有如下特点:
<ul class="org-ul">
<li>不需要声明原形
</li>
<li>支持不定长变参数
</li>
<li>支持多返回值
</li>
<li>支持命名返回参数
</li>
<li>支持匿名函数和闭包
</li>
</ul>
</li>
<li>使用func定义函数,格式你懂的
<div class="org-src-container">

<pre class="src src-go">func test(x, y int, s string) (int, string) {
    n := x + y
    return n, fmt.sprintf(s, n)
}
</pre>
</div>
</li>
<li>函数是first-class 对象.可以作为参数传递.可以使用type将复杂函数定义为函数类型
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func test(fn func() int) int {
    return fn()
}

type formatfunc func(s string, x, y int) string

func format(fn formatfunc, s string, x, y int) string {
    return fn(s, x, y)
}

func main() {
    s1 := test(func() int { return 100 })
    s2 := format(func(s string, x, y int) string {
        return fmt.sprintf(s, x, y)
    }, "%d, %d", 10, 20)

    fmt.println(s1)
    fmt.println(s2)
}

////////////////////////////////////////////////////
// &lt;===================output===================&gt; //
// 100                                            //
// 10, 20                                         //
////////////////////////////////////////////////////
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-2" class="outline-3">
<h3 id="sec-3-2">变参类型</h3>
<div class="outline-text-3" id="text-3-2">
<ul class="org-ul">
<li>变参其实就是最后一个参数是slice(只能有一个),而且使用slice变量作为参数的时候,
得写成'x&#x2026;'
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func test(s string, n ...int) string {
    var x int
    for _, i := range n {
        x += i
    }
    return fmt.sprintf(s, x)
}

func main() {

    fmt.println(test("sum: %d", 1, 2, 3))
    s := []int{1, 2, 3, 4, 5}
    fmt.println(test("sum: %d", s...))
}

////////////////////////////////////////////////////
// &lt;===================output===================&gt; //
// sum: 6                                         //
// sum: 15                                        //
////////////////////////////////////////////////////
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-3" class="outline-3">
<h3 id="sec-3-3">返回值</h3>
<div class="outline-text-3" id="text-3-3">
<ul class="org-ul">
<li>不能使用容器接收多返回值,只能使用多个变量.不像要的参数使用"_"忽略
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func test() (int, int) {
    return 1, 2
}

func main() {
    // error =&gt; multiple-value test() in single-value context
    // s := make([]int, 2)
    // s = test()
    x, _ := test()
    fmt.println(x)
}

////////////////////////////////////////////////////
// &lt;===================output===================&gt; //
// 1                                              //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>多返回值作为实参:
<ul class="org-ul">
<li>理所当然可以看成是slice,所以可以作为n&#x2026;类型的实参.
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func test() (int, int) {
    return 1, 2
}

func sum(n ...int) int {
    var x int

    for _, i := range n {
        x += i
    }

    return x
}

func main() {
    fmt.println(sum(test()))
}

////////////////////////////////////////////////////
// &lt;===================output===================&gt; //
// 3                                              //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>参数有x,y int类型的情况下,也可以使用多返回值作为实参
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func test() (int, int) {
    return 1, 2
}

func add(x, y int) int {
    return x + y
}

func main() {
    fmt.println(add(test()))
}

////////////////////////////////////////////////////
// &lt;===================output===================&gt; //
// 3                                              //
////////////////////////////////////////////////////
</pre>
</div>
</li>
</ul>
</li>
<li>如果返回值写"名字",那么就等同于设置了这个"名字"的局部变量,return后面啥都没
有的话,就是隐式返回.
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func add(x, y int) (z int) {
    z = x + y
    return
}

func main() {
    fmt.println(add(1, 2))
}

////////////////////////////////////////////////////
// &lt;===================output===================&gt; //
// 3                                              //
////////////////////////////////////////////////////
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-4" class="outline-3">
<h3 id="sec-3-4">匿名函数</h3>
<div class="outline-text-3" id="text-3-4">
<ul class="org-ul">
<li>匿名函数也是神通广大,可以:
<ul class="org-ul">
<li>赋值给变量:
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {

    fns := [](func(x int) int){
        func(x int) int { return x + 1 },
        func(x int) int { return x + 2 },
    }

    fmt.println(fns[0](100))
}

////////////////////////////////////////////////////
// &lt;===================output===================&gt; //
// 101                                            //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>作为结构字段:
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    d := struct {
        fn func() string
    }{
        fn: func() string { return "hello, world" },
    }

    fmt.println(d.fn())
}

////////////////////////////////////////////////////
// &lt;===================output===================&gt; //
// hello, world                                   //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>在channel里面传送:
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    fc := make(chan func() string, 2)
    fc &lt;- func() string { return "hello world" }
    fmt.println((&lt;-fc)())
}

////////////////////////////////////////////////////
// &lt;===================output===================&gt; //
// hello world                                    //
////////////////////////////////////////////////////
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-5" class="outline-3">
<h3 id="sec-3-5">延迟调用</h3>
<div class="outline-text-3" id="text-3-5">
<ul class="org-ul">
<li>关键字defer用于注册延迟调用,这些调用知道return之前才执行,通常用于释放资源或
错误处理
<div class="org-src-container">

<pre class="src src-go">package main

import (
    "fmt"
    "os"
)

func test() error {
    f, err := os.Create("test.txt")

    if err != nil {
        return err
    }

    defer f.Close()
    f.WriteString("Hello World")
    return nil
}

func main() {
    err := test()
    if err != nil {
        fmt.Println("Error")
    }
}
</pre>
</div>
</li>
<li>可以使用下面的方法"延迟读取"
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func test() {
    x, y := 10, 20

    // take x as parameter for anoymous function, saved x's value
    // as 10.
    defer func(i int) {
        fmt.Println("defer:", i, y)
    }(x)

    x += 10
    y += 100
    fmt.Println("x = ", x, "y = ", y)
}

func main() {
    test()
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// x =  20 y =  120                               //
// defer: 10 120                                  //
////////////////////////////////////////////////////
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-3-6" class="outline-3">
<h3 id="sec-3-6">错误处理</h3>
<div class="outline-text-3" id="text-3-6">
<ul class="org-ul">
<li>没有结构化异常, 使用panic抛出错误,然后使用recover捕获错误
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func test() {
    defer func() {
        if err := recover(); err != nil {
            fmt.Println(err.(string)) // err is interface{} type and now convert it to string
        }
    }()

    panic("panic error!")
}

func main() {
    test()
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// panic error!                                   //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>上面有err转化成string的部分,因为panic, recover的参数都是interface{}类型,因
此可以抛出任何类型的对象
<div class="org-src-container">

<pre class="src src-go">func panic(v interface{})
func recover() interface{}
</pre>
</div>
</li>
<li>延迟调用中引发的错误,可以被后续延迟调用捕获,但仅最后一个错误可以被捕获
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func test() {
    defer func() {
        fmt.Println(recover())
    }()

    defer func() {
        panic("defer panic")
    }()

    panic("test panic")
}

func main() {
    test()
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// defer panic                                    //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>捕获函数recover必须在两个地方:
<ul class="org-ul">
<li>匿名函数:
<div class="org-src-container">

<pre class="src src-go">package main

func test() {
    defer func() {
        recover()
    }()
    panic("test panic")
}

func main() {
    test()
}
</pre>
</div>
</li>
<li>函数体内才能起作用.
<div class="org-src-container">

<pre class="src src-go">package main

func except() {
    recover()
}

func test() {
    defer except()
    panic("test panic")
}

func main() {
    test()
}
</pre>
</div>
</li>
</ul>
</li>
<li>其他方式(不在函数里面,或者是两层函数),总是失败,recover()会返回nil
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func test() {
    defer recover()
    defer fmt.Println(recover())

    defer func() {
        func() {
            fmt.Println("defer inner")
            recover()
        }()
    }()

    panic("test panic")
}

func main() {
    test()
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// defer inner                                    //
// &lt;nil&gt;                                          //
// panic: test panic                              //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>除了使用panic引发中断性错误外,还可以使用error类型来返回错误,error类型其实是
一个接口,定义如下
<div class="org-src-container">

<pre class="src src-go">type error interface {
    Error() string
}
</pre>
</div>
</li>
<li>我们可以使用errors.New来创建一个error类型的instance,使用方法如下
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"
import "errors"

var ErrDivByZero = errors.New("hfeng: division by zero")

func div(x, y int) (int, error) {
    if y == 0 {
        return 0, ErrDivByZero
    }
    return x / y, nil
}

func main() {
    switch z, err := div(10, 0); err {
    case nil:
        fmt.Println(z)
    case ErrDivByZero:
        panic(err)
    }
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// panic: hfeng: division by zero                 //
////////////////////////////////////////////////////
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-4" class="outline-2">
<h2 id="sec-4">第四章 数据</h2>
<div class="outline-text-2" id="text-4">
</div><div id="outline-container-sec-4-1" class="outline-3">
<h3 id="sec-4-1">Array</h3>
<div class="outline-text-3" id="text-4-1">
<ul class="org-ul">
<li>数组和以往认知的数组有很大的不同:
<ul class="org-ul">
<li>数组是值类型,赋值和传参数会复制整个数组,而不是指针(所以有时候传递数组给函
数的话,代价很大)
</li>
<li>数组长度必须是常量,且是类型的组成部分.int和int是不同类型
</li>
<li>支持"==", "!="操作符
</li>
<li>支持数组[n]*T, 数组指针*[n]T (这里看出类型在后的好处了)
</li>
</ul>
</li>
<li>和c语言相比,go的数组初始化方法非常的多样化
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    a := [3]int{1, 2}
    b := [...]int{1, 2, 3, 4}
    c := [5]int{2: 100, 4: 200}

    d := [...]struct {
        name string
        age  uint8
    }{
        {"user1", 10},
        {"user2", 20},
    }

    fmt.Println(a)
    fmt.Println(b)
    fmt.Println(c)
    fmt.Println(d)
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// [1 2 0]                                        //
// [1 2 3 4]                                      //
// [0 0 100 0 200]                                //
// [{user1 10} {user2 20}]                        //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>多维数组初始化方法如下, 需要注意的是,只支持第一维度的设置为"&#x2026;"
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    a := [2][3]int{{1, 2, 3}, {4, 5, 6}}
    b := [...][2]int{{1, 1}, {2, 2}, {3, 3}}

    fmt.Println(a)
    fmt.Println(b)
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// [[1 2 3] [4 5 6]]                              //
// [[1 1] [2 2] [3 3]]                            //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>值拷贝行为会造成性能的下降,因为会复制整个数组
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func test(x [2]int) {
    fmt.Printf("x: %p\n", &amp;x)
    x[1] = 1000
}

func main() {
    a := [2]int{}
    fmt.Printf("a: %p\n", &amp;a)

    test(a)
    fmt.Println(a)
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// a: 0xc082008310                                //
// x: 0xc082008350                                //
// [0 0]                                          //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>内置的len和cap对于数组来说都是返回数组长度(元素数量),因为不可能有空间而不放
数据
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    a := [2]int{}
    fmt.Println(len(a), cap(a))
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// 2 2                                            //
////////////////////////////////////////////////////
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-2" class="outline-3">
<h3 id="sec-4-2">Slice</h3>
<div class="outline-text-3" id="text-4-2">
<ul class="org-ul">
<li>slice是go语言对于array的一种补充,因为array是值传递的,为了减少值传递作为参数
等情况下带来的性能问题,go特地发明了array的引用类型"替身"&#x2013;slice
</li>
<li>slice在go的源代码里面其实就是1指针数组2长度3容量的一个组合
<div class="org-src-container">

<pre class="src src-c">struct Slice
{
    byte* array;
    uintgo len;
    uintgo cap;
};
</pre>
</div>
</li>
<li>我们通过下面一个例子来看看slice和其"被绑定"数组的关系:
<ul class="org-ul">
<li>先看源代码:
<div class="org-src-container">

<pre class="src src-go">data := [...]int{0, 1, 2, 3, 4, 5, 6}
slice := data[1:4:5]            // [low:high:max]
</pre>
</div>
</li>
<li>再来看看两者的关系(图例)
<pre class="example">
              +- low   high -+    +- max                                   len = high - low
              |              |    |                                        cap = max  - low
      +---+---+---+---+---+---+---+           +---------+---------+---------+
data  | 0 | 1 | 2 | 3 | 4 | 5 | 6 |    slice  | pointer | len = 3 | cap = 4 |
      +---+---+---+---+---+---+---+           +---------+---------+---------+
              |&lt;--- len ----&gt;|    |                              |
              |                   |                              |
              |&lt;----- cap -------&gt;|                              |
              |                                                  |
              +-------&lt;&lt;&lt;-------- slice.array pointer ---&lt;&lt;&lt;-----+
</pre>
</li>
</ul>
</li>
<li>使用[low:high:max]方法从已有数组创建slice的情况,不一定每次都全面的提供low,
high, max.使用默认值的情况总计如下:
<ul class="org-ul">
<li>代码
<div class="org-src-container">

<pre class="src src-go">data := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
</pre>
</div>
</li>
<li>从data创建slice的各种默认值组合
<table border="2" cellspacing="0" cellpadding="6" rules="all" frame="border">


<colgroup>
<col  class="left" />

<col  class="left" />

<col  class="right" />

<col  class="right" />

<col  class="left" />
</colgroup>
<thead>
<tr>
<th scope="col" class="left">expression</th>
<th scope="col" class="left">slice</th>
<th scope="col" class="right">len</th>
<th scope="col" class="right">cap</th>
<th scope="col" class="left">comment</th>
</tr>
</thead>
<tbody>
<tr>
<td class="left">data[:6:8]</td>
<td class="left">[0 1 2 3 4 5]</td>
<td class="right">6</td>
<td class="right">8</td>
<td class="left">low is array's low</td>
</tr>

<tr>
<td class="left">data[5:]</td>
<td class="left">[5 6 7 8 9]</td>
<td class="right">5</td>
<td class="right">5</td>
<td class="left">high is array's high, max is array{low, high}</td>
</tr>

<tr>
<td class="left">data[:3]</td>
<td class="left">[0 1 2]</td>
<td class="right">3</td>
<td class="right">10</td>
<td class="left">low is array's low, max is array{low, high}</td>
</tr>

<tr>
<td class="left">data[:]</td>
<td class="left">[0 1 2 3 4 5 6 7 8 9]</td>
<td class="right">10</td>
<td class="right">10</td>
<td class="left">&#xa0;</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>如果slice是从某个数组创建的话,那么对于slice的读写操作其实就是对于底层数组的
读写
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    data := [...]int{0, 1, 2, 3, 4, 5}

    s := data[2:4]
    s[0] += 100
    s[1] += 200

    fmt.Println(s)
    fmt.Println(data)
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// [102 203]                                      //
// [0 1 102 203 4 5]                              //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>slice如果创建的时候还要带个拖油瓶的"数组"那用起来太麻烦了,go还是可以"直接创
建"slice的
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    s1 := []int{0, 1, 2, 3, 8: 100} // Note! there are nothing in []
    fmt.Println(s1, len(s1), cap(s1))

    s2 := make([]int, 6, 8) // make to create, len and cap as parameter
    fmt.Println(s2, len(s1), cap(s1))

    s3 := make([]int, 6) // len == cap here
    fmt.Println(s3, len(s3), cap(s3))
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// [0 1 2 3 0 0 0 0 100] 9 9                      //
// [0 0 0 0 0 0] 9 9                              //
// [0 0 0 0 0 0] 6 6                              //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>直接创建slice是非常"经济"的一件事情,因为大部分情况下都是用slice的,实在想使
用数组还可以使用指针来直接访问数组
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    s := []int{0, 1, 2, 3}

    p := &amp;s[2] // *int, got underlying array pointer
    *p += 100

    fmt.Println(s)
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// [0 1 102 3]                                    //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>我们看到了[]里面没有东西是slice的特点,所以[][]T的类型是'[]T的数组'
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    data := [][]int{
        []int{1, 2, 3},
        []int{100, 200},
        []int{11, 22, 33, 44},
    }
    fmt.Println(data)
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// [[1 2 3] [100 200] [11 22 33 44]]              //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>可以直接更改struct数组(或slice)的内部成员
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    d := [5]struct {
        x int
    }{}

    s := d[:]

    d[1].x = 10
    s[2].x = 20

    fmt.Println(d)
    fmt.Printf("%p, %p\n", &amp;d, &amp;d[0])
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// [{0} {10} {20} {0} {0}]                        //
// 0xc082003f80, 0xc082003f80                     //
////////////////////////////////////////////////////
</pre>
</div>
</li>
</ul>
</div>
<div id="outline-container-sec-4-2-1" class="outline-4">
<h4 id="sec-4-2-1">reslice</h4>
<div class="outline-text-4" id="text-4-2-1">
<ul class="org-ul">
<li>所谓reslice是基于已有slice创建新的slice对象.以便在cap允许范围内调整属性,每
次获得新的slice,其len,cap等属性都会变化:
<ul class="org-ul">
<li>代码如下:每次创建的新slice其[low,high,max]都会有所改动.
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    s := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    fmt.Println(s, len(s), cap(s))

    s1 := s[2:5]
    fmt.Println(s1, len(s1), cap(s1))
    s2 := s1[2:6:7]
    fmt.Println(s2, len(s2), cap(s2))
    // s3 := s2[3:6]                    // Error out of range
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// [0 1 2 3 4 5 6 7 8 9] 10 10                    //
// [2 3 4] 3 8                                    //
// [4 5 6 7] 4 5                                  //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>图例如下最后s2已经变成4,5,6,7, size为4, cap为7了,所以你的s3超过了我s2的cap
<pre class="example">
     +-+-+-+-+-+-+-+-+-+-+
data |0|1|2|3|4|5|6|7|8|9|
     +-+-+-+-+-+-+-+-+-+-+
         +-+-+-+-+-+-+-+-+
s1       |2|3|4| | | | | | len = 3, cap = 8
         +-+-+-+-+-+-+-+-+
             +-+-+-+-+-+
s2           |4|5|6|7| |   len = 4, cap = 5
             +-+-+-+-+-+
                   +-+-+-+
s3                 |7|8|X| error: slice bounds out of range
                   +-+-+-+
</pre>
</li>
</ul>
</li>
<li>新的对象,依然是指向底层数组
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    s := []int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}

    s1 := s[2:5]
    s1[2] = 100

    s2 := s1[2:6]
    s2[3] = 200

    fmt.Println(s)
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// [0 1 2 3 100 5 6 200 8 9]                      //
////////////////////////////////////////////////////
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-2-2" class="outline-4">
<h4 id="sec-4-2-2">append</h4>
<div class="outline-text-4" id="text-4-2-2">
<ul class="org-ul">
<li>向slice尾部添加数据,返回新的slice对象,简单点说,就是在array[high..cap]之间
写数据
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    data := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    s := data[:3]
    s2 := append(s, 100, 200)

    fmt.Println(data)
    fmt.Println(s)
    fmt.Println(s2)
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// [0 1 2 100 200 5 6 7 8 9]                      //
// [0 1 2]                                        //
// [0 1 2 100 200]                                //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>我们也很容易想到,如果超过cap的限制,那么肯定不能再使用原来的数组了,而是要申
请新的数组,当然,这个过程是自动的
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    data := [...]int{0, 1, 2, 3, 4, 10: 0}
    s := data[:2:3]

    s = append(s, 100, 200) // append two, exceed cap
    fmt.Println(s, data)
    fmt.Println(&amp;s[0], &amp;data[0])
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// [0 1 100 200] [0 1 2 3 4 0 0 0 0 0 0]          //
// 0x8201ea210 0x8201ee180                        //
////////////////////////////////////////////////////
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-2-3" class="outline-4">
<h4 id="sec-4-2-3">copy</h4>
<div class="outline-text-4" id="text-4-2-3">
<ul class="org-ul">
<li>函数copy在两个slice之间复制数据.其实就是把srcSlice的底层数组保存一份到
destSlice的底层数组上,然后srcSlice就可以释放了
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    data1 := [...]int{0, 1, 2, 3, 4, 5, 6, 7, 8, 9}
    s1 := data1[:]
    fmt.Println(s1)
    data2 := [...]int{10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20}
    s2 := data2[:]
    fmt.Println(s2)

    copy(s1, s2) // copy s1 from s2

    fmt.Println(s1)
    fmt.Println(s2)
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// [0 1 2 3 4 5 6 7 8 9]                          //
// [10 11 12 13 14 15 16 17 18 19 20]             //
// [10 11 12 13 14 15 16 17 18 19]                //
// [10 11 12 13 14 15 16 17 18 19 20]             //
////////////////////////////////////////////////////
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-4-3" class="outline-3">
<h3 id="sec-4-3">Map</h3>
<div class="outline-text-3" id="text-4-3">
<ul class="org-ul">
<li>map是引用类型.键是支持(==, !=)的类型(比如number, string, pointer, array,
struct), 值可以是任意类型
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    m := map[int]struct {
        name string
        age  int
    }{
        1: {"user1", 10},
        2: {"user2", 20},
    }

    fmt.Println(m[1].name)
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// user1                                          //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>预先给make函数一个合理的元素数量参数,有助于提高性能,因为这会事先分配一大块
内存,而不是后续频繁扩张
<div class="org-src-container">

<pre class="src src-go">m := make(map[string]int, 1000)
</pre>
</div>
</li>
<li>常见的查询(注意m["a"]是返回两个值的,不过通常不用第二个返回值error),删除等操
作如下
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    m := map[string]int{
        "a": 1,
    }

    if v, ok := m["a"]; ok { // m["a"] will return two value!
        fmt.Println(v)
    }

    fmt.Println(m["c"])

    m["b"] = 2
    delete(m, "c")
    fmt.Println(len(m))

    for k, v := range m {
        fmt.Println(k, v)
    }
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// 1                                              //
// 0                                              //
// 2                                              //
// a 1                                            //
// b 2                                            //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>从map中取回的value是一个临时值,所以对其成员的修改是没有意义的, 所以更改map
内容的方法看起来有些奇怪
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func main() {
    type user struct{ name string }

    m := map[int]user{
        1: {"user1"},
    }

    fmt.Println(m)

    // m[1].name = "Tom"            // cannot assign to m[1].name
    u := m[1]
    u.name = "Tom"
    m[1] = u
    fmt.Println(m)

    m2 := map[int]*user{
        1: &amp;user{"user1"},
    }
    fmt.Println(m2[1])

    m2[1].name = "Jack"

    fmt.Println(m2[1])
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// map[1:{user1}]                                 //
// map[1:{Tom}]                                   //
// &amp;{user1}                                       //
// &amp;{Jack}                                        //
////////////////////////////////////////////////////
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-4" class="outline-3">
<h3 id="sec-4-4">Struct</h3>
<div class="outline-text-3" id="text-4-4">
<ul class="org-ul">
<li>struct也是值类型,赋值和传参数都会复制全部内容.可用'_'定义补位字段
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

type Node struct {
    _    int
    id   int
    data *byte
    next *Node
}

func main() {
    n1 := Node{
        id:   1,
        data: nil,
    }

    n2 := Node{
        id:   2,
        data: nil,
        next: &amp;n1,
    }

    fmt.Println(n1)
    fmt.Println(n2)
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// {0 1 &lt;nil&gt; &lt;nil&gt;}                              //
// {0 2 &lt;nil&gt; 0x82024a020}                        //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>初始化的时候,要包含全部的成员
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

type User struct {
    name string
    age  int
}

func main() {
    u1 := User{"Tom", 20}
    fmt.Println(u1)

    // u2 := User{"Tom"} // too few values in struct initializer
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// {Tom 20}                                       //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>struct里面还可以有匿名struct
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

type File struct {
    name string
    size int
    attr struct {
        perm int
        ower int
    }
}

func main() {
    f := File{
        name: "test.txt",
        size: 1025,
    }

    var attr = struct {
        perm int
        ower int
    }{2, 0755}

    fmt.Println(f)
    f.attr = attr
    fmt.Println(f)
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// {test.txt 1025 {0 0}}                          //
// {test.txt 1025 {2 493}}                        //
////////////////////////////////////////////////////
</pre>
</div>
</li>
</ul>
</div>
<div id="outline-container-sec-4-4-1" class="outline-4">
<h4 id="sec-4-4-1">匿名字段</h4>
<div class="outline-text-4" id="text-4-4-1">
<ul class="org-ul">
<li>匿名字段,就是某个struct里面的字段和"另外一个类型名字相同(可以是任意类型)"
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

type User struct {
    name string
}

type Manager struct {
    User
    title string
}

func main() {

    m := Manager{
        User:  User{"Tom"},
        title: "Administrator",
    }

    fmt.Println(m)
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// {{Tom} Administrator}                          //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>嵌套匿名类,访问起来,就是逐级访问
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

type Resource struct {
    id   int
    name string
}

type Classify struct {
    id int
}

type User struct {
    Resource
    Classify
    name string
}

func main() {
    u := User{
        Resource{1, "people"},
        Classify{100},
        "Jack",
    }

    fmt.Println(u.name)
    fmt.Println(u.Resource.name)
    // fmt.Println(u.id)            //  ambiguous selector u.id
    fmt.Println(u.Classify.id)
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// Jack                                           //
// people                                         //
// 100                                            //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>不能同时嵌套同一类型和其指针类型,因为他们名字相同
<div class="org-src-container">

<pre class="src src-go">type Resource struct {
    id int
}

type User struct {
    *Resource
    // Resource // Error: duplicate field Resource
    name string
}
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-4-4-2" class="outline-4">
<h4 id="sec-4-4-2">面向对象</h4>
<div class="outline-text-4" id="text-4-4-2">
<ul class="org-ul">
<li>面向对象的三大特征(继承,多肽,封装)里面, GO仅仅支持封装
</li>
<li>尽管匿名字段的内存布局和行为特征,类似继承,但是没有class关键字,也没有多肽,继承
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

type User struct {
    id   int
    name string
}

type Manager struct {
    User
    title string
}

func main() {

    m := Manager{User{1, "Tom"}, "Administrator"}
    fmt.Println(m)
    // cannot use m (type Manager) as type User in assignment,
    // no Polymorphism here
    // var u User = m

}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// {{1 Tom} Administrator}                        //
////////////////////////////////////////////////////
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="outline-container-sec-5" class="outline-2">
<h2 id="sec-5">第五章 方法</h2>
<div class="outline-text-2" id="text-5">
</div><div id="outline-container-sec-5-1" class="outline-3">
<h3 id="sec-5-1">方法定义</h3>
<div class="outline-text-3" id="text-5-1">
<ul class="org-ul">
<li>方法总是绑定对象实例,并将这个实例作为第一实际参数(receiver)
</li>
<li>方法有其如下特点:
<ul class="org-ul">
<li>只能为当前包内存在的命名类型定义方法
</li>
<li>参数receiver可任意命名,如方法中没有使用这个receiver,也可以只定义不给名字
</li>
<li>参数receiver可以是类型T或是T* (其中T不能是接口或者指针)
</li>
<li>不支持方法重载
</li>
<li>可用实例value或者pointer调用全部方法,编译器自动转换
</li>
</ul>
</li>
<li>go没有ctor和dtor,一般使用"简单工厂模式"返回对象实例
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

type Queue struct {
    elements []interface{}
}

func NewQueue() *Queue {
    return &amp;Queue{make([]interface{}, 10)}
}

func (*Queue) Push(e interface{}) error {
    panic("not implemented")
}

func (self *Queue) length() int {
    return len(self.elements)
}

func main() {
    q := NewQueue()
    fmt.Printf("%d\n", q.length())
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// 10                                             //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>方法其实就是"第一个参数为receiver的函数", 而且receiver为T的时候是copy by value
而receiver为T*的时候,是copy by reference
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

type Data struct {
    x int
}

func (self Data) ValueTest() {
    // Pass by Value, &amp;self is changing
    fmt.Printf("Value: %p\n", &amp;self)
}

func (self *Data) PointerTest() {
    // Pass by reference, self is always the same
    fmt.Printf("Pointer: %p\n", self)
}

func main() {
    d := Data{}
    p := &amp;d
    fmt.Printf("Data: %p\n", p)

    d.ValueTest()
    d.PointerTest()

    p.ValueTest()
    p.PointerTest()

}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// Data: 0x82024c220                              //
// Value: 0x82024c240                             //
// Pointer: 0x82024c220                           //
// Value: 0x82024c250                             //
// Pointer: 0x82024c220                           //
////////////////////////////////////////////////////
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-2" class="outline-3">
<h3 id="sec-5-2">匿名字段</h3>
<div class="outline-text-3" id="text-5-2">
<ul class="org-ul">
<li>一个struct内部有匿名字段的话,这个struct可以直接访问这个匿名字段的函数,就像
访问自己的函数一样.(用组合的方式实现了继承)
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

type User struct {
    id   int
    name string
}

type Manager struct {
    User
}

func (self *User) ToString() string {
    return fmt.Sprintf("User: %p, %v", self, self)
}

func main() {
    m := Manager{User{1, "Tom"}}

    fmt.Printf("Manager: %p\n", &amp;m)
    fmt.Println(m.ToString())
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// Manager: 0x820258000                           //
// User: 0x820258000, &amp;{1 Tom}                    //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>继承的好处当然就是可以override 函数,我们通过为两个不同的struct(两者有相互包
含的关系)定义名字相同的方法来实现了override
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

type User struct {
    id   int
    name string
}

type Manager struct {
    User
    title string
}

func (self *User) ToString() string {
    return fmt.Sprintf("User: %p, %v", self, self)
}

func (self *Manager) ToString() string {
    return fmt.Sprintf("Manager: %p, %v", self, self)
}

func main() {
    m := Manager{User{1, "Tom"}, "Administrator"}

    fmt.Println(m.ToString())
    fmt.Println(m.User.ToString())
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// Manager: 0x8201ec0c0, &amp;{{1 Tom} Administrator} //
// User: 0x8201ec0c0, &amp;{1 Tom}                    //
////////////////////////////////////////////////////
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-3" class="outline-3">
<h3 id="sec-5-3">方法集</h3>
<div class="outline-text-3" id="text-5-3">
<ul class="org-ul">
<li>每个类型和其方法之间的关系:
<ul class="org-ul">
<li>类型T方法集包含全部receiver T方法
</li>
<li>类型*T方法集包含全部receiver T + *T方法
</li>
<li>如果类型S包含匿名字段T,则S方法包含T 方法
</li>
<li>如果类型S包含匿名字段*T,则S方法包含T + *T方法
</li>
<li>不管嵌入T或者*T, *S方法总能包含T + *T方法
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-5-4" class="outline-3">
<h3 id="sec-5-4">表达式</h3>
<div class="outline-text-3" id="text-5-4">
<ul class="org-ul">
<li>方法有如下两种"等价"的表达方式
<ul class="org-ul">
<li>instance.method(args&#x2026;)
</li>
<li>&lt;type&gt;.func(instance, args)
</li>
</ul>
</li>
<li>其实也很好理解,因为方法定义的时候,就和func一样(只不过前面多个type,可以是T也
可以是*T), 而调用的时候,则可以一来instance.method, 二来&lt;T&gt;.func(instance)
</li>
<li>method的调用例子如下:
<ul class="org-ul">
<li>使用*T的情况:
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

type User struct {
id   int
name string
}

func (self *User) Test() {
fmt.Printf("%p, %v\n", self, self)
}

func main() {
u := User{1, "Tom"}
u.Test()

mValue := u.Test
mValue()

//use *T
mExpression := (*User).Test
//&amp;u is the intance of (*T)
mExpression(&amp;u)

}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// 0x8201e41a0, &amp;{1 Tom}                          //
// 0x8201e41a0, &amp;{1 Tom}                          //
// 0x8201e41a0, &amp;{1 Tom}                          //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>使用T的情况, 我们可以看到这种情况下是pass-by-value
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

type User struct {
    id   int
    name string
}

func (self User) Test() {
    fmt.Printf("%p, %v\n", &amp;self, self)
}

func main() {
    u := User{2, "Jacky"}
    u.Test()

    mValue := u.Test
    mValue()

    mExpression := (User).Test
    mExpression(u)
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// 0x8201e41a0, {2 Jacky}                         //
// 0x8201e4200, {2 Jacky}                         //
// 0x8201e4240, {2 Jacky}                         //
////////////////////////////////////////////////////
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
</div>
<div id="outline-container-sec-6" class="outline-2">
<h2 id="sec-6">第六章 接口</h2>
<div class="outline-text-2" id="text-6">
</div><div id="outline-container-sec-6-1" class="outline-3">
<h3 id="sec-6-1">接口定义</h3>
<div class="outline-text-3" id="text-6-1">
<ul class="org-ul">
<li>接口是一个或者多个方法签名的集合
</li>
<li>任何类型的方法只要拥有与接口A"相同的"全部方法,就表示它"实现"了这个接口.注意,
实现某接口并不需要在该类型上显示添加接口声明
</li>
<li>判断两个方法是否相同.主要是看:
<ul class="org-ul">
<li>名称相同
</li>
<li>参数列表相同
</li>
<li>返回值相同
</li>
</ul>
</li>
<li>go里面的接口也有如下的特点:
<ul class="org-ul">
<li>接口命名是以er结尾
</li>
<li>接口只有方法签名,没有实现
</li>
<li>接口没有数据字段
</li>
<li>接口中可以嵌入其他接口
</li>
<li>类型可以"实现"多个接口
</li>
</ul>
</li>
<li>下面是一个接口的例子
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

type Stringer interface {
    String() string
}

type Printer interface {
    Stringer
    Print()
}

type User struct {
    id   int
    name string
}

func (self *User) String() string {
    return fmt.Sprintf("user %d, %s", self.id, self.name)
}

func (self *User) Print() {
    fmt.Println(self.String())
}

func main() {
    var t Printer = &amp;User{1, "Tom"}
    t.Print()
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// user 1, Tom                                    //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>空接口interface{}没有任何方法的签名,这也就意味着任何的类型都是实现了空接口.
其作用类似面向对象语言中的根对象object (也类似c语言里面的void*)
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

func Print(v interface{}) {
    fmt.Printf("%T: %v\n", v, v)
}

func main() {
    Print(1)
    Print("Hello World!")
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// int: 1                                         //
// string: Hello World!                           //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>匿名接口可以作为变量类型, 变量类型也可以是strcut的一部分, 下面例子中匿名
interface类型类型的变量s是Tester的唯一成员. 而User实现了这个interface的唯一
函数String(),那么就我们说s和User的类型是一样的
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

type Tester struct {
    s interface {
        String() string
    }
}

type User struct {
    id   int
    name string
}

func (self *User) String() string {
    return fmt.Sprintf("user %d, %s", self.id, self.name)
}

func main() {
    t := Tester{&amp;User{1, "Tom"}}
    fmt.Println(t.s.String())
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// user 1, Tom                                    //
////////////////////////////////////////////////////
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-2" class="outline-3">
<h3 id="sec-6-2">执行机制</h3>
<div class="outline-text-3" id="text-6-2">
<ul class="org-ul">
<li>接口对象由两个指针组成:
<ul class="org-ul">
<li>接口返回临时对象, 数据指针持有的是目标对象的只读复制品,比如下例中的i其为
interface u直接返回的临时对象.更改原interface不会影响i
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

type User struct {
    id   int
    name string
}

func main() {
    u := User{1, "Tom"}
    var i interface{} = u

    u.id = 2
    u.name = "Jack"

    fmt.Printf("%v\n", u)
    fmt.Printf("%v\n", i.(User))
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// {2 Jack}                                       //
// {1 Tom}                                        //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>只有使用指针才能修改其状态
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

type User struct {
    id   int
    name string
}

func main() {
    u := User{1, "Tom"}
    var vi, pi interface{} = u, &amp;u

    // vi.(User).name = "Jack" // Error: cannot assign to vi.(User).name
    pi.(*User).name = "Jack"

    fmt.Printf("%v\n", vi.(User))
    fmt.Printf("%v\n", pi.(*User))
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// {1 Tom}                                        //
// &amp;{1 Jack}                                      //
////////////////////////////////////////////////////
</pre>
</div>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-3" class="outline-3">
<h3 id="sec-6-3">接口转换</h3>
<div class="outline-text-3" id="text-6-3">
<ul class="org-ul">
<li>利用类型推断,可以判断某个对象是否"实现"了某个接口
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

type User struct {
    id   int
    name string
}

func (self *User) String() string {
    return fmt.Sprintf("%d, %s", self.id, self.name)
}

func main() {
    var o interface{} = &amp;User{1, "Tom"}

    //////////////////////////////////
    // Source Code for golang       //
    // type Stringer interface {    //
    //  String() string             //
    // }                            //
    //////////////////////////////////

    if i, ok := o.(fmt.Stringer); ok {
        fmt.Println(i)
    }

    u := o.(*User)

    // u := o.(User)  // panic: interface conversion: interface is *main.User, not main.User
    fmt.Println(u)
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// 1, Tom                                         //
// 1, Tom                                         //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>还可以使用switch做批量类型判断
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

type User struct {
    id   int
    name string
}

func main() {
    var o interface{} = &amp;User{1, "Tom"}

    switch v := o.(type) {
    case nil:
        fmt.Println("nil")
    case fmt.Stringer: // interface
        fmt.Println(v)
    case func() string: // func
        fmt.Println(v())
    case *User: // struct
        fmt.Printf("%d, %s\n", v.id, v.name)
    default:
        fmt.Println("unknown")
    }

}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// 1, Tom                                         //
////////////////////////////////////////////////////
</pre>
</div>
</li>
<li>超集接口(父类)可以转换为子集接口(子类),这也是模仿OO的特性
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

type Stringer interface {
    String() string
}

type Printer interface {
    String() string
    Print()
}

type User struct {
    id   int
    name string
}

func (self *User) String() string {
    return fmt.Sprintf("%d, %v", self.id, self.name)
}

func (self *User) Print() {
    fmt.Println(self.String())
}

func main() {
    var o Printer = &amp;User{1, "Tom"}
    var s Stringer = o
    fmt.Println(s.String())
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// 1, Tom                                         //
////////////////////////////////////////////////////
</pre>
</div>
</li>
</ul>
</div>
</div>
<div id="outline-container-sec-6-4" class="outline-3">
<h3 id="sec-6-4">接口检查</h3>
<div class="outline-text-3" id="text-6-4">
<ul class="org-ul">
<li>可以使用如下的办法(转换nil 为Data类型的nil)来检查Data类型到底实现了Stringer没有
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

type Data struct {
    id int
}

func (self Data) String() string {
    return ""
}

func main() {
    // fmt.Stringer is interface type, _ is variable, but we don't
    // care about it.
    var _ fmt.Stringer = (*Data)(nil)

    // IF String() is not implemented =&gt;
    // *Data does not implement fmt.Stringer (missing String method)
}
</pre>
</div>
</li>
<li>还可以让函数"typedef"成type,然后来"实现"接口.很绕口的使用方法
<div class="org-src-container">

<pre class="src src-go">package main

import "fmt"

type Tester interface {
    Do()
}

// Regard function AS type
type FuncDo func()

// the function implement the interface!
// then call itself!
func (self FuncDo) Do() { self() }

func main() {
    // t is Tester type
    // FuncDo implement the Do(), it is also the Tester type
    var t Tester = FuncDo(func() { fmt.Println("Hello World") })
    t.Do()
}

////////////////////////////////////////////////////
// &lt;===================OUTPUT===================&gt; //
// Hello World                                    //
////////////////////////////////////////////////////
</pre>
</div>
</li>
</ul>
</div>
</div>
</div>
</div>
<div id="postamble" class="status">

         <!-- Disqus Comment BEGIN -->
          <div id="disqus_thread"></div>
          <script type="text/javascript">
              var disqus_shortname = 'harrifeng';

              (function() {
                  var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true;
                  dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
                  (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
              })();
          </script>
          <noscript>Please enable JavaScript to view the <a href="http://disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>

         <!-- Disqus Comment END -->
</div>
</body>
</html>
